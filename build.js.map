{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap f60e1f6e61bc63669b1a","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/process/browser.js","webpack:///src/App.vue","webpack:///(webpack)/buildin/amd-define.js","webpack:///./src/main.js","webpack:///./node_modules/vue/dist/vue.esm.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./src/App.vue","webpack:///./src/App.vue?0de8","webpack:///./src/App.vue?dc3d","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/vue-style-loader/lib/addStylesClient.js","webpack:///./node_modules/vue-style-loader/lib/listToStyles.js","webpack:///./node_modules/vue-loader/lib/component-normalizer.js","webpack:///./node_modules/ace-builds/src-noconflict/ace.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/aceHandler.js","webpack:///./node_modules/vm-browserify/index.js","webpack:///./node_modules/util/util.js","webpack:///./node_modules/util/support/isBufferBrowser.js","webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js","webpack:///./src/App.vue?e5f2"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","g","this","Function","eval","e","window","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace__","__WEBPACK_IMPORTED_MODULE_1__aceHandler__","data","editor","shellInput","aceHandler","commands","mounted","set","setTheme","session","setMode","methods","runCommand","_this","command","split","par","document","createElement","appendChild","createTextNode","style","getElementsByClassName","toLowerCase","forEach","printOutput","innerHTML","Math","random","splice","runCode","getValue","result","includes","functionName","functionArgs","substring","map","arg","trim","charAt","parseInt","runFunction","getElementById","scrollTop","scrollHeight","str","className","value","__WEBPACK_IMPORTED_MODULE_0_vue__","__WEBPACK_IMPORTED_MODULE_1__App_vue__","Vue","el","render","h","App","global","setImmediate","isUndef","v","undefined","isDef","isTrue","isFalse","isPrimitive","isObject","obj","isPlainObject","_toString","isRegExp","isValidArrayIndex","val","parseFloat","String","floor","isFinite","isPromise","then","catch","toString","isArray","JSON","stringify","toNumber","isNaN","makeMap","expectsLowerCase","create","list","remove","arr","item","index","indexOf","hasOwn","key","cached","fn","cache","polyfillBind","ctx","boundFn","a","_length","nativeBind","bind","toArray","start","ret","extend","to","_from","toObject","res","b","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","every","Date","getTime","keysA","keys","keysB","looseIndexOf","called","isReserved","charCodeAt","def","writable","parsePath","path","bailRE","test","segments","isNative","Ctor","pushTarget","target","targetStack","Dep","popTarget","pop","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","children","slice","text","elm","context","componentOptions","asyncFactory","ns","isStatic","isComment","fnContext","fnOptions","fnScopeId","asyncMeta","isCloned","toggleObserving","shouldObserve","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","shallow","dep","getOwnPropertyDescriptor","setter","childOb","depend","dependArray","newVal","notify","max","del","mergeData","from","toVal","fromVal","hasSymbol","Reflect","ownKeys","mergeDataOrFn","parentVal","childVal","vm","instanceData","defaultData","mergeHook","dedupeHooks","hooks","mergeAssets","normalizeProps","options","props","camelize","type","normalizeInject","inject","normalized","normalizeDirectives","dirs","directives","def$$1","update","mergeOptions","parent","child","mergeField","strat","strats","defaultStrat","_base","extends","mixins","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","booleanIndex","getTypeIndex","Boolean","hyphenate","stringIndex","getPropDefaultValue","prevShouldObserve","default","$options","_props","getType","match","isSameType","expectedTypes","handleError","err","info","cur","$parent","errorCaptured","capture","globalHandleError","invokeWithErrorHandling","handler","_handled","config","errorHandler","logError","inBrowser","inWeex","console","error","flushCallbacks","pending","copies","callbacks","cb","_resolve","timerFunc","Promise","resolve","traverse","_traverse","seenObjects","clear","seen","isA","isFrozen","depId","has","add","createFnInvoker","fns","invoker","arguments$1","updateListeners","oldOn","remove$$1","createOnceHandler","old","event","normalizeEvent","passive","params","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","merged","extractPropsFromVNodeData","attrs","altKey","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","node","nestedIndex","lastIndex","last","shift","_isVList","initProvide","provide","_provided","initInjections","resolveInject","provideKey","source","provideDefault","resolveSlots","slots","slot","name$1","isWhitespace","normalizeScopedSlots","normalSlots","prevSlots","hasNormalSlots","isStable","$stable","$key","_normalized","emptyObject","$hasNormal","key$1","normalizeScopedSlot","key$2","proxyNormalSlot","proxy","renderList","Symbol","iterator","next","done","renderSlot","fallback","bindObject","nodes","scopedSlotFn","$scopedSlots","$slots","$createElement","resolveFilter","identity","isKeyNotMatch","expect","actual","checkKeyCodes","eventKeyCode","builtInKeyCode","eventKeyName","builtInKeyName","mappedKeyCode","keyCodes","bindObjectProps","asProp","isSync","isReservedAttribute","mustUseProp","domProps","camelizedKey","hyphenatedKey","$event","renderStatic","isInFor","_staticTrees","tree","staticRenderFns","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","bindObjectListeners","existing","ours","resolveScopedSlots","hasDynamicKeys","contentHashKey","bindDynamicKeys","baseObj","values","prependModifier","symbol","installRenderHelpers","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","createEmptyVNode","_u","_g","_d","_p","FunctionalRenderContext","contextVm","this$1","_original","isCompiled","_compiled","needNormalization","injections","scopedSlots","_scopeId","_c","createFunctionalComponent","mergeProps","renderContext","cloneAndMarkFunctionalResult","vnodes","clone","createComponent","baseCtor","cid","resolveAsyncComponent","createAsyncPlaceholder","resolveConstructorOptions","model","transformModel","functional","nativeOn","abstract","installComponentHooks","createComponentInstanceForVnode","_isComponent","_parentVnode","inlineTemplate","hooksToMerge","toMerge","componentVNodeHooks","_merged","mergeHook$1","f1","f2","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","is","SIMPLE_NORMALIZE","$vnode","getTagNamespace","isReservedTag","parsePlatformTagName","pre","applyNS","registerDeepBindings","force","class","initRender","_vnode","parentVnode","_renderChildren","parentData","_parentListeners","ensureCtor","comp","base","toStringTag","factory","errorComp","resolved","owner","currentRenderingInstance","owners","loading","loadingComp","sync","timerLoading","timerTimeout","$on","forceRender","renderCompleted","$forceUpdate","reject","reason","component","delay","isAsyncPlaceholder","getFirstComponentChild","initEvents","_events","_hasHookEvent","updateComponentListeners","remove$1","$off","_target","onceHandler","oldListeners","setActiveInstance","prevActiveInstance","activeInstance","initLifecycle","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","hydrating","$el","callHook","updateComponent","_update","_render","Watcher","before","updateChildComponent","renderChildren","newScopedSlots","oldScopedSlots","hasDynamicScopedSlot","needsForceUpdate","$attrs","$listeners","propKeys","_propKeys","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","j","$emit","resetSchedulerState","activatedChildren","waiting","flushing","flushSchedulerQueue","currentFlushTimestamp","getNow","watcher","sort","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","devtools","queueActivatedComponent","queueWatcher","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","initMethods","initData","_data","computed","initComputed","watch","nativeWatch","initWatch","propsOptions","isRoot","getData","watchers","_computedWatchers","isSSR","userDef","computedWatcherOptions","defineComputed","shouldCache","createComputedGetter","createGetterInvoker","dirty","evaluate","createWatcher","expOrFn","$watch","initInternalComponent","constructor","vnodeComponentOptions","_componentTag","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","sealed","sealedOptions","_init","initUse","use","plugin","installedPlugins","_installedPlugins","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","keepAliveInstance","filter","cachedNode","pruneCacheEntry","current","cached$$1","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","isSVG","isUnknownElement","unknownElementCache","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createComment","insertBefore","newNode","referenceNode","removeChild","nextSibling","setTextContent","textContent","setStyleScope","scopeId","registerRef","isRemoval","ref","refs","refInFor","sameVnode","sameInputType","typeA","typeB","isTextInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","oldArg","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","join","updateAttrs","inheritAttrs","oldAttrs","setAttr","isIE","isEdge","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","baseSetAttr","isBooleanAttr","isFalsyAttrValue","convertEnumeratedValue","setAttributeNS","isIE9","__ieph","blocker","stopImmediatePropagation","removeEventListener","addEventListener","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","validDivisionCharRE","wrapFilter","baseWarn","msg","range","pluckModuleFunction","_","addProp","dynamic","rangeSetItem","plain","addAttr","dynamicAttrs","addRawAttr","attrsMap","attrsList","addDirective","isDynamicArg","prependModifierMarker","addHandler","important","warn","right","middle","events","native","nativeEvents","newHandler","getRawBindingAttr","rawAttrsMap","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","removeFromMap","getAndRemoveAttrByRegex","attr","end","genComponentModel","number","valueExpression","assignment","genAssignmentCode","parseModel","lastIndexOf","index$1","expressionPos","expressionEndPos","eof","chr","isStringStart","parseString","parseBracket","inBracket","stringQuote","_warn","warn$1","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","selectedVal","code","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","CHECKBOX_RADIO_TOKEN","change","createOnceHandler$1","target$1","remove$2","add$1","useMicrotaskFix","attachedTimestamp","original","_wrapper","currentTarget","timeStamp","ownerDocument","supportsPassive","updateDOMListeners","updateDOMProps","oldProps","childNodes","_value","strCur","shouldUpdateValue","svgContainer","svg","firstChild","checkVal","composing","isNotInFocusAndDirty","isDirtyWithModifiers","notInFocus","activeElement","_vModifiers","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","classList","whitespaceRE","getAttribute","removeClass","tar","replace","resolveTransition","css","autoCssTransition","nextFrame","raf","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","actuallySetSelected","isMultiple","option","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokenValue","tokens","rawTokens","exec","@binding","transformNode","classBinding","genData","transformNode$1","styleBinding","genData$1","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","html","advance","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","endTagLength","stackedTag","reStackedTag","reCache","RegExp","rest$1","all","endTag","shouldIgnoreFirstNewline","chars","textEnd","comment","commentEnd","shouldKeepComment","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","startTagClose","dynamicArgAttribute","attribute","unarySlash","isNonPhrasingTag","unary","shouldDecodeNewlinesForHref","rest","createASTElement","makeAttrsMap","parse","template","closeElement","element","trimEndingWhitespace","inVPre","processed","processElement","root","if","elseif","else","addIfCondition","block","currentParent","forbidden","processIfConditions","slotScope","slotTarget","platformIsPreTag","inPre","postTransforms","lastNode","warn$2","isPreTag","platformMustUseProp","platformGetTagNamespace","maybeComponent","transforms","preTransforms","preserveWhitespace","whitespaceOption","whitespace","comments","outputSourceRange","start$1","guardIESVGBug","isForbiddenTag","processPre","processRawAttrs","processFor","processIf","processOnce","end$1","isTextTag","decodeHTMLCached","lineBreakRE","whitespaceRE$1","processKey","processRef","processSlotContent","processSlotOutlet","processComponent","processAttrs","checkInFor","parseFor","inMatch","forAliasRE","for","alias","stripParensRE","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","condition","ifConditions","slotTargetDynamic","slotBinding","slotRE","getSlotName","emptySlotScopeToken","slotBinding$1","ref$1","dynamic$1","slotContainer","dynamicArgRE","slotName","syncGen","isDynamic","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","preTransformNode","typeBinding","ifCondition","ifConditionExtra","hasElse","elseIfCondition","branch0","cloneASTElement","branch1","branch2","optimize","isStaticKey","genStaticKeysCached","staticKeys","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","i$1","l$1","staticInFor","staticRoot","isBuiltInTag","isDirectChildOfTemplateFor","genHandlers","prefix","staticHandlers","dynamicHandlers","handlerCode","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","isFunctionInvocation","fnInvokeRE","genModifierCode","modifierCode","genGuard","keyModifier","genKeyFilter","genFilterCode","keyVal","keyCode","keyName","keyNames","wrapListeners","bind$1","wrapData","generate","ast","state","CodegenState","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData$2","genChildren","originalPreState","onceId","altGen","altEmpty","genIfConditions","conditions","genTernaryExp","altHelper","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","inlineRenderFns","some","containsSlotChild","needsKey","generatedSlots","genScopedSlot","isLegacySyntax","reverseProxy","checkSkip","altGenElement","altGenNode","el$1","normalizationType$1","getNormalizationType","genNode","needsNormalization","genComment","genText","transformSpecialNewlines","bind$$1","componentName","staticProps","dynamicProps","createFunction","errors","createCompileToFunctionFn","compile","compiled","fnGenErrors","getShouldDecode","href","div","getOuterHTML","outerHTML","container","cloneNode","freeze","camelizeRE","toUpperCase","hyphenateRE","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","performance","warnHandler","ignoredElements","isReservedAttr","async","_lifecycleHooks","unicodeRegExp","hasProto","WXEnvironment","platform","weexPlatform","UA","navigator","userAgent","isIOS","isFF","_isServer","_Set","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Set","uid","subs","addSub","sub","removeSub","addDep","raw","prototypeAccessors","defineProperties","arrayProto","arrayMethods","method","observeArray","arrayKeys","getOwnPropertyNames","walk","items","isUsingMicroTask","MutationObserver","counter","observer","textNode","characterData","once$$1","init","keepAlive","mountedNode","prepatch","$mount","insert","destroy","now","uid$2","isRenderWatcher","deep","user","active","deps","newDeps","depIds","newDepIds","cleanupDeps","tmp","teardown","uid$3","_uid","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","$once","cbs","prevEl","prevVnode","restoreActiveInstance","__patch__","__vue__","$nextTick","patternTypes","KeepAlive","include","exclude","created","destroyed","builtInComponents","configDef","util","defineReactive","delete","observable","ssrContext","emptyStyle","acceptValue","isValidContentEditableValue","math","isHTMLTag","nodeOps","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalizedName","normalize","vendorNames","capName","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","parentElm","refElm","nested","ownerArray","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ref$$1","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","vnodeToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","findIdxInOld","hydrate","postpatch","invokeInsertHook","initial","hasChildNodes","childrenMatch","fullInvoke","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","patchable","i$2","vmodel","directive","_vOptions","prevOptions","curOptions","transition$$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","isNotTextNode","isVShowDirective","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","beforeMount","kept","prevChildren","rawChildren","transitionData","removed","c$1","updated","hasMove","_reflow","body","offsetHeight","propertyName","_hasMove","platformComponents","decoder","regexEscapeRE","open","close","klass$1","style$1","he","decode","ncname","qnameCapture","&lt;","&gt;","&quot;","&amp;","&#10;","&#9;","&#39;","isIgnoreNewlineTag","model$1","modules$1","directives$1","baseOptions","reduce","esc","tab","space","up","down","stop","prevent","self","ctrl","alt","meta","baseDirectives","cloak","createCompiler","baseCompile","finalOptions","tips","tip","compileToFunctions","idToTemplate","mount","documentElement","Timeout","clearFn","_id","_clearFn","scope","setInterval","clearInterval","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","clearImmediate","task","tasksByHandle","nextHandle","registerImmediate","handle","runIfPresent","currentlyRunningATask","doc","attachTo","getPrototypeOf","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","messagePrefix","onGlobalMessage","attachEvent","MessageChannel","channel","port1","port2","script","onreadystatechange","injectStyle","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_13a01a4a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__","normalizeComponent","__vue_styles__","Component","content","locals","cssWithMappingToString","useSourceMap","cssMapping","btoa","sourceMapping","toComment","sources","sourceRoot","sourceMap","unescape","encodeURIComponent","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","parts","addStyle","createStyleElement","styleElement","head","ssrIdKey","isProduction","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","media","styleSheet","replaceText","cssNode","ssrId","hasDocument","DEBUG","listToStyles","getElementsByTagName","parentId","_isProduction","_options","newList","mayRemove","textStore","replacement","newStyles","part","rawScriptExports","compiledTemplate","functionalTemplate","injectStyles","moduleIdentifier","esModule","scriptExports","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","beforeCreate","_injectStyles","define","payload","trace","payloads","_require","lookup","require","packagedModule","normalizeModule","moduleName","chunks","previous","mod","uri","packaged","ace","getNativeFlags","regex","ignoreCase","multiline","extended","sticky","real","compliantExecNpcg","compliantLastIndexIncrement","x","r2","_xregexp","captureNames","Empty","doesDefinePropertyWork","exception","toInteger","abs","that","TypeError","bound","defineGetter","defineSetter","lookupGetter","lookupSetter","supportsAccessors","prototypeOfArray","prototypeOfObject","owns","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","makeArray","lengthBefore","array_splice","deleteCount","removeCount","min","tailOldPos","tailNewPos","tailCount","lengthAfterRemove","boxedString","splitString","thisp","reduceRight","sought","descriptor","createEmpty","empty","propertyIsEnumerable","isPrototypeOf","toLocaleString","valueOf","properties","Type","definePropertyWorksOnObject","definePropertyWorksOnDom","definePropertyFallback","seal","freezeObject","preventExtensions","isSealed","returnValue","hasDontEnumBug","dontEnums","dontEnumsLength","ii","dontEnum","ws","trimBeginRegexp","trimEndRegexp","Element","OS","LINUX","MAC","WINDOWS","getOS","isMac","isLinux","os","ua","isWin","appName","isGecko","isMozilla","isOpera","opera","isWebKit","isChrome","isAIR","isIPad","isAndroid","isChromeOS","MSStream","isMobile","useragent","buildDom","txt","els","childIndex","getDocumentHead","removeChildren","createFragment","createDocumentFragment","hasCssClass","addCssClass","removeCssClass","classes","toggleCssClass","setCssClass","hasCssString","sheets","querySelectorAll","importCssString","getRootNode","importCssStylsheet","rel","scrollbarWidth","inner","width","minWidth","height","outer","position","overflow","noScrollbar","offsetWidth","withScrollbar","clientWidth","computedStyle","setStyle","HAS_CSS_ANIMATION","HAS_CSS_TRANSFORMS","HI_DPI","devicePixelRatio","animationName","translate","tx","ty","round","inherits","ctor","superCtor","super_","implement","proto","oop","Keys","MODIFIER_KEYS","16","17","18","224","KEY_MODS","cmd","FUNCTION_KEYS","8","9","13","19","27","32","33","34","35","36","37","38","39","40","44","45","46","96","97","98","99","100","101","102","103","104","105","-13","112","113","114","115","116","117","118","119","120","121","122","123","144","145","PRINTABLE_KEYS","48","49","50","51","52","53","54","55","56","57","59","61","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","107","109","110","186","187","188","189","190","191","192","219","220","221","222","111","106","escape","mods","pow","keyCodeToString","keyString","fromCharCode","normalizeCommandKeys","hashId","getModifierHash","pressedKeys","getModifierState","altGr","location","keyLocation","ts","dt","defaultPrevented","resetPressedKeys","elem","wrapper","detachEvent","stopEvent","stopPropagation","preventDefault","cancelBubble","getButton","ctrlKey","shiftKey","button","1","2","4","eventHandler","releaseCaptureHandler","onMouseUp","addTouchMoveListener","startx","starty","touches","touchObj","clientX","clientY","wheelX","wheelY","addMouseWheelListener","wheelDeltaX","wheelDeltaY","wheelDelta","deltaMode","DOM_DELTA_PIXEL","deltaX","deltaY","DOM_DELTA_LINE","DOM_DELTA_PAGE","axis","HORIZONTAL_AXIS","detail","addMultiMouseDownListener","elements","timeouts","callbackName","onMousedown","clicks","isNewClick","startX","startY","timer","_clicks","eventNames","onDblclick","3","metaKey","getModifierString","addCommandKeyListener","isOldGecko","lastKeyDownKeyCode","lastDefaultPrevented","postMessageId","win","messageName","listener","$idleBlocked","onIdle","$idleBlockId","blockIdle","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","comparePoints","p1","p2","row","column","Range","startRow","startColumn","endRow","endColumn","isEqual","contains","compare","compareRange","cmp","comparePoint","containsRange","intersects","isEnd","isStart","setStart","setEnd","inside","insideStart","insideEnd","isMultiLine","compareStart","compareEnd","compareInside","clipRows","firstRow","lastRow","fromPoints","isEmpty","collapseRows","toScreenRange","screenPosStart","documentToScreenPosition","screenPosEnd","moveBy","stringReverse","string","reverse","stringRepeat","count","stringTrimLeft","stringTrimRight","copyObject","copy","copyArray","deepCopy","arrayToMap","createMap","arrayRemove","escapeRegExp","escapeHTML","getMatchOffsets","regExp","offset","deferredCall","fcn","deferred","cancel","schedule","isPending","delayedCall","defaultTimeout","dom","lang","BROKEN_SETDATA","USE_IE_MIME_TYPE","HAS_FOCUS_ARGS","KEYS","MODS","valueResetRegex","TextInput","host","cancelComposition","ignoreFocusEvents","blur","focus","onKeyup","selectionStart","inComposition","lastValue","lastSelectionStart","lastSelectionEnd","resetSelection","syncComposition","onContextMenuClose","closeTimeout","tempStyle","renderer","$keepTextAreaAtCursor","$moveTextAreaToCursor","opacity","copied","pasted","sendingText","copyWithEmptySelection","fontSize","commandMode","isFocused","onBlur","hasFocus","onFocus","$focusScroll","preventScroll","isTransformed","ancestors","t","parentElement","curOp","newValue","selectionEnd","selection","setSelectionRange","afterContextMenu","getRange","cursor","line","getLine","prevLine","nextLine","isAllSelected","onSelect","selectAll","inputHandler","setInputHandler","getInputHandler","sendText","fromInput","onPaste","extendLeft","extendRight","restoreStart","restoreEnd","onTextInput","onInput","onCompositionUpdate","MAX_LINE_LENGTH","handleClipboardData","forceIEMime","clipboardData","mime","setData","doCopy","isCut","getCopyText","onCut","onCopy","select","onCommandKey","$readOnly","getSelectionRange","markerRange","useTextareaForIME","msGetInputContext","getInputContext","compositionStartOffset","getElement","setCommandMode","readOnly","setReadOnly","setCopyWithEmptySelection","onContextMenu","_emit","domEvent","moveToMouse","bringToFront","characterWidth","rect","borderTopWidth","borderLeftWidth","maxTop","bottom","clientHeight","move","textInput","scroller","typingResetTimeout","typing","detectArrowKeys","modifier","log","home","DefaultHandlers","mouseHandler","$clickSelection","setDefaultHandler","onMouseDown","onDoubleClick","onTripleClick","onQuadClick","onMouseWheel","onTouchMove","selectByLines","extendSelectionBy","selectByWords","calcDistance","ax","ay","bx","by","sqrt","calcRangeOrientation","anchor","ev","inSelection","getDocumentPosition","mousedownEvent","moveToPosition","time","$focusTimeout","inMultiSelectMode","captureMouse","startSelect","setState","waitForClickSelection","screenToTextCoordinates","y","getShiftKey","selectToPosition","setCapture","orientedRange","setSelectionAnchor","scrollCursorIntoView","unitName","cmpStart","cmpEnd","selectEnd","selectAllEnd","selectByWordsEnd","selectByLinesEnd","unsetStyle","releaseCapture","focusWait","distance","getBracketRange","getWordRange","getLineRange","getAccelKey","$lastScroll","vx","vy","allowed","prevScroll","direction","canScroll","isScrollableBy","speed","isSlower","scrollBy","Tooltip","isOpen","$element","$parentNode","$init","setText","setHtml","setPosition","setClassName","hide","getHeight","getWidth","GutterHandler","showTooltip","mouseEvent","annotation","gutter","$annotations","hideTooltip","getLength","screenRow","pixelToScreenCoordinates","$pos","documentToScreenRow","tooltipAnnotation","tooltip","_signal","$tooltipFollowsMouse","moveTooltip","gutterElement","tooltipTimeout","$gutterLayer","GutterTooltip","getRegion","selectTo","srcElement","isMousePressed","$gutter","windowWidth","innerWidth","windowHeight","innerHeight","MouseEvent","$inSelection","propagationStopped","selectionRange","DragdropHandler","prevCursor","vMovement","hMovement","cursorMovedTime","moveCursorToPosition","cursorPointOnCaretMoved","SCROLL_CURSOR_HYSTERESIS","SCROLL_CURSOR_DELAY","autoScroll","lineHeight","layerConfig","editorRect","offsets","nearestXOffset","nearestYOffset","scrollCursor","vScroll","hScroll","autoScrollStartTime","AUTOSCROLL_DELAY","onDragInterval","dragCursor","addDragMarker","toOrientedRange","dragSelectionMarker","addMarker","getSelectionStyle","clearSelection","$cursorLayer","setBlinking","timerId","onMouseMove","clearDragMarker","removeMarker","fromOrientedRange","isInternal","getReadOnly","onMouseMoveTimer","canAccept","dataTransfer","types","getDropEffect","copyAllowed","moveAllowed","copyModifierState","effectAllowed","dropEffect","blankImage","dragOperation","mouseTarget","onDragStart","cancelDrag","draggable","setDragImage","clearData","getTextRange","onDragEnd","setCursorStyle","onDragEnter","onDragOver","onDragLeave","onDrop","moveText","dropData","dragWait","getDragDelay","startDrag","dragWaitEnd","dragReadyEnd","cursorStyle","onMouseDrag","dragDrop","$dragEnabled","eventTarget","unselectable","url","xhr","XMLHttpRequest","readyState","responseText","send","loadScript","onload","isAbort","qualifyURL","EventEmitter","_dispatchEvent","eventName","_eventRegistry","_defaultHandlers","defaultHandler","newCallback","_disabled_","disabled","removeDefaultHandler","capturing","message","reportError","optionsProvider","setOptions","optList","setOption","getOptions","optionNames","hidden","getOption","opt","forwardTo","handlesSet","AppConfig","$defaultOptions","defineOptions","initialValue","resetOptions","setDefaultValue","setDefaultValues","optionHash","scriptOptions","scriptUrl","currentScript","_currentScript","currentDocument","scripts","attributes","deHyphenate","basePath","workerPath","modePath","themePath","m1","net","suffix","$moduleUrls","loadWorkerFromBlob","$modes","moduleUrl","sep","setModuleUrl","subst","$loading","loadModule","onLoad","moduleType","afterLoad","reportErrorIfPathIsNotConfigured","DefaultGutterHandler","MouseHandler","focusEditor","getMouseEventTarget","onMouseEvent","scrollBarV","scrollBarH","gutterEl","$dragDelay","character","mousemove","$scrollSpeed","mouseMoveHandler","which","releaseMouse","$mouseMoved","onCaptureEnd","onOperationEnd","onCaptureInterval","$onCaptureMouseMove","endOperation","selectionChanged","startOperation","cancelContextMenu","scrollSpeed","dragDelay","dragEnabled","focusTimeout","tooltipFollowsMouse","FoldHandler","fold","getFoldAt","removeFold","expandFold","foldWidgets","onFoldWidgetClick","getParentFoldRangeData","firstRange","addFold","keyUtil","KeyBinding","$editor","$data","$handlers","kb","removeKeyboardHandler","$defaultHandler","addKeyboardHandler","setKeyboardHandler","handleKeyboard","attach","detach","getKeyboardHandler","getStatusText","$callKeyboardHandlers","toExecute","success","passEvent","_computeLevels","levels","charTypes","impTab","impTab_RTL","impTab_LTR","prevState","newClass","newLevel","newState","action","condPos","ix","_getCharacterType","hiLevel","lastArabic","hasUBAT_AL","hasUBAT_B","hasUBAT_S","_getCharClass","B","S","WS","_invertLevel","lev","_array","RTL","lo","hi","wType","nType","cType","L","R","ON","AN","EN","AL","CS","ES","ET","NSM","rtlCandidate","LRE","RLE","LRO","RLO","PDF","BN","uc","UnicodeTBL00","UnicodeTBL20","ON_R","R_H","DOT","doBidiReorder","textCharTypes","isRtl","logicalFromVisual","bidiLevels","hasBidiCharacters","getVisualFromLogicalIdx","logIdx","rowMap","bidiUtil","bidiRE","BidiHandler","bidiMap","currentRow","charWidths","EOL","showInvisibles","isRtlDir","$isRtl","wrapIndent","EOF","contentWidth","fontMetrics","rtlLineOffset","wrapOffset","isMoveLeftOperation","seenBidi","isBidiRow","docRow","splitIndex","updateRowLine","updateBidiMap","onChange","delta","lines","getDocumentRow","rowCache","$screenRowCache","$getRowCacheIndex","$docRowCache","getSplitIndex","currentIndex","prevIndex","isLastRow","endOfLine","$useWrapMode","splits","$wrapData","indent","size","isFullWidth","getScreenTabSize","$main","substr","markAsDirty","updateCharacterWidths","$characterSize","bidiCharWidth","$measureCharWidth","setShowInvisibles","setEolChar","eolChar","setContentWidth","isRtlLine","setRtlDirection","getCursorPosition","getSelectionAnchor","$bidiHandler","removeInLine","getPosLeft","col","leftBoundary","logicalIdx","getOverwrite","visualIdx","getSelections","startCol","endCol","level","selections","selColMin","selColMax","isSelected","isSelectedPrev","visIdx","offsetToCol","posX","charWidth","Selection","getDocument","lead","createAnchor","$silent","$cursorChanged","$isEmpty","$keepDesiredColumnOnChange","$desiredColumn","$anchorChanged","getCursor","getPosition","getAnchor","getSelectionLead","isBackwards","$setSelection","MAX_VALUE","setRange","anchorRow","anchorColumn","cursorRow","cursorColumn","wasEmpty","wasMultiselect","$moveSelection","mover","moveCursorTo","moveTo","selectUp","moveCursorUp","selectDown","moveCursorDown","selectRight","moveCursorRight","selectLeft","moveCursorLeft","selectLineStart","moveCursorLineStart","selectLineEnd","moveCursorLineEnd","selectFileEnd","moveCursorFileEnd","selectFileStart","moveCursorFileStart","selectWordRight","moveCursorWordRight","selectWordLeft","moveCursorWordLeft","selectWord","selectAWord","getAWordRange","excludeLastChar","rowEnd","rowStart","foldLine","getFoldLine","selectLine","moveCursorBy","wouldMoveIntoSoftTab","tabSize","isTabStop","getTabSize","getNavigateWithinSoftTabs","firstColumnPosition","screenToDocumentPosition","beforeCursor","getDisplayLine","leadingSpace","$useEmacsStyleLineStart","lineEnd","getDocumentLastRowColumnPosition","search","moveCursorLongWordRight","rightOfCursor","nonTokenRe","tokenRe","moveCursorLongWordLeft","getFoldStringAt","leftOfCursor","$shortWordEndIndex","whitespaceRe","moveCursorShortWordRight","moveCursorShortWordLeft","$selectLongWords","rows","offsetX","screenPos","docPos","lineWidgets","keepDesiredColumn","moveCursorToScreen","desiredColumn","r","getRangeOfMovements","func","toJSON","rangeCount","ranges","r1","fromJSON","rangeList","toSingleRange","addRange","MAX_TOKEN_COUNT","Tokenizer","rules","states","regExps","matchMappings","ruleRegExps","matchTotal","mapping","defaultToken","flag","splitterRurles","rule","caseInsensitive","adjustedregex","matchcount","token","groupCount","tokenArray","onMatch","$arrayTokens","$applyToken","digit","removeCapturingGroups","splitRegex","createSplitterRegexp","$setMaxTokenCount","inChClass","lastCapture","parenOpen","parenClose","getLineTokens","startState","currentState","matchAttempts","skipped","consumeLineEnd","merge","TextHighlightRules","$rules","addRules","nextState","getRules","embedRules","HighlightRules","escapeRules","append","$embeds","getEmbeds","pushState","popState","normalizeRules","processState","toInsert","stateName","includeName","noEscape","keywordMap","createKeywordMapper","splitChar","keywords","$keywordList","getKeywords","$keywords","Behaviour","$behaviours","addBehaviours","behaviours","inherit","getBehaviours","TokenIterator","initialRow","initialColumn","$session","$row","$rowTokens","getTokens","getTokenAt","$tokenIndex","stepBackward","stepForward","rowCount","getCurrentToken","getCurrentTokenRow","getCurrentTokenColumn","rowTokens","tokenIndex","getCurrentTokenPosition","getCurrentTokenRange","SAFE_INSERT_IN_TOKENS","SAFE_INSERT_BEFORE_TOKENS","contextCache","defaultQuotes","\"","'","initContext","multiSelect","autoInsertedBrackets","autoInsertedRow","autoInsertedLineEnd","maybeInsertedBrackets","maybeInsertedRow","maybeInsertedLineStart","maybeInsertedLineEnd","getWrapped","opening","closing","rowDiff","CstyleBehaviour","getWrapBehavioursEnabled","isSaneInsertion","braces","recordAutoInsert","recordMaybeInsert","rightChar","matching","$findOpeningBracket","isAutoInsertedClosing","popAutoInsertedClosing","isMaybeInsertedClosing","clearMaybeInsertedClosing","openBracePos","findMatchingBracket","next_indent","$getIndent","getTabString","quotes","$mode","$quotes","lineCommentStart","quote","leftChar","rightToken","pair","stringBefore","stringAfter","wordRe","isWordBefore","isWordAfter","$matchTokenType","bracket","wordChars","unicode","Mode","$defaultBehaviour","getTokenizer","$tokenizer","$highlightRules","$highlightRuleConfig","blockComment","toggleCommentLines","iter","ignoreBlankLines","shouldRemove","minIndent","Infinity","insertAtTabStop","regexpStart","getUseSoftTabs","uncomment","shouldInsertSpace","commentWithSpace","insertInLine","testRemove","after","spaces","lineCommentEnd","regexpEnd","minEmptyLength","toggleBlockComment","colDiff","initialRange","startRange","endRange","getNextLineIndent","checkOutdent","input","autoOutdent","createWorker","createModeDelegates","$id","delegations","$delegator","language","transformAction","param","$behaviour","completionKeywords","ruleItr","aLength","$createKeywordList","getCompletions","word","score","applyDelta","docLines","doNotValidate","Anchor","$onChange","$pointsInOrder","point1","point2","equalPointsInOrder","bColIsAfter","$getTransformedPoint","point","moveIfEqual","deltaIsInsert","deltaRowShift","deltaColShift","deltaStart","deltaEnd","$clipPositionToDocument","$insertRight","noClip","Document","textOrLines","$lines","insertMergedLines","setValue","getAllLines","getNewLineCharacter","$split","$detectNewLine","$autoNewLine","$newLineMode","setNewLineMode","newLineMode","getNewLineMode","isNewLine","getLines","getLinesForRange","insertLines","insertFullLines","removeLines","removeFullLines","insertNewLine","clippedPos","clonePos","$clipPosition","deleteFirstNewLine","deleteLastNewLine","deletedLines","removeNewLine","applyDeltas","deltas","revertDeltas","revertDelta","isInsert","$splitAndapplyLargeDelta","MAX","chunk","indexToPosition","newlineLength","positionToIndex","BackgroundTokenizer","tokenizer","running","currentLine","$worker","workerStart","endLine","startLine","processedLines","$tokenizeRow","fireUpdateEvent","setTokenizer","setDocument","first","scheduleStart","$updateOnChange","getState","SearchHighlight","clazz","setRegexp","MAX_RANGES","markerLayer","drawSingleLineMarker","FoldLine","foldData","folds","setFoldLine","shiftRow","sameRow","containsRow","lastEnd","isNewRow","getNextFoldTo","kind","addRemoveChars","foldBefore","newFoldLine","foldLineNext","idxToPosition","idx","lastFoldEndColumn","RangeList","pointIndex","excludeEdges","startIndex","endIndex","addList","substractPoint","containsPoint","rangeAtPoint","clipped","removeAll","lineDif","consumePoint","consumeRange","restorePoint","restoreRange","Fold","subFolds","subFold","collapseChildren","addSubFold","afterStart","Folding","side","getFoldsInRange","foldLines","$foldData","foundFolds","getFoldsInRangeList","getAllFolds","lastFold","startFoldLine","getNextFoldLine","getFoldedRowCount","$addFoldLine","added","$clipRangeToDocument","startFold","endFold","removeFolds","$updateWrapData","$updateRowLengthCache","$modified","addFolds","$updating","cloneFolds","foldAll","expandFolds","unfold","expandInner","isRowFolded","startFoldRow","getRowFoldEnd","getRowFoldStart","getFoldDisplayLine","textLine","lastColumn","$cloneFoldData","fd","toggleFold","tryToUnfold","bracketPos","getCommentFoldRange","depth","getFoldWidget","getFoldWidgetRange","$foldStyles","manual","markbegin","markbeginend","$foldStyle","setFoldStyle","$foldMode","$setFolding","foldMode","$updateFoldWidgets","$tokenizerUpdateFoldWidgets","updateFoldWidgets","tokenizerUpdateFoldWidgets","ignoreCurrent","fw","siblings","$toggleFoldWidget","toggleFoldWidget","toggleParent","BracketMatch","charBeforeCursor","$findClosingBracket","$brackets",")","(","]","[","{","}","<",">","typeRe","openBracket","valueIndex","closingBracket","valueLength","TextMode","EditSession","$breakpoints","$decorations","$frontMarkers","$backMarkers","$markerId","$undoSelect","$uid","onChangeFold","bgTokenizer","resetCaches","$resetRowCache","cacheArray","low","mid","$rowLengthCache","removedFolds","$updateInternalDataOnChange","$fromUndo","$undoManager","mergeUndoDeltas","$informUndoManager","setUndoManager","getUndoManager","reset","getSelection","undoManager","addSession","$syncInformUndoManager","markUndoGroup","$defaultUndoManager","undo","redo","addSelection","startNewGroup","setUseSoftTabs","$useSoftTabs","$indentWithTabs","setTabSize","$tabSize","setNavigateWithinSoftTabs","navigateWithinSoftTabs","$navigateWithinSoftTabs","$overwrite","setOverwrite","overwrite","toggleOverwrite","addGutterDecoration","removeGutterDecoration","getBreakpoints","setBreakpoints","clearBreakpoints","setBreakpoint","clearBreakpoint","inFront","addDynamicMarker","markerId","getMarkers","highlight","$searchHighlight","highlightLines","setAnnotations","annotations","getAnnotations","clearAnnotations","inToken","wordRange","setUseWorker","useWorker","getUseWorker","$useWorker","onReloadTokenizer","$modeId","$onChangeMode","$isPlaceholder","$stopWorker","$startWorker","attachToSession","wrapMethod","$wrapMethod","foldingRules","terminate","getMode","$scrollTop","setScrollTop","getScrollTop","$scrollLeft","setScrollLeft","scrollLeft","getScrollLeft","getScreenWidth","$computeWidth","getLineWidgetMaxWidth","screenWidth","lineWidgetsWidth","w","lineWidgetWidth","$wrapLimit","longestScreenLine","foldIndex","foldStart","$getStringScreenWidth","undoChanges","dontSelect","selectionBefore","$getUndoSelection","redoChanges","selectionAfter","setUndoSelect","enable","isUndo","fromRange","toPosition","toRange","collDiff","oldStart","newStart","indentRows","indentString","outdentRows","rowRange","deleteRange","$moveLines","diff","$clipRowToDocument","moveLinesUp","moveLinesDown","duplicateLines","$clipColumnToRow","$wrapLimitRange","setUseWrapMode","useWrapMode","getUseWrapMode","setWrapLimitRange","adjustWrapLimit","desiredLimit","$printMargin","limits","wrapLimit","$constrainWrapLimit","getWrapLimit","setWrapLimit","limit","getWrapLimitRange","foldLineBefore","walkTokens","$getDisplayTokens","PLACEHOLDER_START","PLACEHOLDER_BODY","$computeWrapSplits","SPACE","TAB","TAB_SPACE","getWrapIndent","indentation","maxIndent","indentedSoftWrap","isCode","addSplit","lastSplit","lastDocSplit","displayLength","$wrapAsCode","$indentedSoftWrap","minSplit","maxScreenColumn","screenColumn","getRowLength","getRowLineCount","getRowWrapIndent","getScreenLastRowColumn","documentToScreenColumn","getDocumentLastRowColumn","docColumn","getRowSplitData","screenToDocumentRow","screenToDocumentColumn","rowLength","doCache","maxRow","foldStartRow","wrapRow","screenRowOffset","getScreenLength","screenRows","$getWidgetScreenLength","$setFontMetrics","fm","$enableVarChar","getCharacterWidth","wrap","$wrap","firstLineNumber","useSoftTabs","foldStyle","addWordBoundary","needle","wordBoundary","Search","find","$matchIterator","sr","sc","er","ec","skipCurrent","findAll","$assembleRegExp","$isMultiLine","prevRange","preserveCase","$disableFakeMultiline","wholeWord","caseSensitive","$assembleMultilineRegExp","backwards","forEachInLine","HashHandler","commandKeyBinding","addCommands","$singleCommand","MultiHashHandler","bindKey","isDefault","addCommand","removeCommand","_buildKeyHash","keepCommand","ckb","keyId","cmdGroup","keyPart","chain","parseKeys","_addCommandToBinding","other","otherPos","removeCommands","bindKeys","keyList","findKeyCommand","$keyChain","CommandManager","byName","$checkCommandState","isAvailable","toggleRecording","$inReplay","recording","macro","$addCommandToMacro","oldMacro","replay","trimMacro","mac","showSettingsMenu","showErrorMarker","scrollIntoView","description","centerSelection","gotoLine","prompt","$type","multiSelectAction","getAllRanges","findNext","findPrevious","aceCommandGroup","navigateFileStart","navigateUp","times","navigateFileEnd","navigateDown","navigateWordLeft","navigateLineStart","navigateLeft","navigateWordRight","navigateLineEnd","navigateRight","selectPageDown","scrollPageDown","gotoPageDown","selectPageUp","scrollPageUp","gotoPageUp","jumpToMatching","cutLine","$copyWithEmptySelection","$handlePaste","duplicateSelection","sortLines","modifyNumber","copyLinesUp","copyLinesDown","removeToLineStart","removeToLineEnd","removeWordLeft","removeWordRight","blockOutdent","blockIndent","splitLine","transposeLetters","transposeSelections","firstLineEndCol","selectedText","selectedCount","insertLine","curLine","newRanges","exitMultiSelectMode","lineMode","defaultCommands","clipboard","Editor","getContainerElement","getTextAreaContainer","textarea","$mouseHandler","keyBinding","$search","$historyTracker","$initOperationListeners","_$emitInputEvent","setSession","$opResetTimer","$lastSel","docChanged","prevOp","commandEvent","previousCommand","scrollSelectionIntoView","animateScrolling","sel","$mergeableCommands","$mergeUndoDeltas","mergeableCommands","shouldMerge","mergeNextCommand","sequenceStartTime","keyboardHandler","$keybindingId","oldSession","$onDocumentChange","$onTokenizerUpdate","$onChangeTabSize","$onChangeWrapLimit","$onChangeWrapMode","$onChangeFold","$onChangeFrontMarker","$onChangeBackMarker","$onChangeBreakpoint","$onChangeAnnotation","$onCursorChange","$onScrollTopChange","$onScrollLeftChange","$onSelectionChange","onDocumentChange","onChangeMode","onTokenizerUpdate","onChangeTabSize","onChangeWrapLimit","onChangeWrapMode","onChangeFrontMarker","onChangeBackMarker","onChangeBreakpoint","onChangeAnnotation","onCursorChange","onScrollTopChange","onScrollLeftChange","onSelectionChange","updateFull","oldEditor","getSession","cursorPos","resize","onResize","theme","getTheme","getFontSize","setFontSize","$highlightBrackets","$bracketHighlight","$highlightPending","getMatching","$highlightTags","$highlightTagPending","$tagHighlight","prevToken","sbm","$isFocused","showCursor","visualizeFocus","hideCursor","visualizeBlur","$cursorChange","updateCursor","updateLines","$updateHighlightActiveLine","scrollToY","scrollToX","$highlightActiveLine","$selectionStyle","$selectionColorConflict","$maxLines","$minLines","$highlightLineMarker","$selectionMarker","$highlightSelectedWord","$getSelectionHighLightRegexp","wordWithBoundary","updateFrontMarkers","updateBackMarkers","updateBreakpoints","updateText","getSelectedText","nl","copyLine","inVirtualSelectionMode","execCommand","getBehavioursEnabled","lineState","shouldOutdent","lineIndent","composition","applyComposition","forEachSelection","setScrollSpeed","getScrollSpeed","setDragDelay","setSelectionStyle","setHighlightActiveLine","shouldHighlight","getHighlightActiveLine","setHighlightGutterLine","getHighlightGutterLine","setHighlightSelectedWord","getHighlightSelectedWord","setAnimatedScroll","shouldAnimate","getAnimatedScroll","getShowInvisibles","setDisplayIndentGuides","getDisplayIndentGuides","setShowPrintMargin","showPrintMargin","getShowPrintMargin","setPrintMarginColumn","getPrintMarginColumn","setBehavioursEnabled","enabled","setWrapBehavioursEnabled","setShowFoldWidgets","getShowFoldWidgets","setFadeFoldWidgets","fade","getFadeFoldWidgets","new_range","swap","originalRange","$getSelectedRows","getNumberAt","_numberRx","amount","charRange","nr","fp","decimals","nnr","toFixed","replaceRange","toggleWord","$toggleWordPairs","currWordStart","wordParts","curLength","itLength","reg","wordPairs","negate","firstCondition","secondCondition","endPoint","totalDiff","rangeIndex","subRows","compositionState","showComposition","setCompositionText","hideComposition","getFirstVisibleRow","getLastVisibleRow","isRowVisible","isRowFullyVisible","getFirstFullyVisibleRow","getLastFullyVisibleRow","$getVisibleRowCount","getScrollBottomRow","getScrollTopRow","$moveByPage","scrollToRow","scrollToLine","center","animate","alignCursor","getCursorPositionScreen","expand","matchType","bracketType","found","brackets","lineNumber","navigateTo","replaced","$tryReplace","replaceAll","getLastSearchOptions","newRange","revealRange","setAutoScrollEditorIntoView","shouldScroll","$scrollAnchor","scrollAnchor","onChangeSelection","onBeforeRender","onAfterRender","searchBox","$pixelPos","$resetCursorStyle","$cursorStyle","cursorLayer","setSmoothBlinking","isBlinking","selectionStyle","highlightActiveLine","highlightSelectedWord","behavioursEnabled","wrapBehavioursEnabled","autoScrollEditorIntoView","showLineNumbers","setShowLineNumbers","$loop","CHANGE_GUTTER","$relativeLineNumbers","relativeNumberRenderer","relativeLineNumbers","$showLineNumbers","hScrollBarAlwaysVisible","vScrollBarAlwaysVisible","highlightGutterLine","animatedScroll","printMarginColumn","printMargin","fadeFoldWidgets","showFoldWidgets","displayIndentGuides","showGutter","fontFamily","maxLines","minLines","scrollPastEnd","fixedWidthGutter","hasCssTransforms","maxPixelHeight","getText","lastLineNumber","$renderer","rearrangeUndoStack","deltaSet","ignore","swapped","swapGroups","cloneDelta","stringifyDelta","stringifyRange","rev","d1","d2","i1","i2","ds1","ds2","xform","c1","splitDelta","shiftPos","rowsBefore","otherLines","moveDeltasByOne","redoStack","xformed","rebaseRedoStack","deltaSets","UndoManager","$maxRev","allowMerge","$lastDelta","lastDeltas","$undoStack","$rev","markIgnored","getRevision","getDeltas","getChangedRanges","getChangedLines","$redoStackBaseRev","$redoStack","undoSelectionRange","$syncRev","redoSelectionRange","nextDelta","mark","canUndo","canRedo","bookmark","isAtBookmark","hasUndo","hasRedo","isClean","markClean","$prettyPrint","Lines","canvasHeight","cells","cellCache","$offsetCoefficient","moveContainer","firstRowScreen","pageChanged","oldConfig","newConfig","computeLineTop","screenTop","screenPage","computeLineHeight","$cacheCell","cell","fragment","insertAdjacentElement","createCell","initElement","onCreateCell","foldWidget","Gutter","parentEl","$showFoldWidgets","gutterWidth","$updateAnnotations","rowInfo","annoText","gutterOffset","oldLastRow","$updateCursorRow","$renderCell","$updateGutterWidth","gutterRenderer","$firstLineNumber","lastLineText","$fixedWidth","padding","$padding","$computePadding","ceil","$highlightGutterLine","$cursorRow","updateLineHighlight","$cursorCell","scrollLines","$renderLines","breakpoints","decorations","foldHeight","getShowLineNumbers","paddingLeft","borderRightWidth","paddingRight","Marker","getBorderClass","tl","tr","br","bl","setPadding","setMarkers","markers","elt","$getTop","drawFullLineMarker","drawScreenLineMarker","drawTextMarker","drawMultiLineMarker","childElementCount","lastChild","stringBuilder","extraStyle","curr","lineRange","range1","drawBidiSingleLineMarker","radiusClass","extraLength","Text","$updateEolChar","EOF_CHAR","EOL_CHAR_LF","EOL_CHAR_CRLF","EOL_CHAR","TAB_CHAR","SPACE_CHAR","unixMode","margin","getLineHeight","$fontMetrics","measure","$pollSizeChanges","checkForSizeChanges","$pollSizeChangesTimer","$computeTabString","$tabStrings","tabStr","span","$indentGuideRe","spaceClass","tabClass","spaceContent","tabContent","lineElements","lineElementsIdx","heightChanged","lineElement","$renderLine","$renderLinesFragment","lineEl","$useLineGroups","$textToken","rparen","lparen","$renderToken","valueFragment","simpleSpace","controlCharacter","cjkSpace","cjk","com","renderIndentGuide","cols","$createLineElement","$renderWrappedLine","splitChars","$renderSimpleLine","$renderOverflowMessage","overflowEl","$getFoldLineTokens","lastLineEl","invisibleEl","addTokens","renderTokens","Cursor","isVisible","blinkInterval","smoothBlinking","cursors","addCursor","$updateCursors","$updateOpacity","$startCssAnimation","animationDuration","$stopCssAnimation","blinking","restartTimer","setBlinkInterval","removeCursor","intervalId","timeoutId","blink","getPixelPosition","onScreen","isCursorInView","pixelPos","maxHeight","$selectionMarkers","cursorIndex","drawCursor","$setOverwrite","ScrollBar","classSuffix","setVisible","skipEvent","onScroll","coeff","VScrollBar","$scrollbarWidth","$minWidth","setHeight","setInnerHeight","setScrollHeight","HScrollBar","setWidth","setInnerWidth","setScrollWidth","ScrollBarV","ScrollBarH","RenderLoop","onRender","changes","$recursionLimit","_flush","USE_OBSERVER","ResizeObserver","FontMetrics","$setMeasureNodeStyles","$measureNode","$addObserver","visibility","whiteSpace","font","$measureSizes","fontWeight","boldSize","charSizes","allowBoldFonts","$observer","contentRect","setPolling","disconnect","$getZoom","getZoom","zoom","$initTransformMeasureNodes","transformCoordinates","clientPos","elPos","solve","l1","l2","det","mul","m2","k","ut","u","f","GutterLayer","MarkerLayer","TextLayer","CursorLayer","editorCss","HIDE_TEXTAREA","VirtualRenderer","onGutterResize","$markerBack","textLayer","$textLayer","canvas","$markerFront","$horizScroll","$vScroll","scrollBar","$scrollAnimation","scrollMargin","updateCharacterSize","$size","scrollerHeight","scrollerWidth","$dirty","minHeight","$renderChanges","defaultView","CHANGE_FULL","CHANGE_CURSOR","CHANGE_MARKER","CHANGE_SCROLL","CHANGE_LINES","CHANGE_TEXT","CHANGE_SIZE","CHANGE_MARKER_BACK","CHANGE_MARKER_FRONT","CHANGE_H_SCROLL","$allowBoldFonts","$updatePrintMargin","onChangeNewLineMode","$changedLines","updateFontSize","$changes","$updateSizeAsync","resizing","scrollWidth","$updateCachedSize","$extraHeight","oldSize","$showGutter","$computeLayerConfig","availableWidth","$showPrintMargin","$printMarginColumn","$animatedScroll","getShowGutter","setShowGutter","$printMarginEl","containerEl","$composition","posTop","posLeft","setScrollMargin","sm","setMargin","getHScrollBarAlwaysVisible","$hScrollBarAlwaysVisible","setHScrollBarAlwaysVisible","alwaysVisible","getVScrollBarAlwaysVisible","$vScrollBarAlwaysVisible","setVScrollBarAlwaysVisible","$updateScrollBarV","$scrollPastEnd","$updateScrollBarH","$frozen","unfreeze","st","$updateLines","$autosize","desiredHeight","$maxPixelHeight","hideScrollbars","$gutterWidth","screenLines","longestLine","$getLongestLine","horizScroll","hScrollChanged","vScrollBefore","vScrollChanged","firstRowHeight","lineCount","charCount","$viewMargin","topMargin","bottomMargin","alignment","STEPS","$calcSteps","fromValue","toValue","steps","x_min","initialScroll","oldSteps","$timer","scrollTo","canvasPos","$hasCssTransforms","$blockCursor","textToScreenCoordinates","pageX","pageY","keepTextAreaAtCursor","$useTextareaForIME","addToken","newToken","$themeId","cssClass","$theme","isDark","setMouseCursor","attachToShadowRoot","$workerBlob","workerUrl","Blob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","blobBuilder","getBlob","Worker","blob","URL","webkitURL","blobURL","createObjectURL","WorkerClient","worker","$createWorkerFromOldConfig","$sendDeltaQueue","changeListener","onMessage","callbackId","topLevelNamespaces","classname","nameToUrl","toUrl","normalizePath","$normalizePath","tlns","deltaQueue","$doc","ex","attachToDocument","q","UIWorkerClient","main","emitSync","sender","messageBuffer","workerClient","processNext","setEmitSync","Main","PlaceHolder","others","mainClass","othersClass","$onUpdate","onUpdate","$others","undoStack","$undostack","$undoStackDepth","setup","showOtherMarkers","othersActive","hideOtherMarkers","updateAnchors","lengthDiff","inMainRange","distanceFromStart","updateMarkers","updateMarker","undosRequired","isSamePoint","accel","selectionMode","isMultiSelect","mouseX","mouseY","onMouseSelection","screenAnchor","screenCursor","$enableJumpToDef","$blockSelectEnabled","addSelectionMarker","oldRange","removeSelectionMarker","tmpSel","rectSel","blockSelect","newCursor","removeSelectionMarkers","rectangularRangeBlock","updateSelectionMarkers","onMouseSelectionEnd","onSelectionInterval","selectMoreLines","selectMore","splitIntoLines","alignCursors","multiSelectCommands","MultiSelect","$multiselectOnSessionChange","$onAddRange","$onRemoveRange","$onMultiSelect","$onSingleSelect","onSessionChange","$checkMultiselectChange","addAltCursorListeners","altCursor","altDown","getSelectionMarkers","$blockChangeEvents","mergeOverlappingRanges","lastRange","$initRangeList","toggleBlockSelection","includeEmptyLines","xBackwards","startOffsetX","endOffsetX","yBackwards","docEnd","selectionMarkerCount","markerList","$onMultiSelectExec","inVirtualMode","keepOrder","$byLines","cmdResult","anim","buf","additive","skip","screenLead","toRemove","words","stopAtFirst","sameRowRanges","maxCol","minSpace","spaceOffsets","spaceOffset","fr","lr","guessRange","$reAlignText","forceLeft","alignLeft","startW","textW","endW","alignRight","unAlign","isLeftAligned","isRightAligned","enableMultiselect","enableBlockSelect","FoldMode","foldingStartMarker","foldingStopMarker","indentationBlock","startLevel","openingBracketBlock","closingBracketBlock","LineWidgets","widgetManager","updateOnChange","renderWidgets","measureWidgets","_changedWidgets","$onChangeEditor","updateOnFold","_inDocument","removeLineWidget","$updateRows","noWidgets","$oldWidget","addLineWidget","zIndex","coverGutter","pixelHeight","$fold","onWidgetChanged","w1","getWidgetsAtRow","changedWidgets","fixedWidth","coverLine","fullWidth","binarySearch","comparator","findAnnotations","matched","oldWidget","gutterAnno","arrow","onmousedown","Renderer","edit","oldNode","replaceChild","createEditSession","webpackPolyfill","deprecate","paths","_toConsumableArray","arr2","_classCallCheck","instance","Constructor","AceHandler","_createClass","protoProps","variables","Script","sandbox","runInNewContext","results","variable","inspect","_console","Context","xs","Object_keys","defineProp","globals","runInContext","iframe","contentWindow","wEval","wExecScript","execScript","winKeys","runInThisContext","createContext","isContext","createScript","stylize","stylizeNoColor","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","arrayToHash","recurseTimes","isFunction","isString","primitive","formatPrimitive","visibleKeys","isError","formatError","isDate","toUTCString","output","formatArray","formatProperty","reduceToSingleString","simple","isNumber","isNull","desc","numLinesEst","ar","isNullOrUndefined","isSymbol","objectToString","pad","timestamp","getHours","getMinutes","getSeconds","getDate","months","getMonth","callbackifyOnRejected","newReason","callbackify","callbackified","maybeCb","rej","setPrototypeOf","getOwnPropertyDescriptors","descriptors","formatRegExp","format","objects","deprecated","warned","throwDeprecation","traceDeprecation","noDeprecation","debugEnviron","debugs","debuglog","NODE_ENV","NODE_DEBUG","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","boolean","null","date","regexp","isBuffer","origin","kCustomPromisifiedSymbol","promisify","promiseResolve","promiseReject","promise","custom","fill","readUInt8","TempCtor","_vm","_h","font-size","submit","esExports"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__aceHandler__ = __webpack_require__(17);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  name: 'app',\n  data: function data() {\n    return {\n      editor: null,\n      shellInput: '',\n      aceHandler: null,\n      commands: ['help - see a list of commands', 'random - returns a random float between 0 and 1', 'clear - clears shell', \"run VARIABLES - runs all code in the editor and prints the value of the variable names past\"]\n    };\n  },\n  mounted: function mounted() {\n    __WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace__[\"config\"].set('basePath', '../node_modules/ace-builds/src-noconflict');\n    this.editor = __WEBPACK_IMPORTED_MODULE_0__node_modules_ace_builds_src_noconflict_ace__[\"edit\"]('editor');\n    this.editor.setTheme('ace/theme/monokai');\n    this.editor.session.setMode('ace/mode/javascript');\n\n    this.aceHandler = new __WEBPACK_IMPORTED_MODULE_1__aceHandler__[\"a\" /* AceHandler */]();\n  },\n\n  methods: {\n    runCommand: function runCommand() {\n      var _this = this;\n\n      var command = this.shellInput.split(\" \")[0];\n\n      var par = document.createElement('p');\n      par.appendChild(document.createTextNode('> ' + this.shellInput));\n      par.style = 'input';\n      document.getElementsByClassName('shell-content')[0].appendChild(par);\n\n      if (command.toLowerCase() === 'help') {\n        this.commands.forEach(function (command) {\n          _this.printOutput(command);\n        });\n      } else if (command.toLowerCase() === 'clear') {\n        document.getElementsByClassName('shell-content')[0].innerHTML = '<p>Shell content cleared</p>';\n      } else if (command.toLowerCase() === 'random') {\n        this.printOutput(Math.random());\n      } else if (command.toLowerCase() === 'run') {\n        var args = this.shellInput.split(\" \").splice(1);\n        this.aceHandler.runCode(this.editor.getValue(), args).forEach(function (result) {\n          _this.printOutput(result);\n        });\n      } else if (this.shellInput.includes('(') && this.shellInput.includes(')')) {\n        var functionName = this.shellInput.split('(')[0];\n        var functionArgs = this.shellInput.split('(')[1];\n        functionArgs = functionArgs.substring(0, functionArgs.length - 1).split(\",\");\n        // Convert to correct variable type\n        functionArgs = functionArgs.map(function (arg) {\n          arg = arg.trim();\n\n          // If string remove quotes\n          if (arg.charAt(0) == '\"' || arg.charAt(arg.length - 1) == \"'\") {\n            return arg.substring(1, arg.length - 1);\n\n            // If number param convert\n          } else if (arg.charAt(0) != \"{\") {\n            return parseInt(arg);\n          }\n        });\n\n        var result = this.aceHandler.runFunction(this.editor.getValue(), functionName, functionArgs);\n        this.printOutput(result);\n      } else {\n        this.printOutput(\"Error: Command Not Found. Type 'help' for a list of commands.\");\n      }\n\n      // Clear shellInput\n      this.shellInput = '';\n\n      // Scroll shell with data\n      document.getElementById('shell').scrollTop = document.getElementById('shell').scrollHeight;\n    },\n    printOutput: function printOutput(str) {\n      var par = document.createElement('p');\n      par.appendChild(document.createTextNode(str));\n      par.className = 'output';\n      document.getElementsByClassName('shell-content')[0].appendChild(par);\n    }\n  }\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(8);\n\n\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\n  el: '#app',\n  render: function render(h) {\n    return h(__WEBPACK_IMPORTED_MODULE_1__App_vue__[\"a\" /* default */]);\n  }\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (false) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (false\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (false\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    \"production\" !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (false) {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"production\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (false) {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (false) {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    false\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (false) {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (false) {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (false) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (false) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (false) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (false) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (false) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (false) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (false) {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (false) {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (false) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (false) {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (false) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (false\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (false\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (false) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        false\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (false\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (false) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (false) {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (false) {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (false) {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (false) {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (false) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (false) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (false) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (false) {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (false) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (false) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (false) {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (false) {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (false) {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          false\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (false) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (false\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (false) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (false) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (false) {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"production\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0), __webpack_require__(6).setImmediate))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(7);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__ = __webpack_require__(2);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_13a01a4a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__ = __webpack_require__(22);\nfunction injectStyle (ssrContext) {\n  __webpack_require__(9)\n}\nvar normalizeComponent = __webpack_require__(14)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_13a01a4a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(10);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(12)(\"0b5cd5a4\", content, true, {});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(11)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"body,html{margin:0;padding:0}#app{display:flex;width:100vw;height:100vh}#editor{width:60%;height:100%;font-size:25px}#shell{font-family:\\\"sans-serif\\\";background:#323232;color:#fff;padding:25px;height:calc(100% - 50px);width:calc(60% - 50px);overflow-y:auto}form{display:inline}input{background:transparent;border:0;color:#fff;margin:0;width:80%;padding:5px}.output{padding-left:10px;color:#c8c8c8;margin:5px}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(13)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {/* ***** BEGIN LICENSE BLOCK *****\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**\n * Define a module along with a payload\n * @param module a name for the payload\n * @param payload a function to call with (require, exports, module) params\n */\n\n(function() {\n\nvar ACE_NAMESPACE = \"ace\";\n\nvar global = (function() { return this; })();\nif (!global && typeof window != \"undefined\") global = window; // strict mode\n\n\nif (!ACE_NAMESPACE && typeof requirejs !== \"undefined\")\n    return;\n\n\nvar define = function(module, deps, payload) {\n    if (typeof module !== \"string\") {\n        if (define.original)\n            define.original.apply(this, arguments);\n        else {\n            console.error(\"dropping module because define wasn\\'t a string.\");\n            console.trace();\n        }\n        return;\n    }\n    if (arguments.length == 2)\n        payload = deps;\n    if (!define.modules[module]) {\n        define.payloads[module] = payload;\n        define.modules[module] = null;\n    }\n};\n\ndefine.modules = {};\ndefine.payloads = {};\n\n/**\n * Get at functionality define()ed using the function above\n */\nvar _require = function(parentId, module, callback) {\n    if (typeof module === \"string\") {\n        var payload = lookup(parentId, module);\n        if (payload != undefined) {\n            callback && callback();\n            return payload;\n        }\n    } else if (Object.prototype.toString.call(module) === \"[object Array]\") {\n        var params = [];\n        for (var i = 0, l = module.length; i < l; ++i) {\n            var dep = lookup(parentId, module[i]);\n            if (dep == undefined && require.original)\n                return;\n            params.push(dep);\n        }\n        return callback && callback.apply(null, params) || true;\n    }\n};\n\nvar require = function(module, callback) {\n    var packagedModule = _require(\"\", module, callback);\n    if (packagedModule == undefined && require.original)\n        return require.original.apply(this, arguments);\n    return packagedModule;\n};\n\nvar normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = base + \"/\" + moduleName;\n\n        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    return moduleName;\n};\n\n/**\n * Internal function to lookup moduleNames and resolve them by calling the\n * definition function if needed.\n */\nvar lookup = function(parentId, moduleName) {\n    moduleName = normalizeModule(parentId, moduleName);\n\n    var module = define.modules[moduleName];\n    if (!module) {\n        module = define.payloads[moduleName];\n        if (typeof module === 'function') {\n            var exports = {};\n            var mod = {\n                id: moduleName,\n                uri: '',\n                exports: exports,\n                packaged: true\n            };\n\n            var req = function(module, callback) {\n                return _require(moduleName, module, callback);\n            };\n\n            var returnValue = module(req, exports, mod);\n            exports = returnValue || mod.exports;\n            define.modules[moduleName] = exports;\n            delete define.payloads[moduleName];\n        }\n        module = define.modules[moduleName] = exports || module;\n    }\n    return module;\n};\n\nfunction exportAce(ns) {\n    var root = global;\n    if (ns) {\n        if (!global[ns])\n            global[ns] = {};\n        root = global[ns];\n    }\n\n    if (!root.define || !root.define.packaged) {\n        define.original = root.define;\n        root.define = define;\n        root.define.packaged = true;\n    }\n\n    if (!root.require || !root.require.packaged) {\n        require.original = root.require;\n        root.require = require;\n        root.require.packaged = true;\n    }\n}\n\nexportAce(ACE_NAMESPACE);\n\n})();\n\nace.define(\"ace/lib/regexp\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\n    var real = {\n            exec: RegExp.prototype.exec,\n            test: RegExp.prototype.test,\n            match: String.prototype.match,\n            replace: String.prototype.replace,\n            split: String.prototype.split\n        },\n        compliantExecNpcg = real.exec.call(/()??/, \"\")[1] === undefined, // check `exec` handling of nonparticipating capturing groups\n        compliantLastIndexIncrement = function () {\n            var x = /^/g;\n            real.test.call(x, \"\");\n            return !x.lastIndex;\n        }();\n\n    if (compliantLastIndexIncrement && compliantExecNpcg)\n        return;\n    RegExp.prototype.exec = function (str) {\n        var match = real.exec.apply(this, arguments),\n            name, r2;\n        if ( typeof(str) == 'string' && match) {\n            if (!compliantExecNpcg && match.length > 1 && indexOf(match, \"\") > -1) {\n                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), \"g\", \"\"));\n                real.replace.call(str.slice(match.index), r2, function () {\n                    for (var i = 1; i < arguments.length - 2; i++) {\n                        if (arguments[i] === undefined)\n                            match[i] = undefined;\n                    }\n                });\n            }\n            if (this._xregexp && this._xregexp.captureNames) {\n                for (var i = 1; i < match.length; i++) {\n                    name = this._xregexp.captureNames[i - 1];\n                    if (name)\n                       match[name] = match[i];\n                }\n            }\n            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n        }\n        return match;\n    };\n    if (!compliantLastIndexIncrement) {\n        RegExp.prototype.test = function (str) {\n            var match = real.exec.call(this, str);\n            if (match && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n            return !!match;\n        };\n    }\n\n    function getNativeFlags (regex) {\n        return (regex.global     ? \"g\" : \"\") +\n               (regex.ignoreCase ? \"i\" : \"\") +\n               (regex.multiline  ? \"m\" : \"\") +\n               (regex.extended   ? \"x\" : \"\") + // Proposed for ES4; included in AS3\n               (regex.sticky     ? \"y\" : \"\");\n    }\n\n    function indexOf (array, item, from) {\n        if (Array.prototype.indexOf) // Use the native array method if available\n            return array.indexOf(item, from);\n        for (var i = from || 0; i < array.length; i++) {\n            if (array[i] === item)\n                return i;\n        }\n        return -1;\n    }\n\n});\n\nace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\nfunction Empty() {}\n\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function bind(that) { // .length is 1\n        var target = this;\n        if (typeof target != \"function\") {\n            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n        }\n        var args = slice.call(arguments, 1); // for normal call\n        var bound = function () {\n\n            if (this instanceof bound) {\n\n                var result = target.apply(\n                    this,\n                    args.concat(slice.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return this;\n\n            } else {\n                return target.apply(\n                    that,\n                    args.concat(slice.call(arguments))\n                );\n\n            }\n\n        };\n        if(target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            Empty.prototype = null;\n        }\n        return bound;\n    };\n}\nvar call = Function.prototype.call;\nvar prototypeOfArray = Array.prototype;\nvar prototypeOfObject = Object.prototype;\nvar slice = prototypeOfArray.slice;\nvar _toString = call.bind(prototypeOfObject.toString);\nvar owns = call.bind(prototypeOfObject.hasOwnProperty);\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors;\nif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n}\nif ([1,2].splice(0).length != 2) {\n    if(function() { // test IE < 9 to splice bug - see issue #138\n        function makeArray(l) {\n            var a = new Array(l+2);\n            a[0] = a[1] = 0;\n            return a;\n        }\n        var array = [], lengthBefore;\n        \n        array.splice.apply(array, makeArray(20));\n        array.splice.apply(array, makeArray(26));\n\n        lengthBefore = array.length; //46\n        array.splice(5, 0, \"XXX\"); // add one element\n\n        lengthBefore + 1 == array.length\n\n        if (lengthBefore + 1 == array.length) {\n            return true;// has right splice implementation without bugs\n        }\n    }()) {//IE 6/7\n        var array_splice = Array.prototype.splice;\n        Array.prototype.splice = function(start, deleteCount) {\n            if (!arguments.length) {\n                return [];\n            } else {\n                return array_splice.apply(this, [\n                    start === void 0 ? 0 : start,\n                    deleteCount === void 0 ? (this.length - start) : deleteCount\n                ].concat(slice.call(arguments, 2)))\n            }\n        };\n    } else {//IE8\n        Array.prototype.splice = function(pos, removeCount){\n            var length = this.length;\n            if (pos > 0) {\n                if (pos > length)\n                    pos = length;\n            } else if (pos == void 0) {\n                pos = 0;\n            } else if (pos < 0) {\n                pos = Math.max(length + pos, 0);\n            }\n\n            if (!(pos+removeCount < length))\n                removeCount = length - pos;\n\n            var removed = this.slice(pos, pos+removeCount);\n            var insert = slice.call(arguments, 2);\n            var add = insert.length;            \n            if (pos === length) {\n                if (add) {\n                    this.push.apply(this, insert);\n                }\n            } else {\n                var remove = Math.min(removeCount, length - pos);\n                var tailOldPos = pos + remove;\n                var tailNewPos = tailOldPos + add - remove;\n                var tailCount = length - tailOldPos;\n                var lengthAfterRemove = length - remove;\n\n                if (tailNewPos < tailOldPos) { // case A\n                    for (var i = 0; i < tailCount; ++i) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } else if (tailNewPos > tailOldPos) { // case B\n                    for (i = tailCount; i--; ) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } // else, add == remove (nothing to do)\n\n                if (add && pos === lengthAfterRemove) {\n                    this.length = lengthAfterRemove; // truncate array\n                    this.push.apply(this, insert);\n                } else {\n                    this.length = lengthAfterRemove + add; // reserves space\n                    for (i = 0; i < add; ++i) {\n                        this[pos+i] = insert[i];\n                    }\n                }\n            }\n            return removed;\n        };\n    }\n}\nif (!Array.isArray) {\n    Array.isArray = function isArray(obj) {\n        return _toString(obj) == \"[object Array]\";\n    };\n}\nvar boxedString = Object(\"a\"),\n    splitString = boxedString[0] != \"a\" || !(0 in boxedString);\n\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                fun.call(thisp, self[i], i, object);\n            }\n        }\n    };\n}\nif (!Array.prototype.map) {\n    Array.prototype.map = function map(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self)\n                result[i] = fun.call(thisp, self[i], i, object);\n        }\n        return result;\n    };\n}\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function filter(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                    object,\n            length = self.length >>> 0,\n            result = [],\n            value,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                value = self[i];\n                if (fun.call(thisp, value, i, object)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    };\n}\nif (!Array.prototype.every) {\n    Array.prototype.every = function every(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && !fun.call(thisp, self[i], i, object)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nif (!Array.prototype.some) {\n    Array.prototype.some = function some(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && fun.call(thisp, self[i], i, object)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nif (!Array.prototype.reduce) {\n    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduce of empty array with no initial value\");\n        }\n\n        var i = 0;\n        var result;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i++];\n                    break;\n                }\n                if (++i >= length) {\n                    throw new TypeError(\"reduce of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        for (; i < length; i++) {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        }\n\n        return result;\n    };\n}\nif (!Array.prototype.reduceRight) {\n    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduceRight of empty array with no initial value\");\n        }\n\n        var result, i = length - 1;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i--];\n                    break;\n                }\n                if (--i < 0) {\n                    throw new TypeError(\"reduceRight of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        do {\n            if (i in this) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        } while (i--);\n\n        return result;\n    };\n}\nif (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {\n    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {\n    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n        var i = length - 1;\n        if (arguments.length > 1) {\n            i = Math.min(i, toInteger(arguments[1]));\n        }\n        i = i >= 0 ? i : length - Math.abs(i);\n        for (; i >= 0; i--) {\n            if (i in self && sought === self[i]) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function getPrototypeOf(object) {\n        return object.__proto__ || (\n            object.constructor ?\n            object.constructor.prototype :\n            prototypeOfObject\n        );\n    };\n}\nif (!Object.getOwnPropertyDescriptor) {\n    var ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a \" +\n                         \"non-object: \";\n    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT + object);\n        if (!owns(object, property))\n            return;\n\n        var descriptor, getter, setter;\n        descriptor =  { enumerable: true, configurable: true };\n        if (supportsAccessors) {\n            var prototype = object.__proto__;\n            object.__proto__ = prototypeOfObject;\n\n            var getter = lookupGetter(object, property);\n            var setter = lookupSetter(object, property);\n            object.__proto__ = prototype;\n\n            if (getter || setter) {\n                if (getter) descriptor.get = getter;\n                if (setter) descriptor.set = setter;\n                return descriptor;\n            }\n        }\n        descriptor.value = object[property];\n        return descriptor;\n    };\n}\nif (!Object.getOwnPropertyNames) {\n    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n        return Object.keys(object);\n    };\n}\nif (!Object.create) {\n    var createEmpty;\n    if (Object.prototype.__proto__ === null) {\n        createEmpty = function () {\n            return { \"__proto__\": null };\n        };\n    } else {\n        createEmpty = function () {\n            var empty = {};\n            for (var i in empty)\n                empty[i] = null;\n            empty.constructor =\n            empty.hasOwnProperty =\n            empty.propertyIsEnumerable =\n            empty.isPrototypeOf =\n            empty.toLocaleString =\n            empty.toString =\n            empty.valueOf =\n            empty.__proto__ = null;\n            return empty;\n        }\n    }\n\n    Object.create = function create(prototype, properties) {\n        var object;\n        if (prototype === null) {\n            object = createEmpty();\n        } else {\n            if (typeof prototype != \"object\")\n                throw new TypeError(\"typeof prototype[\"+(typeof prototype)+\"] != 'object'\");\n            var Type = function () {};\n            Type.prototype = prototype;\n            object = new Type();\n            object.__proto__ = prototype;\n        }\n        if (properties !== void 0)\n            Object.defineProperties(object, properties);\n        return object;\n    };\n}\n\nfunction doesDefinePropertyWork(object) {\n    try {\n        Object.defineProperty(object, \"sentinel\", {});\n        return \"sentinel\" in object;\n    } catch (exception) {\n    }\n}\nif (Object.defineProperty) {\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n    var definePropertyWorksOnDom = typeof document == \"undefined\" ||\n        doesDefinePropertyWork(document.createElement(\"div\"));\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n        var definePropertyFallback = Object.defineProperty;\n    }\n}\n\nif (!Object.defineProperty || definePropertyFallback) {\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \"\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined \" +\n                                      \"on this javascript engine\";\n\n    Object.defineProperty = function defineProperty(object, property, descriptor) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        if ((typeof descriptor != \"object\" && typeof descriptor != \"function\") || descriptor === null)\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        if (definePropertyFallback) {\n            try {\n                return definePropertyFallback.call(Object, object, property, descriptor);\n            } catch (exception) {\n            }\n        }\n        if (owns(descriptor, \"value\")) {\n\n            if (supportsAccessors && (lookupGetter(object, property) ||\n                                      lookupSetter(object, property)))\n            {\n                var prototype = object.__proto__;\n                object.__proto__ = prototypeOfObject;\n                delete object[property];\n                object[property] = descriptor.value;\n                object.__proto__ = prototype;\n            } else {\n                object[property] = descriptor.value;\n            }\n        } else {\n            if (!supportsAccessors)\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n            if (owns(descriptor, \"get\"))\n                defineGetter(object, property, descriptor.get);\n            if (owns(descriptor, \"set\"))\n                defineSetter(object, property, descriptor.set);\n        }\n\n        return object;\n    };\n}\nif (!Object.defineProperties) {\n    Object.defineProperties = function defineProperties(object, properties) {\n        for (var property in properties) {\n            if (owns(properties, property))\n                Object.defineProperty(object, property, properties[property]);\n        }\n        return object;\n    };\n}\nif (!Object.seal) {\n    Object.seal = function seal(object) {\n        return object;\n    };\n}\nif (!Object.freeze) {\n    Object.freeze = function freeze(object) {\n        return object;\n    };\n}\ntry {\n    Object.freeze(function () {});\n} catch (exception) {\n    Object.freeze = (function freeze(freezeObject) {\n        return function freeze(object) {\n            if (typeof object == \"function\") {\n                return object;\n            } else {\n                return freezeObject(object);\n            }\n        };\n    })(Object.freeze);\n}\nif (!Object.preventExtensions) {\n    Object.preventExtensions = function preventExtensions(object) {\n        return object;\n    };\n}\nif (!Object.isSealed) {\n    Object.isSealed = function isSealed(object) {\n        return false;\n    };\n}\nif (!Object.isFrozen) {\n    Object.isFrozen = function isFrozen(object) {\n        return false;\n    };\n}\nif (!Object.isExtensible) {\n    Object.isExtensible = function isExtensible(object) {\n        if (Object(object) === object) {\n            throw new TypeError(); // TODO message\n        }\n        var name = '';\n        while (owns(object, name)) {\n            name += '?';\n        }\n        object[name] = true;\n        var returnValue = owns(object, name);\n        delete object[name];\n        return returnValue;\n    };\n}\nif (!Object.keys) {\n    var hasDontEnumBug = true,\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    for (var key in {\"toString\": null}) {\n        hasDontEnumBug = false;\n    }\n\n    Object.keys = function keys(object) {\n\n        if (\n            (typeof object != \"object\" && typeof object != \"function\") ||\n            object === null\n        ) {\n            throw new TypeError(\"Object.keys called on a non-object\");\n        }\n\n        var keys = [];\n        for (var name in object) {\n            if (owns(object, name)) {\n                keys.push(name);\n            }\n        }\n\n        if (hasDontEnumBug) {\n            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n                var dontEnum = dontEnums[i];\n                if (owns(object, dontEnum)) {\n                    keys.push(dontEnum);\n                }\n            }\n        }\n        return keys;\n    };\n\n}\nif (!Date.now) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\nvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\" +\n    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n    \"\\u2029\\uFEFF\";\nif (!String.prototype.trim || ws.trim()) {\n    ws = \"[\" + ws + \"]\";\n    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n    String.prototype.trim = function trim() {\n        return String(this).replace(trimBeginRegexp, \"\").replace(trimEndRegexp, \"\");\n    };\n}\n\nfunction toInteger(n) {\n    n = +n;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n}\n\nfunction isPrimitive(input) {\n    var type = typeof input;\n    return (\n        input === null ||\n        type === \"undefined\" ||\n        type === \"boolean\" ||\n        type === \"number\" ||\n        type === \"string\"\n    );\n}\n\nfunction toPrimitive(input) {\n    var val, valueOf, toString;\n    if (isPrimitive(input)) {\n        return input;\n    }\n    valueOf = input.valueOf;\n    if (typeof valueOf === \"function\") {\n        val = valueOf.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    toString = input.toString;\n    if (typeof toString === \"function\") {\n        val = toString.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    throw new TypeError();\n}\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \"+o+\" to object\");\n    }\n    return Object(o);\n};\n\n});\n\nace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/regexp\",\"ace/lib/es5-shim\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./regexp\");\nrequire(\"./es5-shim\");\nif (typeof Element != \"undefined\" && !Element.prototype.remove) {\n    Object.defineProperty(Element.prototype, \"remove\", {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: function() { this.parentNode && this.parentNode.removeChild(this); }\n    });\n}\n\n\n});\n\nace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nexports.OS = {\n    LINUX: \"LINUX\",\n    MAC: \"MAC\",\n    WINDOWS: \"WINDOWS\"\n};\nexports.getOS = function() {\n    if (exports.isMac) {\n        return exports.OS.MAC;\n    } else if (exports.isLinux) {\n        return exports.OS.LINUX;\n    } else {\n        return exports.OS.WINDOWS;\n    }\n};\nif (typeof navigator != \"object\")\n    return;\n\nvar os = (navigator.platform.match(/mac|win|linux/i) || [\"other\"])[0].toLowerCase();\nvar ua = navigator.userAgent;\nexports.isWin = (os == \"win\");\nexports.isMac = (os == \"mac\");\nexports.isLinux = (os == \"linux\");\nexports.isIE = \n    (navigator.appName == \"Microsoft Internet Explorer\" || navigator.appName.indexOf(\"MSAppHost\") >= 0)\n    ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1])\n    : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1]); // for ie\n    \nexports.isOldIE = exports.isIE && exports.isIE < 9;\nexports.isGecko = exports.isMozilla = ua.match(/ Gecko\\/\\d+/);\nexports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == \"[object Opera]\";\nexports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\n\nexports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\n\nexports.isEdge = parseFloat(ua.split(\" Edge/\")[1]) || undefined;\n\nexports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\n\nexports.isIPad = ua.indexOf(\"iPad\") >= 0;\n\nexports.isAndroid = ua.indexOf(\"Android\") >= 0;\n\nexports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\n\nexports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;\n\nif (exports.isIOS) exports.isMac = true;\n\nexports.isMobile = exports.isIPad || exports.isAndroid;\n\n});\n\nace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"./useragent\"); \nvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\nexports.buildDom = function buildDom(arr, parent, refs) {\n    if (typeof arr == \"string\" && arr) {\n        var txt = document.createTextNode(arr);\n        if (parent)\n            parent.appendChild(txt);\n        return txt;\n    }\n    \n    if (!Array.isArray(arr))\n        return arr;\n    if (typeof arr[0] != \"string\" || !arr[0]) {\n        var els = [];\n        for (var i = 0; i < arr.length; i++) {\n            var ch = buildDom(arr[i], parent, refs);\n            ch && els.push(ch);\n        }\n        return els;\n    }\n    \n    var el = document.createElement(arr[0]);\n    var options = arr[1];\n    var childIndex = 1;\n    if (options && typeof options == \"object\" && !Array.isArray(options))\n        childIndex = 2;\n    for (var i = childIndex; i < arr.length; i++)\n        buildDom(arr[i], el, refs);\n    if (childIndex == 2) {\n        Object.keys(options).forEach(function(n) {\n            var val = options[n];\n            if (n === \"class\") {\n                el.className = Array.isArray(val) ? val.join(\" \") : val;\n            } else if (typeof val == \"function\" || n == \"value\") {\n                el[n] = val;\n            } else if (n === \"ref\") {\n                if (refs) refs[val] = el;\n            } else if (val != null) {\n                el.setAttribute(n, val);\n            }\n        });\n    }\n    if (parent)\n        parent.appendChild(el);\n    return el;\n};\n\nexports.getDocumentHead = function(doc) {\n    if (!doc)\n        doc = document;\n    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n};\n\nexports.createElement = function(tag, ns) {\n    return document.createElementNS ?\n           document.createElementNS(ns || XHTML_NS, tag) :\n           document.createElement(tag);\n};\n\nexports.removeChildren = function(element) {\n    element.innerHTML = \"\";\n};\n\nexports.createTextNode = function(textContent, element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createTextNode(textContent);\n};\n\nexports.createFragment = function(element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createDocumentFragment();\n};\n\nexports.hasCssClass = function(el, name) {\n    var classes = (el.className + \"\").split(/\\s+/g);\n    return classes.indexOf(name) !== -1;\n};\nexports.addCssClass = function(el, name) {\n    if (!exports.hasCssClass(el, name)) {\n        el.className += \" \" + name;\n    }\n};\nexports.removeCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g);\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        classes.splice(index, 1);\n    }\n    el.className = classes.join(\" \");\n};\n\nexports.toggleCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g), add = true;\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        add = false;\n        classes.splice(index, 1);\n    }\n    if (add)\n        classes.push(name);\n\n    el.className = classes.join(\" \");\n    return add;\n};\nexports.setCssClass = function(node, className, include) {\n    if (include) {\n        exports.addCssClass(node, className);\n    } else {\n        exports.removeCssClass(node, className);\n    }\n};\n\nexports.hasCssString = function(id, doc) {\n    var index = 0, sheets;\n    doc = doc || document;\n    if ((sheets = doc.querySelectorAll(\"style\"))) {\n        while (index < sheets.length)\n            if (sheets[index++].id === id)\n                return true;\n    }\n};\n\nexports.importCssString = function importCssString(cssText, id, target) {\n    var container = target;\n    if (!target || !target.getRootNode) {\n        container = document;\n    } else {\n        container = target.getRootNode();\n        if (!container || container == target)\n            container = document;\n    }\n    \n    var doc = container.ownerDocument || container;\n    if (id && exports.hasCssString(id, container))\n        return null;\n    \n    if (id)\n        cssText += \"\\n/*# sourceURL=ace/css/\" + id + \" */\";\n    \n    var style = exports.createElement(\"style\");\n    style.appendChild(doc.createTextNode(cssText));\n    if (id)\n        style.id = id;\n\n    if (container == doc)\n        container = exports.getDocumentHead(doc);\n    container.insertBefore(style, container.firstChild);\n};\n\nexports.importCssStylsheet = function(uri, doc) {\n    exports.buildDom([\"link\", {rel: \"stylesheet\", href: uri}], exports.getDocumentHead(doc));\n};\nexports.scrollbarWidth = function(document) {\n    var inner = exports.createElement(\"ace_inner\");\n    inner.style.width = \"100%\";\n    inner.style.minWidth = \"0px\";\n    inner.style.height = \"200px\";\n    inner.style.display = \"block\";\n\n    var outer = exports.createElement(\"ace_outer\");\n    var style = outer.style;\n\n    style.position = \"absolute\";\n    style.left = \"-10000px\";\n    style.overflow = \"hidden\";\n    style.width = \"200px\";\n    style.minWidth = \"0px\";\n    style.height = \"150px\";\n    style.display = \"block\";\n\n    outer.appendChild(inner);\n\n    var body = document.documentElement;\n    body.appendChild(outer);\n\n    var noScrollbar = inner.offsetWidth;\n\n    style.overflow = \"scroll\";\n    var withScrollbar = inner.offsetWidth;\n\n    if (noScrollbar == withScrollbar) {\n        withScrollbar = outer.clientWidth;\n    }\n\n    body.removeChild(outer);\n\n    return noScrollbar-withScrollbar;\n};\n\nif (typeof document == \"undefined\") {\n    exports.importCssString = function() {};\n}\n\nexports.computedStyle = function(element, style) {\n    return window.getComputedStyle(element, \"\") || {};\n};\n\nexports.setStyle = function(styles, property, value) {\n    if (styles[property] !== value) {\n        styles[property] = value;\n    }\n};\n\nexports.HAS_CSS_ANIMATION = false;\nexports.HAS_CSS_TRANSFORMS = false;\nexports.HI_DPI = useragent.isWin\n    ? typeof window !== \"undefined\" && window.devicePixelRatio >= 1.5\n    : true;\n\nif (typeof document !== \"undefined\") {\n    var div = document.createElement(\"div\");\n    if (exports.HI_DPI && div.style.transform  !== undefined)\n        exports.HAS_CSS_TRANSFORMS = true;\n    if (!useragent.isEdge && typeof div.style.animationName !== \"undefined\")\n        exports.HAS_CSS_ANIMATION = true;\n    div = null;\n}\n\nif (exports.HAS_CSS_TRANSFORMS) {\n    exports.translate = function(element, tx, ty) {\n        element.style.transform = \"translate(\" + Math.round(tx) + \"px, \" + Math.round(ty) +\"px)\";\n    };\n} else {\n    exports.translate = function(element, tx, ty) {\n        element.style.top = Math.round(ty) + \"px\";\n        element.style.left = Math.round(tx) + \"px\";\n    };\n}\n\n});\n\nace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.inherits = function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\n\nexports.mixin = function(obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\n\nexports.implement = function(proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./oop\");\nvar Keys = (function() {\n    var ret = {\n        MODIFIER_KEYS: {\n            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'\n        },\n\n        KEY_MODS: {\n            \"ctrl\": 1, \"alt\": 2, \"option\" : 2, \"shift\": 4,\n            \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8\n        },\n\n        FUNCTION_KEYS : {\n            8  : \"Backspace\",\n            9  : \"Tab\",\n            13 : \"Return\",\n            19 : \"Pause\",\n            27 : \"Esc\",\n            32 : \"Space\",\n            33 : \"PageUp\",\n            34 : \"PageDown\",\n            35 : \"End\",\n            36 : \"Home\",\n            37 : \"Left\",\n            38 : \"Up\",\n            39 : \"Right\",\n            40 : \"Down\",\n            44 : \"Print\",\n            45 : \"Insert\",\n            46 : \"Delete\",\n            96 : \"Numpad0\",\n            97 : \"Numpad1\",\n            98 : \"Numpad2\",\n            99 : \"Numpad3\",\n            100: \"Numpad4\",\n            101: \"Numpad5\",\n            102: \"Numpad6\",\n            103: \"Numpad7\",\n            104: \"Numpad8\",\n            105: \"Numpad9\",\n            '-13': \"NumpadEnter\",\n            112: \"F1\",\n            113: \"F2\",\n            114: \"F3\",\n            115: \"F4\",\n            116: \"F5\",\n            117: \"F6\",\n            118: \"F7\",\n            119: \"F8\",\n            120: \"F9\",\n            121: \"F10\",\n            122: \"F11\",\n            123: \"F12\",\n            144: \"Numlock\",\n            145: \"Scrolllock\"\n        },\n\n        PRINTABLE_KEYS: {\n           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',\n           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',\n           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',\n           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',\n           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',\n           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',\n          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',\n          219: '[', 220: '\\\\',221: ']', 222: \"'\", 111: '/', 106: '*'\n        }\n    };\n    var name, i;\n    for (i in ret.FUNCTION_KEYS) {\n        name = ret.FUNCTION_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    for (i in ret.PRINTABLE_KEYS) {\n        name = ret.PRINTABLE_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    oop.mixin(ret, ret.MODIFIER_KEYS);\n    oop.mixin(ret, ret.PRINTABLE_KEYS);\n    oop.mixin(ret, ret.FUNCTION_KEYS);\n    ret.enter = ret[\"return\"];\n    ret.escape = ret.esc;\n    ret.del = ret[\"delete\"];\n    ret[173] = '-';\n    \n    (function() {\n        var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n        for (var i = Math.pow(2, mods.length); i--;) {            \n            ret.KEY_MODS[i] = mods.filter(function(x) {\n                return i & ret.KEY_MODS[x];\n            }).join(\"-\") + \"-\";\n        }\n    })();\n\n    ret.KEY_MODS[0] = \"\";\n    ret.KEY_MODS[-1] = \"input-\";\n\n    return ret;\n})();\noop.mixin(exports, Keys);\n\nexports.keyCodeToString = function(keyCode) {\n    var keyString = Keys[keyCode];\n    if (typeof keyString != \"string\")\n        keyString = String.fromCharCode(keyCode);\n    return keyString.toLowerCase();\n};\n\n});\n\nace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keys = require(\"./keys\");\nvar useragent = require(\"./useragent\");\n\nvar pressedKeys = null;\nvar ts = 0;\n\nexports.addListener = function(elem, type, callback) {\n    if (elem.addEventListener) {\n        return elem.addEventListener(type, callback, false);\n    }\n    if (elem.attachEvent) {\n        var wrapper = function() {\n            callback.call(elem, window.event);\n        };\n        callback._wrapper = wrapper;\n        elem.attachEvent(\"on\" + type, wrapper);\n    }\n};\n\nexports.removeListener = function(elem, type, callback) {\n    if (elem.removeEventListener) {\n        return elem.removeEventListener(type, callback, false);\n    }\n    if (elem.detachEvent) {\n        elem.detachEvent(\"on\" + type, callback._wrapper || callback);\n    }\n};\nexports.stopEvent = function(e) {\n    exports.stopPropagation(e);\n    exports.preventDefault(e);\n    return false;\n};\n\nexports.stopPropagation = function(e) {\n    if (e.stopPropagation)\n        e.stopPropagation();\n    else\n        e.cancelBubble = true;\n};\n\nexports.preventDefault = function(e) {\n    if (e.preventDefault)\n        e.preventDefault();\n    else\n        e.returnValue = false;\n};\nexports.getButton = function(e) {\n    if (e.type == \"dblclick\")\n        return 0;\n    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n        return 2;\n    if (e.preventDefault) {\n        return e.button;\n    }\n    else {\n        return {1:0, 2:2, 4:1}[e.button];\n    }\n};\n\nexports.capture = function(el, eventHandler, releaseCaptureHandler) {\n    function onMouseUp(e) {\n        eventHandler && eventHandler(e);\n        releaseCaptureHandler && releaseCaptureHandler(e);\n\n        exports.removeListener(document, \"mousemove\", eventHandler, true);\n        exports.removeListener(document, \"mouseup\", onMouseUp, true);\n        exports.removeListener(document, \"dragstart\", onMouseUp, true);\n    }\n\n    exports.addListener(document, \"mousemove\", eventHandler, true);\n    exports.addListener(document, \"mouseup\", onMouseUp, true);\n    exports.addListener(document, \"dragstart\", onMouseUp, true);\n    \n    return onMouseUp;\n};\n\nexports.addTouchMoveListener = function (el, callback) {\n    var startx, starty;\n    exports.addListener(el, \"touchstart\", function (e) {\n        var touches = e.touches;\n        var touchObj = touches[0];\n        startx = touchObj.clientX;\n        starty = touchObj.clientY;\n    });\n    exports.addListener(el, \"touchmove\", function (e) {\n        var touches = e.touches;\n        if (touches.length > 1) return;\n        \n        var touchObj = touches[0];\n\n        e.wheelX = startx - touchObj.clientX;\n        e.wheelY = starty - touchObj.clientY;\n\n        startx = touchObj.clientX;\n        starty = touchObj.clientY;\n\n        callback(e);\n    });\n};\n\nexports.addMouseWheelListener = function(el, callback) {\n    if (\"onmousewheel\" in el) {\n        exports.addListener(el, \"mousewheel\", function(e) {\n            var factor = 8;\n            if (e.wheelDeltaX !== undefined) {\n                e.wheelX = -e.wheelDeltaX / factor;\n                e.wheelY = -e.wheelDeltaY / factor;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = -e.wheelDelta / factor;\n            }\n            callback(e);\n        });\n    } else if (\"onwheel\" in el) {\n        exports.addListener(el, \"wheel\",  function(e) {\n            var factor = 0.35;\n            switch (e.deltaMode) {\n                case e.DOM_DELTA_PIXEL:\n                    e.wheelX = e.deltaX * factor || 0;\n                    e.wheelY = e.deltaY * factor || 0;\n                    break;\n                case e.DOM_DELTA_LINE:\n                case e.DOM_DELTA_PAGE:\n                    e.wheelX = (e.deltaX || 0) * 5;\n                    e.wheelY = (e.deltaY || 0) * 5;\n                    break;\n            }\n            \n            callback(e);\n        });\n    } else {\n        exports.addListener(el, \"DOMMouseScroll\", function(e) {\n            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {\n                e.wheelX = (e.detail || 0) * 5;\n                e.wheelY = 0;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = (e.detail || 0) * 5;\n            }\n            callback(e);\n        });\n    }\n};\n\nexports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {\n    var clicks = 0;\n    var startX, startY, timer; \n    var eventNames = {\n        2: \"dblclick\",\n        3: \"tripleclick\",\n        4: \"quadclick\"\n    };\n\n    function onMousedown(e) {\n        if (exports.getButton(e) !== 0) {\n            clicks = 0;\n        } else if (e.detail > 1) {\n            clicks++;\n            if (clicks > 4)\n                clicks = 1;\n        } else {\n            clicks = 1;\n        }\n        if (useragent.isIE) {\n            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n            if (!timer || isNewClick)\n                clicks = 1;\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);\n\n            if (clicks == 1) {\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        }\n        \n        e._clicks = clicks;\n\n        eventHandler[callbackName](\"mousedown\", e);\n\n        if (clicks > 4)\n            clicks = 0;\n        else if (clicks > 1)\n            return eventHandler[callbackName](eventNames[clicks], e);\n    }\n    function onDblclick(e) {\n        clicks = 2;\n        if (timer)\n            clearTimeout(timer);\n        timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);\n        eventHandler[callbackName](\"mousedown\", e);\n        eventHandler[callbackName](eventNames[clicks], e);\n    }\n    if (!Array.isArray(elements))\n        elements = [elements];\n    elements.forEach(function(el) {\n        exports.addListener(el, \"mousedown\", onMousedown);\n        if (useragent.isOldIE)\n            exports.addListener(el, \"dblclick\", onDblclick);\n    });\n};\n\nvar getModifierHash = useragent.isMac && useragent.isOpera && !(\"KeyboardEvent\" in window)\n    ? function(e) {\n        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);\n    }\n    : function(e) {\n        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n    };\n\nexports.getModifierString = function(e) {\n    return keys.KEY_MODS[getModifierHash(e)];\n};\n\nfunction normalizeCommandKeys(callback, e, keyCode) {\n    var hashId = getModifierHash(e);\n\n    if (!useragent.isMac && pressedKeys) {\n        if (e.getModifierState && (e.getModifierState(\"OS\") || e.getModifierState(\"Win\")))\n            hashId |= 8;\n        if (pressedKeys.altGr) {\n            if ((3 & hashId) != 3)\n                pressedKeys.altGr = 0;\n            else\n                return;\n        }\n        if (keyCode === 18 || keyCode === 17) {\n            var location = \"location\" in e ? e.location : e.keyLocation;\n            if (keyCode === 17 && location === 1) {\n                if (pressedKeys[keyCode] == 1)\n                    ts = e.timeStamp;\n            } else if (keyCode === 18 && hashId === 3 && location === 2) {\n                var dt = e.timeStamp - ts;\n                if (dt < 50)\n                    pressedKeys.altGr = true;\n            }\n        }\n    }\n    \n    if (keyCode in keys.MODIFIER_KEYS) {\n        keyCode = -1;\n    }\n    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {\n        keyCode = -1;\n    }\n    \n    if (!hashId && keyCode === 13) {\n        var location = \"location\" in e ? e.location : e.keyLocation;\n        if (location === 3) {\n            callback(e, hashId, -keyCode);\n            if (e.defaultPrevented)\n                return;\n        }\n    }\n    \n    if (useragent.isChromeOS && hashId & 8) {\n        callback(e, hashId, keyCode);\n        if (e.defaultPrevented)\n            return;\n        else\n            hashId &= ~8;\n    }\n    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n        return false;\n    }\n    \n    return callback(e, hashId, keyCode);\n}\n\n\nexports.addCommandKeyListener = function(el, callback) {\n    var addListener = exports.addListener;\n    if (useragent.isOldGecko || (useragent.isOpera && !(\"KeyboardEvent\" in window))) {\n        var lastKeyDownKeyCode = null;\n        addListener(el, \"keydown\", function(e) {\n            lastKeyDownKeyCode = e.keyCode;\n        });\n        addListener(el, \"keypress\", function(e) {\n            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);\n        });\n    } else {\n        var lastDefaultPrevented = null;\n\n        addListener(el, \"keydown\", function(e) {\n            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;\n            var result = normalizeCommandKeys(callback, e, e.keyCode);\n            lastDefaultPrevented = e.defaultPrevented;\n            return result;\n        });\n\n        addListener(el, \"keypress\", function(e) {\n            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n                exports.stopEvent(e);\n                lastDefaultPrevented = null;\n            }\n        });\n\n        addListener(el, \"keyup\", function(e) {\n            pressedKeys[e.keyCode] = null;\n        });\n\n        if (!pressedKeys) {\n            resetPressedKeys();\n            addListener(window, \"focus\", resetPressedKeys);\n        }\n    }\n};\nfunction resetPressedKeys() {\n    pressedKeys = Object.create(null);\n}\n\nif (typeof window == \"object\" && window.postMessage && !useragent.isOldIE) {\n    var postMessageId = 1;\n    exports.nextTick = function(callback, win) {\n        win = win || window;\n        var messageName = \"zero-timeout-message-\" + (postMessageId++);\n        \n        var listener = function(e) {\n            if (e.data == messageName) {\n                exports.stopPropagation(e);\n                exports.removeListener(win, \"message\", listener);\n                callback();\n            }\n        };\n        \n        exports.addListener(win, \"message\", listener);\n        win.postMessage(messageName, \"*\");\n    };\n}\n\nexports.$idleBlocked = false;\nexports.onIdle = function(cb, timeout) {\n    return setTimeout(function handler() {\n        if (!exports.$idleBlocked) {\n            cb();\n        } else {\n            setTimeout(handler, 100);\n        }\n    }, timeout);\n};\n\nexports.$idleBlockId = null;\nexports.blockIdle = function(delay) {\n    if (exports.$idleBlockId)\n        clearTimeout(exports.$idleBlockId);\n        \n    exports.$idleBlocked = true;\n    exports.$idleBlockId = setTimeout(function() {\n        exports.$idleBlocked = false;\n    }, delay || 100);\n};\n\nexports.nextFrame = typeof window == \"object\" && (window.requestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || window.oRequestAnimationFrame);\n\nif (exports.nextFrame)\n    exports.nextFrame = exports.nextFrame.bind(window);\nelse\n    exports.nextFrame = function(callback) {\n        setTimeout(callback, 17);\n    };\n});\n\nace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nvar Range = function(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n        row: startRow,\n        column: startColumn\n    };\n\n    this.end = {\n        row: endRow,\n        column: endColumn\n    };\n};\n\n(function() {\n    this.isEqual = function(range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    this.toString = function() {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n\n    this.contains = function(row, column) {\n        return this.compare(row, column) == 0;\n    };\n    this.compareRange = function(range) {\n        var cmp,\n            end = range.end,\n            start = range.start;\n\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            } else if (cmp == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (cmp == -1) {\n            return -2;\n        } else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            } else if (cmp == 1) {\n                return 42;\n            } else {\n                return 0;\n            }\n        }\n    };\n    this.comparePoint = function(p) {\n        return this.compare(p.row, p.column);\n    };\n    this.containsRange = function(range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function(range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    this.isEnd = function(row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function(row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function(row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        } else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    this.setEnd = function(row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        } else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    this.inside = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideStart = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideEnd = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.compare = function(row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n\n        if (row < this.start.row)\n            return -1;\n\n        if (row > this.end.row)\n            return 1;\n\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n\n        return 0;\n    };\n    this.compareStart = function(row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareEnd = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareInside = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.clipRows = function(firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = {row: lastRow + 1, column: 0};\n        else if (this.end.row < firstRow)\n            var end = {row: firstRow, column: 0};\n\n        if (this.start.row > lastRow)\n            var start = {row: lastRow + 1, column: 0};\n        else if (this.start.row < firstRow)\n            var start = {row: firstRow, column: 0};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function(row, column) {\n        var cmp = this.compare(row, column);\n\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = {row: row, column: column};\n        else\n            var end = {row: row, column: column};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n\n    this.isEmpty = function() {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    this.isMultiLine = function() {\n        return (this.start.row !== this.end.row);\n    };\n    this.clone = function() {\n        return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function() {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function(session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n\n        return new Range(\n            screenPosStart.row, screenPosStart.column,\n            screenPosEnd.row, screenPosEnd.column\n        );\n    };\n    this.moveBy = function(row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n\n}).call(Range.prototype);\nRange.fromPoints = function(start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = comparePoints;\n\nRange.comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\n\n\nexports.Range = Range;\n});\n\nace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.last = function(a) {\n    return a[a.length - 1];\n};\n\nexports.stringReverse = function(string) {\n    return string.split(\"\").reverse().join(\"\");\n};\n\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\n\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\n\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\n\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\n\nexports.copyObject = function(obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\n\nexports.copyArray = function(array){\n    var copy = [];\n    for (var i=0, l=array.length; i<l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else \n            copy[i] = array[i];\n    }\n    return copy;\n};\n\nexports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    \n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\n\nexports.arrayToMap = function(arr) {\n    var map = {};\n    for (var i=0; i<arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n\n};\n\nexports.createMap = function(props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function(array, value) {\n  for (var i = 0; i <= array.length; i++) {\n    if (value === array[i]) {\n      array.splice(i, 1);\n    }\n  }\n};\n\nexports.escapeRegExp = function(str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\n\nexports.escapeHTML = function(str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\n\nexports.getMatchOffsets = function(string, regExp) {\n    var matches = [];\n\n    string.replace(regExp, function(str) {\n        matches.push({\n            offset: arguments[arguments.length-2],\n            length: str.length\n        });\n    });\n\n    return matches;\n};\nexports.deferredCall = function(fcn) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var deferred = function(timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n\n    deferred.schedule = deferred;\n\n    deferred.call = function() {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n\n    deferred.cancel = function() {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    \n    deferred.isPending = function() {\n        return timer;\n    };\n\n    return deferred;\n};\n\n\nexports.delayedCall = function(fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var _self = function(timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n\n    _self.delay = function(timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n\n    _self.call = function() {\n        this.cancel();\n        fcn();\n    };\n\n    _self.cancel = function() {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n\n    _self.isPending = function() {\n        return timer;\n    };\n\n    return _self;\n};\n});\n\nace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/keys\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar BROKEN_SETDATA = useragent.isChrome < 18;\nvar USE_IE_MIME_TYPE =  useragent.isIE;\nvar HAS_FOCUS_ARGS = useragent.isChrome > 63;\nvar MAX_LINE_LENGTH = 400;\n\nvar KEYS = require(\"../lib/keys\");\nvar MODS = KEYS.KEY_MODS;\nvar isIOS = useragent.isIOS;\nvar valueResetRegex = isIOS ? /\\s/ : /\\n/;\n\nvar TextInput = function(parentNode, host) {\n    var text = dom.createElement(\"textarea\");\n    text.className = \"ace_text-input\";\n\n    text.setAttribute(\"wrap\", \"off\");\n    text.setAttribute(\"autocorrect\", \"off\");\n    text.setAttribute(\"autocapitalize\", \"off\");\n    text.setAttribute(\"spellcheck\", false);\n\n    text.style.opacity = \"0\";\n    parentNode.insertBefore(text, parentNode.firstChild);\n\n    var copied = false;\n    var pasted = false;\n    var inComposition = false;\n    var sendingText = false;\n    var tempStyle = '';\n    var isSelectionEmpty = true;\n    var copyWithEmptySelection = false;\n    \n    if (!useragent.isMobile)\n        text.style.fontSize = \"1px\";\n\n    var commandMode = false;\n    var ignoreFocusEvents = false;\n    \n    var lastValue = \"\";\n    var lastSelectionStart = 0;\n    var lastSelectionEnd = 0;\n    try { var isFocused = document.activeElement === text; } catch(e) {}\n    \n    event.addListener(text, \"blur\", function(e) {\n        if (ignoreFocusEvents) return;\n        host.onBlur(e);\n        isFocused = false;\n    });\n    event.addListener(text, \"focus\", function(e) {\n        if (ignoreFocusEvents) return;\n        isFocused = true;\n        if (useragent.isEdge) {\n            try {\n                if (!document.hasFocus())\n                    return;\n            } catch(e) {}\n        }\n        host.onFocus(e);\n        if (useragent.isEdge)\n            setTimeout(resetSelection);\n        else\n            resetSelection();\n    });\n    this.$focusScroll = false;\n    this.focus = function() {\n        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == \"browser\")\n            return text.focus({ preventScroll: true });\n\n        var top = text.style.top;\n        text.style.position = \"fixed\";\n        text.style.top = \"0px\";\n        try {\n            var isTransformed = text.getBoundingClientRect().top != 0;\n        } catch(e) {\n            return;\n        }\n        var ancestors = [];\n        if (isTransformed) {\n            var t = text.parentElement;\n            while (t && t.nodeType == 1) {\n                ancestors.push(t);\n                t.setAttribute(\"ace_nocontext\", true);\n                if (!t.parentElement && t.getRootNode)\n                    t = t.getRootNode().host;\n                else\n                    t = t.parentElement;\n            }\n        }\n        text.focus({ preventScroll: true });\n        if (isTransformed) {\n            ancestors.forEach(function(p) {\n                p.removeAttribute(\"ace_nocontext\");\n            });\n        }\n        setTimeout(function() {\n            text.style.position = \"\";\n            if (text.style.top == \"0px\")\n                text.style.top = top;\n        }, 0);\n    };\n    this.blur = function() {\n        text.blur();\n    };\n    this.isFocused = function() {\n        return isFocused;\n    };\n    \n    host.on(\"beforeEndOperation\", function() {\n        if (host.curOp && host.curOp.command.name == \"insertstring\")\n            return;\n        if (inComposition) {\n            lastValue = text.value = \"\";\n            onCompositionEnd();\n        }\n        resetSelection();\n    });\n    \n    var resetSelection = isIOS\n    ? function(value) {\n        if (!isFocused || (copied && !value) || sendingText) return;\n        if (!value) \n            value = \"\";\n        var newValue = \"\\n ab\" + value + \"cde fg\\n\";\n        if (newValue != text.value)\n            text.value = lastValue = newValue;\n        \n        var selectionStart = 4;\n        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));\n\n        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {\n            text.setSelectionRange(selectionStart, selectionEnd);\n        }\n        lastSelectionStart = selectionStart;\n        lastSelectionEnd = selectionEnd;\n    }\n    : function() {\n        if (inComposition || sendingText)\n            return;\n        if (!isFocused && !afterContextMenu)\n            return;\n        inComposition = true;\n        \n        var selection = host.selection;\n        var range = selection.getRange();\n        var row = selection.cursor.row;\n        var selectionStart = range.start.column;\n        var selectionEnd = range.end.column;\n        var line = host.session.getLine(row);\n\n        if (range.start.row != row) {\n            var prevLine = host.session.getLine(row - 1);\n            selectionStart = range.start.row < row - 1 ? 0 : selectionStart;\n            selectionEnd += prevLine.length + 1;\n            line = prevLine + \"\\n\" + line;\n        }\n        else if (range.end.row != row) {\n            var nextLine = host.session.getLine(row + 1);\n            selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;\n            selectionEnd += line.length + 1;\n            line = line + \"\\n\" + nextLine;\n        }\n\n        if (line.length > MAX_LINE_LENGTH) {\n            if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {\n                line = line.slice(0, MAX_LINE_LENGTH);\n            } else {\n                line = \"\\n\";\n                selectionStart = 0;\n                selectionEnd = 1;\n            }\n        }\n\n        var newValue = line + \"\\n\\n\";\n        if (newValue != lastValue) {\n            text.value = lastValue = newValue;\n            lastSelectionStart = lastSelectionEnd = newValue.length;\n        }\n        if (afterContextMenu) {\n            lastSelectionStart = text.selectionStart;\n            lastSelectionEnd = text.selectionEnd;\n        }\n        if (\n            lastSelectionEnd != selectionEnd \n            || lastSelectionStart != selectionStart \n            || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization\n        ) {\n            try {\n                text.setSelectionRange(selectionStart, selectionEnd);\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n            } catch(e){}\n        }\n        inComposition = false;\n    };\n\n    if (isFocused)\n        host.onFocus();\n\n\n    var isAllSelected = function(text) {\n        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length\n            && text.value === lastValue && lastValue\n            && text.selectionEnd !== lastSelectionEnd;\n    };\n\n    var onSelect = function(e) {\n        if (inComposition)\n            return;\n        if (copied) {\n            copied = false;\n        } else if (isAllSelected(text)) {\n            host.selectAll();\n            resetSelection();\n        }\n    };\n\n    var inputHandler = null;\n    this.setInputHandler = function(cb) {inputHandler = cb;};\n    this.getInputHandler = function() {return inputHandler;};\n    var afterContextMenu = false;\n    \n    var sendText = function(value, fromInput) {\n        if (afterContextMenu)\n            afterContextMenu = false;\n        if (pasted) {\n            resetSelection();\n            if (value)\n                host.onPaste(value);\n            pasted = false;\n            return \"\";\n        } else {\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n        \n            var extendLeft = lastSelectionStart;\n            var extendRight = lastValue.length - lastSelectionEnd;\n            \n            var inserted = value;\n            var restoreStart = value.length - selectionStart;\n            var restoreEnd = value.length - selectionEnd;\n        \n            var i = 0;\n            while (extendLeft > 0 && lastValue[i] == value[i]) {\n                i++;\n                extendLeft--;\n            }\n            inserted = inserted.slice(i);\n            i = 1;\n            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {\n                i++;\n                extendRight--;\n            }\n            restoreStart -= i-1;\n            restoreEnd -= i-1;\n            inserted = inserted.slice(0, inserted.length - i+1);\n            if (!fromInput && restoreStart == inserted.length && !extendLeft && !extendRight && !restoreEnd)\n                return \"\";\n            \n            sendingText = true;\n            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {\n                host.onTextInput(inserted);\n            } else {\n                host.onTextInput(inserted, {\n                    extendLeft: extendLeft,\n                    extendRight: extendRight,\n                    restoreStart: restoreStart,\n                    restoreEnd: restoreEnd\n                });\n            }\n            sendingText = false;\n            \n            lastValue = value;\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n            return inserted;\n        }\n    };\n    var onInput = function(e) {\n        if (inComposition)\n            return onCompositionUpdate();\n        var data = text.value;\n        var inserted = sendText(data, true);\n        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted))\n            resetSelection();\n    };\n    \n    var handleClipboardData = function(e, data, forceIEMime) {\n        var clipboardData = e.clipboardData || window.clipboardData;\n        if (!clipboardData || BROKEN_SETDATA)\n            return;\n        var mime = USE_IE_MIME_TYPE || forceIEMime ? \"Text\" : \"text/plain\";\n        try {\n            if (data) {\n                return clipboardData.setData(mime, data) !== false;\n            } else {\n                return clipboardData.getData(mime);\n            }\n        } catch(e) {\n            if (!forceIEMime)\n                return handleClipboardData(e, data, true);\n        }\n    };\n\n    var doCopy = function(e, isCut) {\n        var data = host.getCopyText();\n        if (!data)\n            return event.preventDefault(e);\n\n        if (handleClipboardData(e, data)) {\n            if (isIOS) {\n                resetSelection(data);\n                copied = data;\n                setTimeout(function () {\n                    copied = false;\n                }, 10);\n            }\n            isCut ? host.onCut() : host.onCopy();\n            event.preventDefault(e);\n        } else {\n            copied = true;\n            text.value = data;\n            text.select();\n            setTimeout(function(){\n                copied = false;\n                resetSelection();\n                isCut ? host.onCut() : host.onCopy();\n            });\n        }\n    };\n    \n    var onCut = function(e) {\n        doCopy(e, true);\n    };\n    \n    var onCopy = function(e) {\n        doCopy(e, false);\n    };\n    \n    var onPaste = function(e) {\n        var data = handleClipboardData(e);\n        if (typeof data == \"string\") {\n            if (data)\n                host.onPaste(data, e);\n            if (useragent.isIE)\n                setTimeout(resetSelection);\n            event.preventDefault(e);\n        }\n        else {\n            text.value = \"\";\n            pasted = true;\n        }\n    };\n\n    event.addCommandKeyListener(text, host.onCommandKey.bind(host));\n\n    event.addListener(text, \"select\", onSelect);\n    event.addListener(text, \"input\", onInput);\n\n    event.addListener(text, \"cut\", onCut);\n    event.addListener(text, \"copy\", onCopy);\n    event.addListener(text, \"paste\", onPaste);\n    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {\n        event.addListener(parentNode, \"keydown\", function(e) {\n            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n                return;\n\n            switch (e.keyCode) {\n                case 67:\n                    onCopy(e);\n                    break;\n                case 86:\n                    onPaste(e);\n                    break;\n                case 88:\n                    onCut(e);\n                    break;\n            }\n        });\n    }\n    var onCompositionStart = function(e) {\n        if (inComposition || !host.onCompositionStart || host.$readOnly) \n            return;\n        \n        inComposition = {};\n\n        if (commandMode)\n            return;\n        \n        setTimeout(onCompositionUpdate, 0);\n        host.on(\"mousedown\", cancelComposition);\n        \n        var range = host.getSelectionRange();\n        range.end.row = range.start.row;\n        range.end.column = range.start.column;\n        inComposition.markerRange = range;\n        inComposition.selectionStart = lastSelectionStart;\n        host.onCompositionStart(inComposition);\n        \n        if (inComposition.useTextareaForIME) {\n            text.value = \"\";\n            lastValue = \"\";\n            lastSelectionStart = 0;\n            lastSelectionEnd = 0;\n        }\n        else {\n            if (text.msGetInputContext)\n                inComposition.context = text.msGetInputContext();\n            if (text.getInputContext)\n                inComposition.context = text.getInputContext();\n        }\n    };\n\n    var onCompositionUpdate = function() {\n        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n            return;\n        if (commandMode)\n            return cancelComposition();\n        \n        if (inComposition.useTextareaForIME) {\n            host.onCompositionUpdate(text.value);\n        }\n        else {\n            var data = text.value;\n            sendText(data);\n            if (inComposition.markerRange) {\n                if (inComposition.context) {\n                    inComposition.markerRange.start.column = inComposition.selectionStart\n                        = inComposition.context.compositionStartOffset;\n                }\n                inComposition.markerRange.end.column = inComposition.markerRange.start.column\n                    + lastSelectionEnd - inComposition.selectionStart;\n            }\n        }\n    };\n\n    var onCompositionEnd = function(e) {\n        if (!host.onCompositionEnd || host.$readOnly) return;\n        inComposition = false;\n        host.onCompositionEnd();\n        host.off(\"mousedown\", cancelComposition);\n        if (e) onInput();\n    };\n    \n\n    function cancelComposition() {\n        ignoreFocusEvents = true;\n        text.blur();\n        text.focus();\n        ignoreFocusEvents = false;\n    }\n\n    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);\n    \n    function onKeyup(e) {\n        if (e.keyCode == 27 && text.value.length < text.selectionStart) {\n            if (!inComposition)\n                lastValue = text.value;\n            lastSelectionStart = lastSelectionEnd = -1;\n            resetSelection();\n        }\n        syncComposition();\n    }\n\n    event.addListener(text, \"compositionstart\", onCompositionStart);\n    event.addListener(text, \"compositionupdate\", onCompositionUpdate);\n    event.addListener(text, \"keyup\", onKeyup);\n    event.addListener(text, \"keydown\", syncComposition);\n    event.addListener(text, \"compositionend\", onCompositionEnd);\n\n    this.getElement = function() {\n        return text;\n    };\n    this.setCommandMode = function(value) {\n       commandMode = value;\n       text.readOnly = false;\n    };\n    \n    this.setReadOnly = function(readOnly) {\n        if (!commandMode)\n            text.readOnly = readOnly;\n    };\n\n    this.setCopyWithEmptySelection = function(value) {\n        copyWithEmptySelection = value;\n    };\n\n    this.onContextMenu = function(e) {\n        afterContextMenu = true;\n        resetSelection();\n        host._emit(\"nativecontextmenu\", {target: host, domEvent: e});\n        this.moveToMouse(e, true);\n    };\n    \n    this.moveToMouse = function(e, bringToFront) {\n        if (!tempStyle)\n            tempStyle = text.style.cssText;\n        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n            + (useragent.isIE ? \"opacity:0.1;\" : \"\")\n            + \"text-indent: -\" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + \"px;\";\n\n        var rect = host.container.getBoundingClientRect();\n        var style = dom.computedStyle(host.container);\n        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);\n        var maxTop = rect.bottom - top - text.clientHeight -2;\n        var move = function(e) {\n            text.style.left = e.clientX - left - 2 + \"px\";\n            text.style.top = Math.min(e.clientY - top - 2, maxTop) + \"px\";\n        }; \n        move(e);\n\n        if (e.type != \"mousedown\")\n            return;\n\n        if (host.renderer.$keepTextAreaAtCursor)\n            host.renderer.$keepTextAreaAtCursor = null;\n\n        clearTimeout(closeTimeout);\n        if (useragent.isWin)\n            event.capture(host.container, move, onContextMenuClose);\n    };\n\n    this.onContextMenuClose = onContextMenuClose;\n    var closeTimeout;\n    function onContextMenuClose() {\n        clearTimeout(closeTimeout);\n        closeTimeout = setTimeout(function () {\n            if (tempStyle) {\n                text.style.cssText = tempStyle;\n                tempStyle = '';\n            }\n            if (host.renderer.$keepTextAreaAtCursor == null) {\n                host.renderer.$keepTextAreaAtCursor = true;\n                host.renderer.$moveTextAreaToCursor();\n            }\n        }, 0);\n    }\n\n    var onContextMenu = function(e) {\n        host.textInput.onContextMenu(e);\n        onContextMenuClose();\n    };\n    event.addListener(text, \"mouseup\", onContextMenu);\n    event.addListener(text, \"mousedown\", function(e) {\n        e.preventDefault();\n        onContextMenuClose();\n    });\n    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu);\n    event.addListener(text, \"contextmenu\", onContextMenu);\n    \n    if (isIOS)\n        addIosSelectionHandler(parentNode, host, text);\n\n    function addIosSelectionHandler(parentNode, host, text) {\n        var typingResetTimeout = null;\n        var typing = false;\n \n        text.addEventListener(\"keydown\", function (e) {\n            if (typingResetTimeout) clearTimeout(typingResetTimeout);\n            typing = true;\n        }, true);\n\n        text.addEventListener(\"keyup\", function (e) {\n            typingResetTimeout = setTimeout(function () {\n                typing = false;\n            }, 100);\n        }, true);\n        var detectArrowKeys = function(e) {\n            if (document.activeElement !== text) return;\n            if (typing || inComposition) return;\n\n            if (copied) {\n                return;\n            }\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            \n            var key = null;\n            var modifier = 0;\n            console.log(selectionStart, selectionEnd);\n            if (selectionStart == 0) {\n                key = KEYS.up;\n            } else if (selectionStart == 1) {\n                key = KEYS.home;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == \"\\n\") {\n                key = KEYS.end;\n            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == \" \") {\n                key = KEYS.left;\n                modifier = MODS.option;\n            } else if (\n                selectionStart < lastSelectionStart\n                || (\n                    selectionStart == lastSelectionStart \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.left;\n            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split(\"\\n\").length > 2) {\n                key = KEYS.down;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == \" \") {\n                key = KEYS.right;\n                modifier = MODS.option;\n            } else if (\n                selectionEnd > lastSelectionEnd\n                || (\n                    selectionEnd == lastSelectionEnd \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.right;\n            }\n            \n            if (selectionStart !== selectionEnd)\n                modifier |= MODS.shift;\n\n            if (key) {\n                host.onCommandKey(null, modifier, key);\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n                resetSelection(\"\");\n            }\n        };\n        document.addEventListener(\"selectionchange\", detectArrowKeys);\n        host.on(\"destroy\", function() {\n            document.removeEventListener(\"selectionchange\", detectArrowKeys);\n        });\n    }\n\n};\n\nexports.TextInput = TextInput;\n});\n\nace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"../lib/useragent\");\n\nvar DRAG_OFFSET = 0; // pixels\nvar SCROLL_COOLDOWN_T = 550; // milliseconds\n\nfunction DefaultHandlers(mouseHandler) {\n    mouseHandler.$clickSelection = null;\n\n    var editor = mouseHandler.editor;\n    editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n    editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n    editor.setDefaultHandler(\"touchmove\", this.onTouchMove.bind(mouseHandler));\n\n    var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n        \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n\n    exports.forEach(function(x) {\n        mouseHandler[x] = this[x];\n    }, this);\n\n    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n}\n\n(function() {\n\n    this.onMouseDown = function(ev) {\n        var inSelection = ev.inSelection();\n        var pos = ev.getDocumentPosition();\n        this.mousedownEvent = ev;\n        var editor = this.editor;\n\n        var button = ev.getButton();\n        if (button !== 0) {\n            var selectionRange = editor.getSelectionRange();\n            var selectionEmpty = selectionRange.isEmpty();\n            if (selectionEmpty || button == 1)\n                editor.selection.moveToPosition(pos);\n            if (button == 2) {\n                editor.textInput.onContextMenu(ev.domEvent);\n                if (!useragent.isMozilla)\n                    ev.preventDefault();\n            }\n            return;\n        }\n\n        this.mousedownEvent.time = Date.now();\n        if (inSelection && !editor.isFocused()) {\n            editor.focus();\n            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {\n                this.setState(\"focusWait\");\n                this.captureMouse(ev);\n                return;\n            }\n        }\n\n        this.captureMouse(ev);\n        this.startSelect(pos, ev.domEvent._clicks > 1);\n        return ev.preventDefault();\n    };\n\n    this.startSelect = function(pos, waitForClickSelection) {\n        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var editor = this.editor;\n        if (!this.mousedownEvent) return;\n        if (this.mousedownEvent.getShiftKey())\n            editor.selection.selectToPosition(pos);\n        else if (!waitForClickSelection)\n            editor.selection.moveToPosition(pos);\n        if (!waitForClickSelection)\n            this.select();\n        if (editor.renderer.scroller.setCapture) {\n            editor.renderer.scroller.setCapture();\n        }\n        editor.setStyle(\"ace_selecting\");\n        this.setState(\"select\");\n    };\n\n    this.select = function() {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        if (this.$clickSelection) {\n            var cmp = this.$clickSelection.comparePoint(cursor);\n\n            if (cmp == -1) {\n                anchor = this.$clickSelection.end;\n            } else if (cmp == 1) {\n                anchor = this.$clickSelection.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.extendSelectionBy = function(unitName) {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var range = editor.selection[unitName](cursor.row, cursor.column);\n        if (this.$clickSelection) {\n            var cmpStart = this.$clickSelection.comparePoint(range.start);\n            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n\n            if (cmpStart == -1 && cmpEnd <= 0) {\n                anchor = this.$clickSelection.end;\n                if (range.end.row != cursor.row || range.end.column != cursor.column)\n                    cursor = range.start;\n            } else if (cmpEnd == 1 && cmpStart >= 0) {\n                anchor = this.$clickSelection.start;\n                if (range.start.row != cursor.row || range.start.column != cursor.column)\n                    cursor = range.end;\n            } else if (cmpStart == -1 && cmpEnd == 1) {\n                cursor = range.end;\n                anchor = range.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.selectEnd =\n    this.selectAllEnd =\n    this.selectByWordsEnd =\n    this.selectByLinesEnd = function() {\n        this.$clickSelection = null;\n        this.editor.unsetStyle(\"ace_selecting\");\n        if (this.editor.renderer.scroller.releaseCapture) {\n            this.editor.renderer.scroller.releaseCapture();\n        }\n    };\n\n    this.focusWait = function() {\n        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n        var time = Date.now();\n\n        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)\n            this.startSelect(this.mousedownEvent.getDocumentPosition());\n    };\n\n    this.onDoubleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        var session = editor.session;\n\n        var range = session.getBracketRange(pos);\n        if (range) {\n            if (range.isEmpty()) {\n                range.start.column--;\n                range.end.column++;\n            }\n            this.setState(\"select\");\n        } else {\n            range = editor.selection.getWordRange(pos.row, pos.column);\n            this.setState(\"selectByWords\");\n        }\n        this.$clickSelection = range;\n        this.select();\n    };\n\n    this.onTripleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n\n        this.setState(\"selectByLines\");\n        var range = editor.getSelectionRange();\n        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n        } else {\n            this.$clickSelection = editor.selection.getLineRange(pos.row);\n        }\n        this.select();\n    };\n\n    this.onQuadClick = function(ev) {\n        var editor = this.editor;\n\n        editor.selectAll();\n        this.$clickSelection = editor.getSelectionRange();\n        this.setState(\"selectAll\");\n    };\n\n    this.onMouseWheel = function(ev) {\n        if (ev.getAccelKey())\n            return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n        \n        var editor = this.editor;\n        \n        if (!this.$lastScroll)\n            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };\n        \n        var prevScroll = this.$lastScroll;\n        var t = ev.domEvent.timeStamp;\n        var dt = t - prevScroll.t;\n        var vx = dt ? ev.wheelX / dt : prevScroll.vx;\n        var vy = dt ? ev.wheelY / dt : prevScroll.vy;\n        if (dt < SCROLL_COOLDOWN_T) {\n            vx = (vx + prevScroll.vx) / 2;\n            vy = (vy + prevScroll.vy) / 2;\n        }\n        \n        var direction = Math.abs(vx / vy);\n        \n        var canScroll = false;\n        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))\n            canScroll = true;\n        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))\n            canScroll = true;\n            \n        if (canScroll) {\n            prevScroll.allowed = t;\n        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {\n            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)\n                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);\n            if (isSlower) {\n                canScroll = true;\n                prevScroll.allowed = t;\n            }\n            else {\n                prevScroll.allowed = 0;\n            }\n        }\n        \n        prevScroll.t = t;\n        prevScroll.vx = vx;\n        prevScroll.vy = vy;\n\n        if (canScroll) {\n            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    };\n    \n    this.onTouchMove = function(ev) {\n        this.editor._emit(\"mousewheel\", ev);\n    };\n\n}).call(DefaultHandlers.prototype);\n\nexports.DefaultHandlers = DefaultHandlers;\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nfunction calcRangeOrientation(range, cursor) {\n    if (range.start.row == range.end.row)\n        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n        var cmp = cursor.column - 4;\n    else\n        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n\n    if (cmp < 0)\n        return {cursor: range.start, anchor: range.end};\n    else\n        return {cursor: range.end, anchor: range.start};\n}\n\n});\n\nace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nfunction Tooltip (parentNode) {\n    this.isOpen = false;\n    this.$element = null;\n    this.$parentNode = parentNode;\n}\n\n(function() {\n    this.$init = function() {\n        this.$element = dom.createElement(\"div\");\n        this.$element.className = \"ace_tooltip\";\n        this.$element.style.display = \"none\";\n        this.$parentNode.appendChild(this.$element);\n        return this.$element;\n    };\n    this.getElement = function() {\n        return this.$element || this.$init();\n    };\n    this.setText = function(text) {\n        this.getElement().textContent = text;\n    };\n    this.setHtml = function(html) {\n        this.getElement().innerHTML = html;\n    };\n    this.setPosition = function(x, y) {\n        this.getElement().style.left = x + \"px\";\n        this.getElement().style.top = y + \"px\";\n    };\n    this.setClassName = function(className) {\n        dom.addCssClass(this.getElement(), className);\n    };\n    this.show = function(text, x, y) {\n        if (text != null)\n            this.setText(text);\n        if (x != null && y != null)\n            this.setPosition(x, y);\n        if (!this.isOpen) {\n            this.getElement().style.display = \"block\";\n            this.isOpen = true;\n        }\n    };\n\n    this.hide = function() {\n        if (this.isOpen) {\n            this.getElement().style.display = \"none\";\n            this.isOpen = false;\n        }\n    };\n    this.getHeight = function() {\n        return this.getElement().offsetHeight;\n    };\n    this.getWidth = function() {\n        return this.getElement().offsetWidth;\n    };\n    \n    this.destroy = function() {\n        this.isOpen = false;\n        if (this.$element && this.$element.parentNode) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    };\n\n}).call(Tooltip.prototype);\n\nexports.Tooltip = Tooltip;\n});\n\nace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event\",\"ace/tooltip\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar event = require(\"../lib/event\");\nvar Tooltip = require(\"../tooltip\").Tooltip;\n\nfunction GutterHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var gutter = editor.renderer.$gutterLayer;\n    var tooltip = new GutterTooltip(editor.container);\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function(e) {\n        if (!editor.isFocused() || e.getButton() != 0)\n            return;\n        var gutterRegion = gutter.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\")\n            return;\n\n        var row = e.getDocumentPosition().row;\n        var selection = editor.session.selection;\n\n        if (e.getShiftKey())\n            selection.selectTo(row, 0);\n        else {\n            if (e.domEvent.detail == 2) {\n                editor.selectAll();\n                return e.preventDefault();\n            }\n            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n        }\n        mouseHandler.setState(\"selectByLines\");\n        mouseHandler.captureMouse(e);\n        return e.preventDefault();\n    });\n\n\n    var tooltipTimeout, mouseEvent, tooltipAnnotation;\n\n    function showTooltip() {\n        var row = mouseEvent.getDocumentPosition().row;\n        var annotation = gutter.$annotations[row];\n        if (!annotation)\n            return hideTooltip();\n\n        var maxRow = editor.session.getLength();\n        if (row == maxRow) {\n            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n            var pos = mouseEvent.$pos;\n            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n                return hideTooltip();\n        }\n\n        if (tooltipAnnotation == annotation)\n            return;\n        tooltipAnnotation = annotation.text.join(\"<br/>\");\n\n        tooltip.setHtml(tooltipAnnotation);\n        tooltip.show();\n        editor._signal(\"showGutterTooltip\", tooltip);\n        editor.on(\"mousewheel\", hideTooltip);\n\n        if (mouseHandler.$tooltipFollowsMouse) {\n            moveTooltip(mouseEvent);\n        } else {\n            var gutterElement = mouseEvent.domEvent.target;\n            var rect = gutterElement.getBoundingClientRect();\n            var style = tooltip.getElement().style;\n            style.left = rect.right + \"px\";\n            style.top = rect.bottom + \"px\";\n        }\n    }\n\n    function hideTooltip() {\n        if (tooltipTimeout)\n            tooltipTimeout = clearTimeout(tooltipTimeout);\n        if (tooltipAnnotation) {\n            tooltip.hide();\n            tooltipAnnotation = null;\n            editor._signal(\"hideGutterTooltip\", tooltip);\n            editor.removeEventListener(\"mousewheel\", hideTooltip);\n        }\n    }\n\n    function moveTooltip(e) {\n        tooltip.setPosition(e.x, e.y);\n    }\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function(e) {\n        var target = e.domEvent.target || e.domEvent.srcElement;\n        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n            return hideTooltip();\n\n        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)\n            moveTooltip(e);\n\n        mouseEvent = e;\n        if (tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            if (mouseEvent && !mouseHandler.isMousePressed)\n                showTooltip();\n            else\n                hideTooltip();\n        }, 50);\n    });\n\n    event.addListener(editor.renderer.$gutter, \"mouseout\", function(e) {\n        mouseEvent = null;\n        if (!tooltipAnnotation || tooltipTimeout)\n            return;\n\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            hideTooltip();\n        }, 50);\n    });\n    \n    editor.on(\"changeSession\", hideTooltip);\n}\n\nfunction GutterTooltip(parentNode) {\n    Tooltip.call(this, parentNode);\n}\n\noop.inherits(GutterTooltip, Tooltip);\n\n(function(){\n    this.setPosition = function(x, y) {\n        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n        var width = this.getWidth();\n        var height = this.getHeight();\n        x += 15;\n        y += 15;\n        if (x + width > windowWidth) {\n            x -= (x + width) - windowWidth;\n        }\n        if (y + height > windowHeight) {\n            y -= 20 + height;\n        }\n        Tooltip.prototype.setPosition.call(this, x, y);\n    };\n\n}).call(GutterTooltip.prototype);\n\n\n\nexports.GutterHandler = GutterHandler;\n\n});\n\nace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar MouseEvent = exports.MouseEvent = function(domEvent, editor) {\n    this.domEvent = domEvent;\n    this.editor = editor;\n    \n    this.x = this.clientX = domEvent.clientX;\n    this.y = this.clientY = domEvent.clientY;\n\n    this.$pos = null;\n    this.$inSelection = null;\n    \n    this.propagationStopped = false;\n    this.defaultPrevented = false;\n};\n\n(function() {  \n    \n    this.stopPropagation = function() {\n        event.stopPropagation(this.domEvent);\n        this.propagationStopped = true;\n    };\n    \n    this.preventDefault = function() {\n        event.preventDefault(this.domEvent);\n        this.defaultPrevented = true;\n    };\n    \n    this.stop = function() {\n        this.stopPropagation();\n        this.preventDefault();\n    };\n    this.getDocumentPosition = function() {\n        if (this.$pos)\n            return this.$pos;\n        \n        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n        return this.$pos;\n    };\n    this.inSelection = function() {\n        if (this.$inSelection !== null)\n            return this.$inSelection;\n            \n        var editor = this.editor;\n        \n\n        var selectionRange = editor.getSelectionRange();\n        if (selectionRange.isEmpty())\n            this.$inSelection = false;\n        else {\n            var pos = this.getDocumentPosition();\n            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n        }\n\n        return this.$inSelection;\n    };\n    this.getButton = function() {\n        return event.getButton(this.domEvent);\n    };\n    this.getShiftKey = function() {\n        return this.domEvent.shiftKey;\n    };\n    \n    this.getAccelKey = useragent.isMac\n        ? function() { return this.domEvent.metaKey; }\n        : function() { return this.domEvent.ctrlKey; };\n    \n}).call(MouseEvent.prototype);\n\n});\n\nace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\n\nvar AUTOSCROLL_DELAY = 200;\nvar SCROLL_CURSOR_DELAY = 200;\nvar SCROLL_CURSOR_HYSTERESIS = 5;\n\nfunction DragdropHandler(mouseHandler) {\n\n    var editor = mouseHandler.editor;\n\n    var blankImage = dom.createElement(\"img\");\n    blankImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (useragent.isOpera)\n        blankImage.style.cssText = \"width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;\";\n\n    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n\n     exports.forEach(function(x) {\n         mouseHandler[x] = this[x];\n    }, this);\n    editor.addEventListener(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n\n\n    var mouseTarget = editor.container;\n    var dragSelectionMarker, x, y;\n    var timerId, range;\n    var dragCursor, counter = 0;\n    var dragOperation;\n    var isInternal;\n    var autoScrollStartTime;\n    var cursorMovedTime;\n    var cursorPointOnCaretMoved;\n\n    this.onDragStart = function(e) {\n        if (this.cancelDrag || !mouseTarget.draggable) {\n            var self = this;\n            setTimeout(function(){\n                self.startSelect();\n                self.captureMouse(e);\n            }, 0);\n            return e.preventDefault();\n        }\n        range = editor.getSelectionRange();\n\n        var dataTransfer = e.dataTransfer;\n        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n        if (useragent.isOpera) {\n            editor.container.appendChild(blankImage);\n            blankImage.scrollTop = 0;\n        }\n        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);\n        if (useragent.isOpera) {\n            editor.container.removeChild(blankImage);\n        }\n        dataTransfer.clearData();\n        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n\n        isInternal = true;\n        this.setState(\"drag\");\n    };\n\n    this.onDragEnd = function(e) {\n        mouseTarget.draggable = false;\n        isInternal = false;\n        this.setState(null);\n        if (!editor.getReadOnly()) {\n            var dropEffect = e.dataTransfer.dropEffect;\n            if (!dragOperation && dropEffect == \"move\")\n                editor.session.remove(editor.getSelectionRange());\n            editor.renderer.$cursorLayer.setBlinking(true);\n        }\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n    };\n\n    this.onDragEnter = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker)\n            addDragMarker();\n        counter++;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragOver = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker) {\n            addDragMarker();\n            counter++;\n        }\n        if (onMouseMoveTimer !== null)\n            onMouseMoveTimer = null;\n\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragLeave = function(e) {\n        counter--;\n        if (counter <= 0 && dragSelectionMarker) {\n            clearDragMarker();\n            dragOperation = null;\n            return event.preventDefault(e);\n        }\n    };\n\n    this.onDrop = function(e) {\n        if (!dragCursor)\n            return;\n        var dataTransfer = e.dataTransfer;\n        if (isInternal) {\n            switch (dragOperation) {\n                case \"move\":\n                    if (range.contains(dragCursor.row, dragCursor.column)) {\n                        range = {\n                            start: dragCursor,\n                            end: dragCursor\n                        };\n                    } else {\n                        range = editor.moveText(range, dragCursor);\n                    }\n                    break;\n                case \"copy\":\n                    range = editor.moveText(range, dragCursor, true);\n                    break;\n            }\n        } else {\n            var dropData = dataTransfer.getData('Text');\n            range = {\n                start: dragCursor,\n                end: editor.session.insert(dragCursor, dropData)\n            };\n            editor.focus();\n            dragOperation = null;\n        }\n        clearDragMarker();\n        return event.preventDefault(e);\n    };\n\n    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler));\n    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler));\n\n    function scrollCursorIntoView(cursor, prevCursor) {\n        var now = Date.now();\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n        if (!cursorMovedTime || vMovement || hMovement) {\n            editor.moveCursorToPosition(cursor);\n            cursorMovedTime = now;\n            cursorPointOnCaretMoved = {x: x, y: y};\n        } else {\n            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n                cursorMovedTime = null;\n            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n                editor.renderer.scrollCursorIntoView();\n                cursorMovedTime = null;\n            }\n        }\n    }\n\n    function autoScroll(cursor, prevCursor) {\n        var now = Date.now();\n        var lineHeight = editor.renderer.layerConfig.lineHeight;\n        var characterWidth = editor.renderer.layerConfig.characterWidth;\n        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n        var offsets = {\n           x: {\n               left: x - editorRect.left,\n               right: editorRect.right - x\n           },\n           y: {\n               top: y - editorRect.top,\n               bottom: editorRect.bottom - y\n           }\n        };\n        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n        var scrollCursor = {row: cursor.row, column: cursor.column};\n        if (nearestXOffset / characterWidth <= 2) {\n            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n        }\n        if (nearestYOffset / lineHeight <= 1) {\n            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n        }\n        var vScroll = cursor.row != scrollCursor.row;\n        var hScroll = cursor.column != scrollCursor.column;\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        if (vScroll || (hScroll && !vMovement)) {\n            if (!autoScrollStartTime)\n                autoScrollStartTime = now;\n            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n                editor.renderer.scrollCursorIntoView(scrollCursor);\n        } else {\n            autoScrollStartTime = null;\n        }\n    }\n\n    function onDragInterval() {\n        var prevCursor = dragCursor;\n        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n        scrollCursorIntoView(dragCursor, prevCursor);\n        autoScroll(dragCursor, prevCursor);\n    }\n\n    function addDragMarker() {\n        range = editor.selection.toOrientedRange();\n        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n        editor.clearSelection();\n        if (editor.isFocused())\n            editor.renderer.$cursorLayer.setBlinking(false);\n        clearInterval(timerId);\n        onDragInterval();\n        timerId = setInterval(onDragInterval, 20);\n        counter = 0;\n        event.addListener(document, \"mousemove\", onMouseMove);\n    }\n\n    function clearDragMarker() {\n        clearInterval(timerId);\n        editor.session.removeMarker(dragSelectionMarker);\n        dragSelectionMarker = null;\n        editor.selection.fromOrientedRange(range);\n        if (editor.isFocused() && !isInternal)\n            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());\n        range = null;\n        dragCursor = null;\n        counter = 0;\n        autoScrollStartTime = null;\n        cursorMovedTime = null;\n        event.removeListener(document, \"mousemove\", onMouseMove);\n    }\n    var onMouseMoveTimer = null;\n    function onMouseMove() {\n        if (onMouseMoveTimer == null) {\n            onMouseMoveTimer = setTimeout(function() {\n                if (onMouseMoveTimer != null && dragSelectionMarker)\n                    clearDragMarker();\n            }, 20);\n        }\n    }\n\n    function canAccept(dataTransfer) {\n        var types = dataTransfer.types;\n        return !types || Array.prototype.some.call(types, function(type) {\n            return type == 'text/plain' || type == 'Text';\n        });\n    }\n\n    function getDropEffect(e) {\n        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n\n        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n        var effectAllowed = \"uninitialized\";\n        try {\n            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n        } catch (e) {}\n        var dropEffect = \"none\";\n\n        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"move\";\n        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n\n        return dropEffect;\n    }\n}\n\n(function() {\n\n    this.dragWait = function() {\n        var interval = Date.now() - this.mousedownEvent.time;\n        if (interval > this.editor.getDragDelay())\n            this.startDrag();\n    };\n\n    this.dragWaitEnd = function() {\n        var target = this.editor.container;\n        target.draggable = false;\n        this.startSelect(this.mousedownEvent.getDocumentPosition());\n        this.selectEnd();\n    };\n\n    this.dragReadyEnd = function(e) {\n        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n        this.dragWaitEnd();\n    };\n\n    this.startDrag = function(){\n        this.cancelDrag = false;\n        var editor = this.editor;\n        var target = editor.container;\n        target.draggable = true;\n        editor.renderer.$cursorLayer.setBlinking(false);\n        editor.setStyle(\"ace_dragging\");\n        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n        editor.renderer.setCursorStyle(cursorStyle);\n        this.setState(\"dragReady\");\n    };\n\n    this.onMouseDrag = function(e) {\n        var target = this.editor.container;\n        if (useragent.isIE && this.state == \"dragReady\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 3)\n                target.dragDrop();\n        }\n        if (this.state === \"dragWait\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 0) {\n                target.draggable = false;\n                this.startSelect(this.mousedownEvent.getDocumentPosition());\n            }\n        }\n    };\n\n    this.onMouseDown = function(e) {\n        if (!this.$dragEnabled)\n            return;\n        this.mousedownEvent = e;\n        var editor = this.editor;\n\n        var inSelection = e.inSelection();\n        var button = e.getButton();\n        var clickCount = e.domEvent.detail || 1;\n        if (clickCount === 1 && button === 0 && inSelection) {\n            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n                return;\n            this.mousedownEvent.time = Date.now();\n            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n            if (\"unselectable\" in eventTarget)\n                eventTarget.unselectable = \"on\";\n            if (editor.getDragDelay()) {\n                if (useragent.isWebKit) {\n                    this.cancelDrag = true;\n                    var mouseTarget = editor.container;\n                    mouseTarget.draggable = true;\n                }\n                this.setState(\"dragWait\");\n            } else {\n                this.startDrag();\n            }\n            this.captureMouse(e, this.onMouseDrag.bind(this));\n            e.defaultPrevented = true;\n        }\n    };\n\n}).call(DragdropHandler.prototype);\n\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nexports.DragdropHandler = DragdropHandler;\n\n});\n\nace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"./dom\");\n\nexports.get = function (url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            callback(xhr.responseText);\n        }\n    };\n    xhr.send(null);\n};\n\nexports.loadScript = function(path, callback) {\n    var head = dom.getDocumentHead();\n    var s = document.createElement('script');\n\n    s.src = path;\n    head.appendChild(s);\n\n    s.onload = s.onreadystatechange = function(_, isAbort) {\n        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n            s = s.onload = s.onreadystatechange = null;\n            if (!isAbort)\n                callback();\n        }\n    };\n};\nexports.qualifyURL = function(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.href;\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar EventEmitter = {};\nvar stopPropagation = function() { this.propagationStopped = true; };\nvar preventDefault = function() { this.defaultPrevented = true; };\n\nEventEmitter._emit =\nEventEmitter._dispatchEvent = function(eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler)\n        return;\n\n    if (typeof e != \"object\" || !e)\n        e = {};\n\n    if (!e.type)\n        e.type = eventName;\n    if (!e.stopPropagation)\n        e.stopPropagation = stopPropagation;\n    if (!e.preventDefault)\n        e.preventDefault = preventDefault;\n\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++) {\n        listeners[i](e, this);\n        if (e.propagationStopped)\n            break;\n    }\n    \n    if (defaultHandler && !e.defaultPrevented)\n        return defaultHandler(e, this);\n};\n\n\nEventEmitter._signal = function(eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](e, this);\n};\n\nEventEmitter.once = function(eventName, callback) {\n    var _self = this;\n    this.addEventListener(eventName, function newCallback() {\n        _self.removeEventListener(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function(resolve) {\n            callback = resolve;\n        });\n    }\n};\n\n\nEventEmitter.setDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = {_disabled_: {}};\n    \n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1) \n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    \n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\n\nEventEmitter.on =\nEventEmitter.addEventListener = function(eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        listeners = this._eventRegistry[eventName] = [];\n\n    if (listeners.indexOf(callback) == -1)\n        listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n};\n\nEventEmitter.off =\nEventEmitter.removeListener =\nEventEmitter.removeEventListener = function(eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        return;\n\n    var index = listeners.indexOf(callback);\n    if (index !== -1)\n        listeners.splice(index, 1);\n};\n\nEventEmitter.removeAllListeners = function(eventName) {\n    if (this._eventRegistry) this._eventRegistry[eventName] = [];\n};\n\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/lib/app_config\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"no use strict\";\n\nvar oop = require(\"./oop\");\nvar EventEmitter = require(\"./event_emitter\").EventEmitter;\n\nvar optionsProvider = {\n    setOptions: function(optList) {\n        Object.keys(optList).forEach(function(key) {\n            this.setOption(key, optList[key]);\n        }, this);\n    },\n    getOptions: function(optionNames) {\n        var result = {};\n        if (!optionNames) {\n            var options = this.$options;\n            optionNames = Object.keys(options).filter(function(key) {\n                return !options[key].hidden;\n            });\n        } else if (!Array.isArray(optionNames)) {\n            result = optionNames;\n            optionNames = Object.keys(result);\n        }\n        optionNames.forEach(function(key) {\n            result[key] = this.getOption(key);\n        }, this);\n        return result;\n    },\n    setOption: function(name, value) {\n        if (this[\"$\" + name] === value)\n            return;\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n\n        if (!opt.handlesSet)\n            this[\"$\" + name] = value;\n        if (opt && opt.set)\n            opt.set.call(this, value);\n    },\n    getOption: function(name) {\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n    }\n};\n\nfunction warn(message) {\n    if (typeof console != \"undefined\" && console.warn)\n        console.warn.apply(console, arguments);\n}\n\nfunction reportError(msg, data) {\n    var e = new Error(msg);\n    e.data = data;\n    if (typeof console == \"object\" && console.error)\n        console.error(e);\n    setTimeout(function() { throw e; });\n}\n\nvar AppConfig = function() {\n    this.$defaultOptions = {};\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n    this.defineOptions = function(obj, path, options) {\n        if (!obj.$options)\n            this.$defaultOptions[path] = obj.$options = {};\n\n        Object.keys(options).forEach(function(key) {\n            var opt = options[key];\n            if (typeof opt == \"string\")\n                opt = {forwardTo: opt};\n\n            opt.name || (opt.name = key);\n            obj.$options[opt.name] = opt;\n            if (\"initialValue\" in opt)\n                obj[\"$\" + opt.name] = opt.initialValue;\n        });\n        oop.implement(obj, optionsProvider);\n\n        return this;\n    };\n\n    this.resetOptions = function(obj) {\n        Object.keys(obj.$options).forEach(function(key) {\n            var opt = obj.$options[key];\n            if (\"value\" in opt)\n                obj.setOption(key, opt.value);\n        });\n    };\n\n    this.setDefaultValue = function(path, name, value) {\n        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});\n        if (opts[name]) {\n            if (opts.forwardTo)\n                this.setDefaultValue(opts.forwardTo, name, value);\n            else\n                opts[name].value = value;\n        }\n    };\n\n    this.setDefaultValues = function(path, optionHash) {\n        Object.keys(optionHash).forEach(function(key) {\n            this.setDefaultValue(path, key, optionHash[key]);\n        }, this);\n    };\n    \n    this.warn = warn;\n    this.reportError = reportError;\n    \n}).call(AppConfig.prototype);\n\nexports.AppConfig = AppConfig;\n\n});\n\nace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/app_config\"], function(require, exports, module) {\n\"no use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar net = require(\"./lib/net\");\nvar AppConfig = require(\"./lib/app_config\").AppConfig;\n\nmodule.exports = exports = new AppConfig();\n\nvar global = (function() {\n    return this || typeof window != \"undefined\" && window;\n})();\n\nvar options = {\n    packaged: false,\n    workerPath: null,\n    modePath: null,\n    themePath: null,\n    basePath: \"\",\n    suffix: \".js\",\n    $moduleUrls: {},\n    loadWorkerFromBlob: true\n};\n\nexports.get = function(key) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n\n    return options[key];\n};\n\nexports.set = function(key, value) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n\n    options[key] = value;\n};\n\nexports.all = function() {\n    return lang.copyObject(options);\n};\n\nexports.$modes = {};\nexports.moduleUrl = function(name, component) {\n    if (options.$moduleUrls[name])\n        return options.$moduleUrls[name];\n\n    var parts = name.split(\"/\");\n    component = component || parts[parts.length - 2] || \"\";\n    var sep = component == \"snippets\" ? \"/\" : \"-\";\n    var base = parts[parts.length - 1];\n    if (component == \"worker\" && sep == \"-\") {\n        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n        base = base.replace(re, \"\");\n    }\n\n    if ((!base || base == component) && parts.length > 1)\n        base = parts[parts.length - 2];\n    var path = options[component + \"Path\"];\n    if (path == null) {\n        path = options.basePath;\n    } else if (sep == \"/\") {\n        component = sep = \"\";\n    }\n    if (path && path.slice(-1) != \"/\")\n        path += \"/\";\n    return path + component + sep + base + this.get(\"suffix\");\n};\n\nexports.setModuleUrl = function(name, subst) {\n    return options.$moduleUrls[name] = subst;\n};\n\nexports.$loading = {};\nexports.loadModule = function(moduleName, onLoad) {\n    var module, moduleType;\n    if (Array.isArray(moduleName)) {\n        moduleType = moduleName[0];\n        moduleName = moduleName[1];\n    }\n\n    try {\n        module = require(moduleName);\n    } catch (e) {}\n    if (module && !exports.$loading[moduleName])\n        return onLoad && onLoad(module);\n\n    if (!exports.$loading[moduleName])\n        exports.$loading[moduleName] = [];\n\n    exports.$loading[moduleName].push(onLoad);\n\n    if (exports.$loading[moduleName].length > 1)\n        return;\n\n    var afterLoad = function() {\n        require([moduleName], function(module) {\n            exports._emit(\"load.module\", {name: moduleName, module: module});\n            var listeners = exports.$loading[moduleName];\n            exports.$loading[moduleName] = null;\n            listeners.forEach(function(onLoad) {\n                onLoad && onLoad(module);\n            });\n        });\n    };\n\n    if (!exports.get(\"packaged\"))\n        return afterLoad();\n    \n    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n    reportErrorIfPathIsNotConfigured();\n};\n\nvar reportErrorIfPathIsNotConfigured = function() {\n    if (\n        !options.basePath && !options.workerPath \n        && !options.modePath && !options.themePath\n        && !Object.keys(options.$moduleUrls).length\n    ) {\n        console.error(\n            \"Unable to infer path to ace from script src,\",\n            \"use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes\",\n            \"or with webpack use ace/webpack-resolver\"\n        );\n        reportErrorIfPathIsNotConfigured = function() {};\n    }\n};\ninit(true);function init(packaged) {\n\n    if (!global || !global.document)\n        return;\n    \n    options.packaged = packaged || require.packaged || module.packaged || (global.define && __webpack_require__(3).packaged);\n\n    var scriptOptions = {};\n    var scriptUrl = \"\";\n    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n    var currentDocument = currentScript && currentScript.ownerDocument || document;\n    \n    var scripts = currentDocument.getElementsByTagName(\"script\");\n    for (var i=0; i<scripts.length; i++) {\n        var script = scripts[i];\n\n        var src = script.src || script.getAttribute(\"src\");\n        if (!src)\n            continue;\n\n        var attributes = script.attributes;\n        for (var j=0, l=attributes.length; j < l; j++) {\n            var attr = attributes[j];\n            if (attr.name.indexOf(\"data-ace-\") === 0) {\n                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n            }\n        }\n\n        var m = src.match(/^(.*)\\/ace(\\-\\w+)?\\.js(\\?|$)/);\n        if (m)\n            scriptUrl = m[1];\n    }\n\n    if (scriptUrl) {\n        scriptOptions.base = scriptOptions.base || scriptUrl;\n        scriptOptions.packaged = true;\n    }\n\n    scriptOptions.basePath = scriptOptions.base;\n    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n    delete scriptOptions.base;\n\n    for (var key in scriptOptions)\n        if (typeof scriptOptions[key] !== \"undefined\")\n            exports.set(key, scriptOptions[key]);\n}\n\nexports.init = init;\n\nfunction deHyphenate(str) {\n    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n}\n\n});\n\nace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar DefaultHandlers = require(\"./default_handlers\").DefaultHandlers;\nvar DefaultGutterHandler = require(\"./default_gutter_handler\").GutterHandler;\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar DragdropHandler = require(\"./dragdrop_handler\").DragdropHandler;\nvar config = require(\"../config\");\n\nvar MouseHandler = function(editor) {\n    var _self = this;\n    this.editor = editor;\n\n    new DefaultHandlers(this);\n    new DefaultGutterHandler(this);\n    new DragdropHandler(this);\n\n    var focusEditor = function(e) {\n        var windowBlurred = !document.hasFocus || !document.hasFocus()\n            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());\n        if (windowBlurred)\n            window.focus();\n        editor.focus();\n    };\n\n    var mouseTarget = editor.renderer.getMouseEventTarget();\n    event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"));\n    event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"));\n    event.addMultiMouseDownListener([\n        mouseTarget,\n        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,\n        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,\n        editor.textInput && editor.textInput.getElement()\n    ].filter(Boolean), [400, 300, 250], this, \"onMouseEvent\");\n    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"));\n    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, \"touchmove\"));\n\n    var gutterEl = editor.renderer.$gutter;\n    event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"));\n    event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"));\n    event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"));\n    event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"));\n\n    event.addListener(mouseTarget, \"mousedown\", focusEditor);\n    event.addListener(gutterEl, \"mousedown\", focusEditor);\n    if (useragent.isIE && editor.renderer.scrollBarV) {\n        event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor);\n        event.addListener(editor.renderer.scrollBarH.element, \"mousedown\", focusEditor);\n    }\n\n    editor.on(\"mousemove\", function(e){\n        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n            return;\n\n        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);\n        var range = editor.session.selection.getRange();\n        var renderer = editor.renderer;\n\n        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {\n            renderer.setCursorStyle(\"default\");\n        } else {\n            renderer.setCursorStyle(\"\");\n        }\n    });\n};\n\n(function() {\n    this.onMouseEvent = function(name, e) {\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseMove = function(name, e) {\n        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n        if (!listeners || !listeners.length)\n            return;\n\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseWheel = function(name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n\n        this.editor._emit(name, mouseEvent);\n    };\n    \n    this.onTouchMove = function (name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = 1;//this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n        this.editor._emit(name, mouseEvent);\n    };\n\n    this.setState = function(state) {\n        this.state = state;\n    };\n\n    this.captureMouse = function(ev, mouseMoveHandler) {\n        this.x = ev.x;\n        this.y = ev.y;\n\n        this.isMousePressed = true;\n        var editor = this.editor;\n        var renderer = this.editor.renderer;\n        if (renderer.$keepTextAreaAtCursor)\n            renderer.$keepTextAreaAtCursor = null;\n\n        var self = this;\n        var onMouseMove = function(e) {\n            if (!e) return;\n            if (useragent.isWebKit && !e.which && self.releaseMouse)\n                return self.releaseMouse();\n\n            self.x = e.clientX;\n            self.y = e.clientY;\n            mouseMoveHandler && mouseMoveHandler(e);\n            self.mouseEvent = new MouseEvent(e, self.editor);\n            self.$mouseMoved = true;\n        };\n\n        var onCaptureEnd = function(e) {\n            editor.off(\"beforeEndOperation\", onOperationEnd);\n            clearInterval(timerId);\n            onCaptureInterval();\n            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n            self.state = \"\";\n            if (renderer.$keepTextAreaAtCursor == null) {\n                renderer.$keepTextAreaAtCursor = true;\n                renderer.$moveTextAreaToCursor();\n            }\n            self.isMousePressed = false;\n            self.$onCaptureMouseMove = self.releaseMouse = null;\n            e && self.onMouseEvent(\"mouseup\", e);\n            editor.endOperation();\n        };\n\n        var onCaptureInterval = function() {\n            self[self.state] && self[self.state]();\n            self.$mouseMoved = false;\n        };\n\n        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n            return setTimeout(function() {onCaptureEnd(ev);});\n        }\n\n        var onOperationEnd = function(e) {\n            if (!self.releaseMouse) return;\n            if (editor.curOp.command.name && editor.curOp.selectionChanged) {\n                self[self.state + \"End\"] && self[self.state + \"End\"]();\n                self.state = \"\";\n                self.releaseMouse();\n            }\n        };\n\n        editor.on(\"beforeEndOperation\", onOperationEnd);\n        editor.startOperation({command: {name: \"mouse\"}});\n\n        self.$onCaptureMouseMove = onMouseMove;\n        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n        var timerId = setInterval(onCaptureInterval, 20);\n    };\n    this.releaseMouse = null;\n    this.cancelContextMenu = function() {\n        var stop = function(e) {\n            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n                return;\n            this.editor.off(\"nativecontextmenu\", stop);\n            if (e && e.domEvent)\n                event.stopEvent(e.domEvent);\n        }.bind(this);\n        setTimeout(stop, 10);\n        this.editor.on(\"nativecontextmenu\", stop);\n    };\n}).call(MouseHandler.prototype);\n\nconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n    scrollSpeed: {initialValue: 2},\n    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},\n    dragEnabled: {initialValue: true},\n    focusTimeout: {initialValue: 0},\n    tooltipFollowsMouse: {initialValue: true}\n});\n\n\nexports.MouseHandler = MouseHandler;\n});\n\nace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\n\nfunction FoldHandler(editor) {\n\n    editor.on(\"click\", function(e) {\n        var position = e.getDocumentPosition();\n        var session = editor.session;\n        var fold = session.getFoldAt(position.row, position.column, 1);\n        if (fold) {\n            if (e.getAccelKey())\n                session.removeFold(fold);\n            else\n                session.expandFold(fold);\n\n            e.stop();\n        }\n        \n        var target = e.domEvent && e.domEvent.target;\n        if (target && dom.hasCssClass(target, \"ace_inline_button\")) {\n            if (dom.hasCssClass(target, \"ace_toggle_wrap\")) {\n                session.setOption(\"wrap\", true);\n                editor.renderer.scrollCursorIntoView();\n            }\n        }\n    });\n\n    editor.on(\"gutterclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            if (session.foldWidgets && session.foldWidgets[row])\n                editor.session.onFoldWidgetClick(row, e);\n            if (!editor.isFocused())\n                editor.focus();\n            e.stop();\n        }\n    });\n\n    editor.on(\"gutterdblclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            var data = session.getParentFoldRangeData(row, true);\n            var range = data.range || data.firstRange;\n\n            if (range) {\n                row = range.start.row;\n                var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n\n                if (fold) {\n                    session.removeFold(fold);\n                } else {\n                    session.addFold(\"...\", range);\n                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});\n                }\n            }\n            e.stop();\n        }\n    });\n}\n\nexports.FoldHandler = FoldHandler;\n\n});\n\nace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil  = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\n\nvar KeyBinding = function(editor) {\n    this.$editor = editor;\n    this.$data = {editor: editor};\n    this.$handlers = [];\n    this.setDefaultHandler(editor.commands);\n};\n\n(function() {\n    this.setDefaultHandler = function(kb) {\n        this.removeKeyboardHandler(this.$defaultHandler);\n        this.$defaultHandler = kb;\n        this.addKeyboardHandler(kb, 0);\n    };\n\n    this.setKeyboardHandler = function(kb) {\n        var h = this.$handlers;\n        if (h[h.length - 1] == kb)\n            return;\n\n        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n            this.removeKeyboardHandler(h[h.length - 1]);\n\n        this.addKeyboardHandler(kb, 1);\n    };\n\n    this.addKeyboardHandler = function(kb, pos) {\n        if (!kb)\n            return;\n        if (typeof kb == \"function\" && !kb.handleKeyboard)\n            kb.handleKeyboard = kb;\n        var i = this.$handlers.indexOf(kb);\n        if (i != -1)\n            this.$handlers.splice(i, 1);\n\n        if (pos == undefined)\n            this.$handlers.push(kb);\n        else\n            this.$handlers.splice(pos, 0, kb);\n\n        if (i == -1 && kb.attach)\n            kb.attach(this.$editor);\n    };\n\n    this.removeKeyboardHandler = function(kb) {\n        var i = this.$handlers.indexOf(kb);\n        if (i == -1)\n            return false;\n        this.$handlers.splice(i, 1);\n        kb.detach && kb.detach(this.$editor);\n        return true;\n    };\n\n    this.getKeyboardHandler = function() {\n        return this.$handlers[this.$handlers.length - 1];\n    };\n    \n    this.getStatusText = function() {\n        var data = this.$data;\n        var editor = data.editor;\n        return this.$handlers.map(function(h) {\n            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n        }).filter(Boolean).join(\" \");\n    };\n\n    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {\n        var toExecute;\n        var success = false;\n        var commands = this.$editor.commands;\n\n        for (var i = this.$handlers.length; i--;) {\n            toExecute = this.$handlers[i].handleKeyboard(\n                this.$data, hashId, keyString, keyCode, e\n            );\n            if (!toExecute || !toExecute.command)\n                continue;\n            if (toExecute.command == \"null\") {\n                success = true;\n            } else {\n                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);\n            }\n            if (success && e && hashId != -1 && \n                toExecute.passEvent != true && toExecute.command.passEvent != true\n            ) {\n                event.stopEvent(e);\n            }\n            if (success)\n                break;\n        }\n        \n        if (!success && hashId == -1) {\n            toExecute = {command: \"insertstring\"};\n            success = commands.exec(\"insertstring\", this.$editor, keyString);\n        }\n        \n        if (success && this.$editor._signal)\n            this.$editor._signal(\"keyboardActivity\", toExecute);\n        \n        return success;\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        var keyString = keyUtil.keyCodeToString(keyCode);\n        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n    };\n\n    this.onTextInput = function(text) {\n        this.$callKeyboardHandlers(-1, text);\n    };\n\n}).call(KeyBinding.prototype);\n\nexports.KeyBinding = KeyBinding;\n});\n\nace.define(\"ace/lib/bidiutil\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar ArabicAlefBetIntervalsBegine = ['\\u0621', '\\u0641'];\nvar ArabicAlefBetIntervalsEnd = ['\\u063A', '\\u064a'];\nvar dir = 0, hiLevel = 0;\nvar lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;\n\nvar impTab_LTR = [\t[\t0,\t\t3,\t\t0,\t\t1,\t\t0,\t\t0,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t1,\t\t2,\t\t2,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t0x11,\t\t2,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t1,\t\t0\t],\t[\t0,\t\t3,\t\t0x15,\t\t0x15,\t\t4,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t2,\t\t0\t]\n];\n\nvar impTab_RTL = [\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t1,\t\t0\t],\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t1,\t\t3,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t0x21,\t\t3,\t\t1,\t\t1\t]\n];\n\nvar LTR = 0, RTL = 1;\n\nvar L = 0;\nvar R = 1;\nvar EN = 2;\nvar AN = 3;\nvar ON = 4;\nvar B = 5;\nvar S = 6;\nvar AL = 7;\nvar WS = 8;\nvar CS = 9;\nvar ES = 10;\nvar ET = 11;\nvar NSM = 12;\nvar LRE = 13;\nvar RLE = 14;\nvar PDF = 15;\nvar LRO = 16;\nvar RLO = 17;\nvar BN = 18;\n\nvar UnicodeTBL00 = [\nBN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,\nWS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,\nEN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,\nBN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nCS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,\nET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON\n];\n\nvar UnicodeTBL20 = [\nWS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R\t,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,\nET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS\n];\n\nfunction _computeLevels(chars, levels, len, charTypes) {\n\tvar impTab = dir ? impTab_RTL : impTab_LTR\n\t\t, prevState = null, newClass = null, newLevel = null, newState = 0\n\t\t, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];\n\n\tif (!charTypes) {\n\t\tfor (i = 0, charTypes = []; i < len; i++) {\n\t\t\tcharTypes[i] = _getCharacterType(chars[i]);\n\t\t}\n\t}\n\thiLevel = dir;\n\tlastArabic = false;\n\thasUBAT_AL = false;\n\thasUBAT_B = false;\n\thasUBAT_S = false;\n\tfor (ix = 0; ix < len; ix++){\n\t\tprevState = newState;\n\t\tclasses[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);\n\t\tnewState = impTab[prevState][newClass];\n\t\taction = newState & 0xF0;\n\t\tnewState &= 0x0F;\n\t\tlevels[ix] = newLevel = impTab[newState][5];\n\t\tif (action > 0){\n\t\t\tif (action == 0x10){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = 1;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t} else {\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tcond = impTab[newState][6];\n\t\tif (cond){\n\t\t\tif(condPos == -1){\n\t\t\t\tcondPos = ix;\n\t\t\t}\n\t\t}else{\n\t\t\tif (condPos > -1){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = newLevel;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tif (charTypes[ix] == B){\n\t\t\tlevels[ix] = 0;\n\t\t}\n\t\thiLevel |= newLevel;\n\t}\n\tif (hasUBAT_S){\n\t\tfor(i = 0; i < len; i++){\n\t\t\tif(charTypes[i] == S){\n\t\t\t\tlevels[i] = dir;\n\t\t\t\tfor(var j = i - 1; j >= 0; j--){\n\t\t\t\t\tif(charTypes[j] == WS){\n\t\t\t\t\t\tlevels[j] = dir;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction _invertLevel(lev, levels, _array) {\n\tif (hiLevel < lev){\n\t\treturn;\n\t}\n\tif (lev == 1 && dir == RTL && !hasUBAT_B){\n\t\t_array.reverse();\n\t\treturn;\n\t}\n\tvar len = _array.length, start = 0, end, lo, hi, tmp;\n\twhile(start < len){\n\t\tif (levels[start] >= lev){\n\t\t\tend = start + 1;\n\t\twhile(end < len && levels[end] >= lev){\n\t\t\tend++;\n\t\t}\n\t\tfor(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){\n\t\t\ttmp = _array[lo];\n\t\t\t_array[lo] = _array[hi];\n\t\t\t_array[hi] = tmp;\n\t\t}\n\t\tstart = end;\n\t}\n\tstart++;\n\t}\n}\n\nfunction _getCharClass(chars, types, classes, ix) {\t\t\t\n\tvar cType = types[ix], wType, nType, len, i;\n\tswitch(cType){\n\t\tcase L:\n\t\tcase R:\n\t\t\tlastArabic = false;\n\t\tcase ON:\n\t\tcase AN:\n\t\t\treturn cType;\n\t\tcase EN:\n\t\t\treturn lastArabic ? AN : EN;\n\t\tcase AL:\n\t\t\tlastArabic = true;\n\t\t\thasUBAT_AL = true;\n\t\t\treturn R;\n\t\tcase WS:\n\t\t\treturn ON;\n\t\tcase CS:\n\t\t\tif (ix < 1 || (ix + 1) >= types.length ||\n\t\t\t\t((wType = classes[ix - 1]) != EN && wType != AN) ||\n\t\t\t\t((nType = types[ix + 1]) != EN && nType != AN)){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\tif (lastArabic){nType = AN;}\n\t\t\treturn nType == wType ? nType : ON;\n\t\tcase ES:\n\t\t\twType = ix > 0 ? classes[ix - 1] : B;\n\t\t\tif (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase ET:\n\t\t\tif (ix > 0 && classes[ix - 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\tif (lastArabic){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\ti = ix + 1;\n\t\t\tlen = types.length;\n\t\t\twhile (i < len && types[i] == ET){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len && types[i] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase NSM:\n\t\t\tlen = types.length;\n\t\t\ti = ix + 1;\n\t\t\twhile (i < len && types[i] == NSM){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len){\n\t\t\t\tvar c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;\n\t\t\t\t\n\t\t\t\twType = types[i];\n\t\t\t\tif (rtlCandidate && (wType == R || wType == AL)){\n\t\t\t\t\treturn R;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ix < 1 || (wType = types[ix - 1]) == B){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\treturn classes[ix - 1];\n\t\tcase B:\n\t\t\tlastArabic = false;\n\t\t\thasUBAT_B = true;\n\t\t\treturn dir;\n\t\tcase S:\n\t\t\thasUBAT_S = true;\n\t\t\treturn ON;\n\t\tcase LRE:\n\t\tcase RLE:\n\t\tcase LRO:\n\t\tcase RLO:\n\t\tcase PDF:\n\t\t\tlastArabic = false;\n\t\tcase BN:\n\t\t\treturn ON;\n\t}\n}\n\nfunction _getCharacterType( ch ) {\t\t\n\tvar uc = ch.charCodeAt(0), hi = uc >> 8;\n\t\n\tif (hi == 0) {\t\t\n\t\treturn ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);\n\t} else if (hi == 5) {\n\t\treturn (/[\\u0591-\\u05f4]/.test(ch) ? R : L);\n\t} else if (hi == 6) {\n\t\tif (/[\\u0610-\\u061a\\u064b-\\u065f\\u06d6-\\u06e4\\u06e7-\\u06ed]/.test(ch))\n\t\t\treturn NSM;\n\t\telse if (/[\\u0660-\\u0669\\u066b-\\u066c]/.test(ch))\n\t\t\treturn AN;\n\t\telse if (uc == 0x066A)\n\t\t\treturn ET;\n\t\telse if (/[\\u06f0-\\u06f9]/.test(ch))\n\t\t\treturn EN;\t\t\t\n\t\telse\n\t\t\treturn AL;\n\t} else if (hi == 0x20 && uc <= 0x205F) {\n\t\treturn UnicodeTBL20[uc & 0xFF];\n\t} else if (hi == 0xFE) {\n\t\treturn (uc >= 0xFE70 ? AL : ON);\n\t}\t\t\n\treturn ON;\t\n}\n\nfunction _isArabicDiacritics( ch ) {\n\treturn (ch >= '\\u064b' && ch <= '\\u0655');\n}\nexports.L = L;\nexports.R = R;\nexports.EN = EN;\nexports.ON_R = 3;\nexports.AN = 4;\nexports.R_H = 5;\nexports.B = 6;\nexports.RLE = 7;\n\nexports.DOT = \"\\xB7\";\nexports.doBidiReorder = function(text, textCharTypes, isRtl) {\n\tif (text.length < 2)\n\t\treturn {};\n\t\t\n\tvar chars = text.split(\"\"), logicalFromVisual = new Array(chars.length),\n\t\tbidiLevels = new Array(chars.length), levels = []; \n\n\tdir = isRtl ? RTL : LTR;\n\n\t_computeLevels(chars, levels, chars.length, textCharTypes);\n\n\tfor (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);\n\n\t_invertLevel(2, levels, logicalFromVisual);\n\t_invertLevel(1, levels, logicalFromVisual);\n\n\tfor (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width\n\t\tif (textCharTypes[i] === AN) {\n\t\t\tlevels[i] = exports.AN;\n\t\t} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) \n\t\t\t|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {\n\t\t\tlevels[i] = exports.ON_R;\n\t\t} else if ((i > 0 && chars[i - 1] === '\\u0644') && /\\u0622|\\u0623|\\u0625|\\u0627/.test(chars[i])) {\n\t\t\tlevels[i - 1] = levels[i] = exports.R_H;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (chars[chars.length - 1] === exports.DOT)\n\t\tlevels[chars.length - 1] = exports.B;\n\t\t\t\t\n\tif (chars[0] === '\\u202B')\n\t\tlevels[0] = exports.RLE;\n\t\t\t\t\n\tfor (var i = 0; i < logicalFromVisual.length; i++) {\n\t\tbidiLevels[i] = levels[logicalFromVisual[i]];\n\t}\n\n\treturn {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};\n};\nexports.hasBidiCharacters = function(text, textCharTypes){\n\tvar ret = false;\n\tfor (var i = 0; i < text.length; i++){\n\t\ttextCharTypes[i] = _getCharacterType(text.charAt(i));\n\t\tif (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))\n\t\t\tret = true;\n\t}\n\treturn ret;\n};\t\nexports.getVisualFromLogicalIdx = function(logIdx, rowMap) {\n\tfor (var i = 0; i < rowMap.logicalFromVisual.length; i++) {\n\t\tif (rowMap.logicalFromVisual[i] == logIdx)\n\t\t\treturn i;\n\t}\n\treturn 0;\n};\n\n});\n\nace.define(\"ace/bidihandler\",[\"require\",\"exports\",\"module\",\"ace/lib/bidiutil\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar bidiUtil = require(\"./lib/bidiutil\");\nvar lang = require(\"./lib/lang\");\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\nvar BidiHandler = function(session) {\n    this.session = session;\n    this.bidiMap = {};\n    this.currentRow = null;\n    this.bidiUtil = bidiUtil;\n    this.charWidths = [];\n    this.EOL = \"\\xAC\";\n    this.showInvisibles = true;\n    this.isRtlDir = false;\n    this.$isRtl = false;\n    this.line = \"\";\n    this.wrapIndent = 0;\n    this.EOF = \"\\xB6\";\n    this.RLE = \"\\u202B\";\n    this.contentWidth = 0;\n    this.fontMetrics = null;\n    this.rtlLineOffset = 0;\n    this.wrapOffset = 0;\n    this.isMoveLeftOperation = false;\n    this.seenBidi = bidiRE.test(session.getValue());\n};\n\n(function() {\n    this.isBidiRow = function(screenRow, docRow, splitIndex) {\n        if (!this.seenBidi)\n            return false;\n        if (screenRow !== this.currentRow) {\n            this.currentRow = screenRow;\n            this.updateRowLine(docRow, splitIndex);\n            this.updateBidiMap();\n        }\n        return this.bidiMap.bidiLevels;\n    };\n\n    this.onChange = function(delta) {\n        if (!this.seenBidi) {\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\n                this.seenBidi = true;\n                this.currentRow = null;\n            }\n        } \n        else {\n            this.currentRow = null;\n        }\n    };\n\n    this.getDocumentRow = function() {\n        var docRow = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            if (index >= 0)\n                docRow = this.session.$docRowCache[index];\n        }\n\n        return docRow;\n    };\n\n    this.getSplitIndex = function() {\n        var splitIndex = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            while (this.currentRow - splitIndex > 0) {\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\n                if (currentIndex !== prevIndex)\n                    break;\n\n                prevIndex = currentIndex;\n                splitIndex++;\n            }\n        } else {\n            splitIndex = this.currentRow;\n        }\n\n        return splitIndex;\n    };\n\n    this.updateRowLine = function(docRow, splitIndex) {\n        if (docRow === undefined)\n            docRow = this.getDocumentRow();\n            \n        var isLastRow = (docRow === this.session.getLength() - 1),\n            endOfLine = isLastRow ? this.EOF : this.EOL;\n\n        this.wrapIndent = 0;\n        this.line = this.session.getLine(docRow);\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\n        if (this.session.$useWrapMode) {\n            var splits = this.session.$wrapData[docRow];\n            if (splits) {\n                if (splitIndex === undefined)\n                    splitIndex = this.getSplitIndex();\n\n                if(splitIndex > 0 && splits.length) {\n                    this.wrapIndent = splits.indent;\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\n                    this.line = (splitIndex < splits.length) ?\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\n                            this.line.substring(splits[splits.length - 1]);\n                } else {\n                    this.line = this.line.substring(0, splits[splitIndex]);\n                }\n            }\n            if (splitIndex == splits.length)\n                this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\n        } else {\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\n        }\n        var session = this.session, shift = 0, size;\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function(ch, i){\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\n                shift += size - 1;\n                return lang.stringRepeat(bidiUtil.DOT, size);\n            }\n            return ch;\n        });\n\n        if (this.isRtlDir) {\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\n        }\n    };\n    \n    this.updateBidiMap = function() {\n        var textCharTypes = [];\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\n             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\n        } else {\n            this.bidiMap = {};\n        }\n    };\n    this.markAsDirty = function() {\n        this.currentRow = null;\n    };\n    this.updateCharacterWidths = function(fontMetrics) {\n        if (this.characterWidth === fontMetrics.$characterSize.width)\n            return;\n\n        this.fontMetrics = fontMetrics;\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\n\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\n\n        this.currentRow = null;\n    };\n\n    this.setShowInvisibles = function(showInvisibles) {\n        this.showInvisibles = showInvisibles;\n        this.currentRow = null;\n    };\n\n    this.setEolChar = function(eolChar) {\n        this.EOL = eolChar; \n    };\n\n    this.setContentWidth = function(width) {\n        this.contentWidth = width;\n    };\n\n    this.isRtlLine = function(row) {\n        if (this.$isRtl) return true;\n        if (row != undefined)\n            return (this.session.getLine(row).charAt(0) == this.RLE);\n        else\n            return this.isRtlDir; \n    };\n\n    this.setRtlDirection = function(editor, isRtlDir) {\n        var cursor = editor.getCursorPosition(); \n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\n                editor.session.doc.removeInLine(row, 0, 1);\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\n                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);\n        }\n    };\n    this.getPosLeft = function(col) {\n        col -= this.wrapIndent;\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),\n            levels = this.bidiMap.bidiLevels, left = 0;\n\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\n            visualIdx++;\n            \n        for (var i = 0; i < visualIdx; i++) {\n            left += this.charWidths[levels[i]];\n        }\n\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\n            left += this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        if (this.isRtlDir)\n            left += this.rtlLineOffset;\n\n        return left;\n    };\n    this.getSelections = function(startCol, endCol) {\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,\n            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,\n                isSelected = false, isSelectedPrev = false, selectionStart = 0;\n            \n        if (this.wrapIndent)\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\n            logIdx = map.logicalFromVisual[visIdx];\n            level = levels[visIdx];\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\n            if (isSelected && !isSelectedPrev) {\n                selectionStart = offset;\n            } else if (!isSelected && isSelectedPrev) {\n                selections.push({left: selectionStart, width: offset - selectionStart});\n            }\n            offset += this.charWidths[level];\n            isSelectedPrev = isSelected;\n        }\n\n        if (isSelected && (visIdx === levels.length)) {\n            selections.push({left: selectionStart, width: offset - selectionStart});\n        }\n\n        if(this.isRtlDir) {\n            for (var i = 0; i < selections.length; i++) {\n                selections[i].left += this.rtlLineOffset;\n            }\n        }\n        return selections;\n    };\n    this.offsetToCol = function(posX) {\n        if(this.isRtlDir)\n            posX -= this.rtlLineOffset;\n\n        var logicalIdx = 0, posX = Math.max(posX, 0),\n            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,\n                charWidth = this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n    \n        while(posX > offset + charWidth/2) {\n            offset += charWidth;\n            if(visualIdx === levels.length - 1) {\n                charWidth = 0;\n                break;\n            }\n            charWidth = this.charWidths[levels[++visualIdx]];\n        }\n    \n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){\n            if(posX < offset)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n\n        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\n                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);\n\n        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\n                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\n        } else {\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n\n        if (logicalIdx === 0 && this.isRtlDir)\n            logicalIdx++;\n\n        return (logicalIdx + this.wrapIndent);\n    };\n\n}).call(BidiHandler.prototype);\n\nexports.BidiHandler = BidiHandler;\n});\n\nace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Selection = function(session) {\n    this.session = session;\n    this.doc = session.getDocument();\n\n    this.clearSelection();\n    this.cursor = this.lead = this.doc.createAnchor(0, 0);\n    this.anchor = this.doc.createAnchor(0, 0);\n    this.$silent = false;\n\n    var self = this;\n    this.cursor.on(\"change\", function(e) {\n        self.$cursorChanged = true;\n        if (!self.$silent)\n            self._emit(\"changeCursor\");\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n            self.$desiredColumn = null;\n    });\n\n    this.anchor.on(\"change\", function() {\n        self.$anchorChanged = true;\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n    });\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.isEmpty = function() {\n        return this.$isEmpty || (\n            this.anchor.row == this.lead.row &&\n            this.anchor.column == this.lead.column\n        );\n    };\n    this.isMultiLine = function() {\n        return !this.$isEmpty && this.anchor.row != this.cursor.row;\n    };\n    this.getCursor = function() {\n        return this.lead.getPosition();\n    };\n    this.setSelectionAnchor = function(row, column) {\n        this.$isEmpty = false;\n        this.anchor.setPosition(row, column);\n    };\n    this.getAnchor = \n    this.getSelectionAnchor = function() {\n        if (this.$isEmpty)\n            return this.getSelectionLead();\n        \n        return this.anchor.getPosition();\n    };\n    this.getSelectionLead = function() {\n        return this.lead.getPosition();\n    };\n    this.isBackwards = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n    };\n    this.getRange = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n\n        if (this.$isEmpty)\n            return Range.fromPoints(lead, lead);\n\n        return this.isBackwards()\n            ? Range.fromPoints(lead, anchor)\n            : Range.fromPoints(anchor, lead);\n    };\n    this.clearSelection = function() {\n        if (!this.$isEmpty) {\n            this.$isEmpty = true;\n            this._emit(\"changeSelection\");\n        }\n    };\n    this.selectAll = function() {\n        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);\n    };\n    this.setRange =\n    this.setSelectionRange = function(range, reverse) {\n        var start = reverse ? range.end : range.start;\n        var end = reverse ? range.start : range.end;\n        this.$setSelection(start.row, start.column, end.row, end.column);\n    };\n\n    this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {\n        var wasEmpty = this.$isEmpty;\n        var wasMultiselect = this.inMultiSelectMode;\n        this.$silent = true;\n        this.$cursorChanged = this.$anchorChanged = false;\n        this.anchor.setPosition(anchorRow, anchorColumn);\n        this.cursor.setPosition(cursorRow, cursorColumn);\n        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);\n        this.$silent = false;\n        if (this.$cursorChanged)\n            this._emit(\"changeCursor\");\n        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)\n            this._emit(\"changeSelection\");\n    };\n\n    this.$moveSelection = function(mover) {\n        var lead = this.lead;\n        if (this.$isEmpty)\n            this.setSelectionAnchor(lead.row, lead.column);\n\n        mover.call(this);\n    };\n    this.selectTo = function(row, column) {\n        this.$moveSelection(function() {\n            this.moveCursorTo(row, column);\n        });\n    };\n    this.selectToPosition = function(pos) {\n        this.$moveSelection(function() {\n            this.moveCursorToPosition(pos);\n        });\n    };\n    this.moveTo = function(row, column) {\n        this.clearSelection();\n        this.moveCursorTo(row, column);\n    };\n    this.moveToPosition = function(pos) {\n        this.clearSelection();\n        this.moveCursorToPosition(pos);\n    };\n    this.selectUp = function() {\n        this.$moveSelection(this.moveCursorUp);\n    };\n    this.selectDown = function() {\n        this.$moveSelection(this.moveCursorDown);\n    };\n    this.selectRight = function() {\n        this.$moveSelection(this.moveCursorRight);\n    };\n    this.selectLeft = function() {\n        this.$moveSelection(this.moveCursorLeft);\n    };\n    this.selectLineStart = function() {\n        this.$moveSelection(this.moveCursorLineStart);\n    };\n    this.selectLineEnd = function() {\n        this.$moveSelection(this.moveCursorLineEnd);\n    };\n    this.selectFileEnd = function() {\n        this.$moveSelection(this.moveCursorFileEnd);\n    };\n    this.selectFileStart = function() {\n        this.$moveSelection(this.moveCursorFileStart);\n    };\n    this.selectWordRight = function() {\n        this.$moveSelection(this.moveCursorWordRight);\n    };\n    this.selectWordLeft = function() {\n        this.$moveSelection(this.moveCursorWordLeft);\n    };\n    this.getWordRange = function(row, column) {\n        if (typeof column == \"undefined\") {\n            var cursor = row || this.lead;\n            row = cursor.row;\n            column = cursor.column;\n        }\n        return this.session.getWordRange(row, column);\n    };\n    this.selectWord = function() {\n        this.setSelectionRange(this.getWordRange());\n    };\n    this.selectAWord = function() {\n        var cursor = this.getCursor();\n        var range = this.session.getAWordRange(cursor.row, cursor.column);\n        this.setSelectionRange(range);\n    };\n\n    this.getLineRange = function(row, excludeLastChar) {\n        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n        var rowEnd;\n\n        var foldLine = this.session.getFoldLine(rowStart);\n        if (foldLine) {\n            rowStart = foldLine.start.row;\n            rowEnd = foldLine.end.row;\n        } else {\n            rowEnd = rowStart;\n        }\n        if (excludeLastChar === true)\n            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n        else\n            return new Range(rowStart, 0, rowEnd + 1, 0);\n    };\n    this.selectLine = function() {\n        this.setSelectionRange(this.getLineRange());\n    };\n    this.moveCursorUp = function() {\n        this.moveCursorBy(-1, 0);\n    };\n    this.moveCursorDown = function() {\n        this.moveCursorBy(1, 0);\n    };\n    this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {\n        var start = cursor.column;\n        var end = cursor.column + tabSize;\n\n        if (direction < 0) {\n            start = cursor.column - tabSize;\n            end = cursor.column;\n        }\n        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(\" \").length-1 == tabSize;\n    };\n    this.moveCursorLeft = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n        } else if (cursor.column === 0) {\n            if (cursor.row > 0) {\n                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, -tabSize);\n            } else {\n                this.moveCursorBy(0, -1);\n            }\n        }\n    };\n    this.moveCursorRight = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n        }\n        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n            if (this.lead.row < this.doc.getLength() - 1) {\n                this.moveCursorTo(this.lead.row + 1, 0);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            var cursor = this.lead;\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, tabSize);\n            } else {\n                this.moveCursorBy(0, 1);\n            }\n        }\n    };\n    this.moveCursorLineStart = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var screenRow = this.session.documentToScreenRow(row, column);\n        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n        var beforeCursor = this.session.getDisplayLine(\n            row, null, firstColumnPosition.row,\n            firstColumnPosition.column\n        );\n\n        var leadingSpace = beforeCursor.match(/^\\s*/);\n        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n            firstColumnPosition.column += leadingSpace[0].length;\n        this.moveCursorToPosition(firstColumnPosition);\n    };\n    this.moveCursorLineEnd = function() {\n        var lead = this.lead;\n        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n        if (this.lead.column == lineEnd.column) {\n            var line = this.session.getLine(lineEnd.row);\n            if (lineEnd.column == line.length) {\n                var textEnd = line.search(/\\s+$/);\n                if (textEnd > 0)\n                    lineEnd.column = textEnd;\n            }\n        }\n\n        this.moveCursorTo(lineEnd.row, lineEnd.column);\n    };\n    this.moveCursorFileEnd = function() {\n        var row = this.doc.getLength() - 1;\n        var column = this.doc.getLine(row).length;\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorFileStart = function() {\n        this.moveCursorTo(0, 0);\n    };\n    this.moveCursorLongWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n            return;\n        }\n        if (this.session.nonTokenRe.exec(rightOfCursor)) {\n            column += this.session.nonTokenRe.lastIndex;\n            this.session.nonTokenRe.lastIndex = 0;\n            rightOfCursor = line.substring(column);\n        }\n        if (column >= line.length) {\n            this.moveCursorTo(row, line.length);\n            this.moveCursorRight();\n            if (row < this.doc.getLength() - 1)\n                this.moveCursorWordRight();\n            return;\n        }\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            column += this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorLongWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n            return;\n        }\n\n        var str = this.session.getFoldStringAt(row, column, -1);\n        if (str == null) {\n            str = this.doc.getLine(row).substring(0, column);\n        }\n\n        var leftOfCursor = lang.stringReverse(str);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        if (this.session.nonTokenRe.exec(leftOfCursor)) {\n            column -= this.session.nonTokenRe.lastIndex;\n            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n            this.session.nonTokenRe.lastIndex = 0;\n        }\n        if (column <= 0) {\n            this.moveCursorTo(row, 0);\n            this.moveCursorLeft();\n            if (row > 0)\n                this.moveCursorWordLeft();\n            return;\n        }\n        if (this.session.tokenRe.exec(leftOfCursor)) {\n            column -= this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n\n    this.$shortWordEndIndex = function(rightOfCursor) {\n        var index = 0, ch;\n        var whitespaceRe = /\\s/;\n        var tokenRe = this.session.tokenRe;\n\n        tokenRe.lastIndex = 0;\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            index = this.session.tokenRe.lastIndex;\n        } else {\n            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                index ++;\n\n            if (index < 1) {\n                tokenRe.lastIndex = 0;\n                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n                    tokenRe.lastIndex = 0;\n                    index ++;\n                    if (whitespaceRe.test(ch)) {\n                        if (index > 2) {\n                            index--;\n                            break;\n                        } else {\n                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                                index ++;\n                            if (index > 2)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        tokenRe.lastIndex = 0;\n\n        return index;\n    };\n\n    this.moveCursorShortWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold)\n            return this.moveCursorTo(fold.end.row, fold.end.column);\n\n        if (column == line.length) {\n            var l = this.doc.getLength();\n            do {\n                row++;\n                rightOfCursor = this.doc.getLine(row);\n            } while (row < l && /^\\s*$/.test(rightOfCursor));\n\n            if (!/^\\s+/.test(rightOfCursor))\n                rightOfCursor = \"\";\n            column = 0;\n        }\n\n        var index = this.$shortWordEndIndex(rightOfCursor);\n\n        this.moveCursorTo(row, column + index);\n    };\n\n    this.moveCursorShortWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1))\n            return this.moveCursorTo(fold.start.row, fold.start.column);\n\n        var line = this.session.getLine(row).substring(0, column);\n        if (column === 0) {\n            do {\n                row--;\n                line = this.doc.getLine(row);\n            } while (row > 0 && /^\\s*$/.test(line));\n\n            column = line.length;\n            if (!/\\s+$/.test(line))\n                line = \"\";\n        }\n\n        var leftOfCursor = lang.stringReverse(line);\n        var index = this.$shortWordEndIndex(leftOfCursor);\n\n        return this.moveCursorTo(row, column - index);\n    };\n\n    this.moveCursorWordRight = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordRight();\n        else\n            this.moveCursorShortWordRight();\n    };\n\n    this.moveCursorWordLeft = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordLeft();\n        else\n            this.moveCursorShortWordLeft();\n    };\n    this.moveCursorBy = function(rows, chars) {\n        var screenPos = this.session.documentToScreenPosition(\n            this.lead.row,\n            this.lead.column\n        );\n\n        var offsetX;\n\n        if (chars === 0) {\n            if (rows !== 0) {\n                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {\n                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);\n                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);\n                } else {\n                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];\n                }\n            }\n\n            if (this.$desiredColumn)\n                screenPos.column = this.$desiredColumn;\n            else\n                this.$desiredColumn = screenPos.column;\n        }\n\n        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);\n        \n        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {\n                if (docPos.row > 0 || rows > 0)\n                    docPos.row++;\n            }\n        }\n        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n    };\n    this.moveCursorToPosition = function(position) {\n        this.moveCursorTo(position.row, position.column);\n    };\n    this.moveCursorTo = function(row, column, keepDesiredColumn) {\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            row = fold.start.row;\n            column = fold.start.column;\n        }\n\n        this.$keepDesiredColumnOnChange = true;\n        var line = this.session.getLine(row);\n        if (/[\\uDC00-\\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {\n            if (this.lead.row == row && this.lead.column == column + 1)\n                column = column - 1;\n            else\n                column = column + 1;\n        }\n        this.lead.setPosition(row, column);\n        this.$keepDesiredColumnOnChange = false;\n\n        if (!keepDesiredColumn)\n            this.$desiredColumn = null;\n    };\n    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {\n        var pos = this.session.screenToDocumentPosition(row, column);\n        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n    };\n    this.detach = function() {\n        this.lead.detach();\n        this.anchor.detach();\n        this.session = this.doc = null;\n    };\n\n    this.fromOrientedRange = function(range) {\n        this.setSelectionRange(range, range.cursor == range.start);\n        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n    };\n\n    this.toOrientedRange = function(range) {\n        var r = this.getRange();\n        if (range) {\n            range.start.column = r.start.column;\n            range.start.row = r.start.row;\n            range.end.column = r.end.column;\n            range.end.row = r.end.row;\n        } else {\n            range = r;\n        }\n\n        range.cursor = this.isBackwards() ? range.start : range.end;\n        range.desiredColumn = this.$desiredColumn;\n        return range;\n    };\n    this.getRangeOfMovements = function(func) {\n        var start = this.getCursor();\n        try {\n            func(this);\n            var end = this.getCursor();\n            return Range.fromPoints(start, end);\n        } catch(e) {\n            return Range.fromPoints(start, start);\n        } finally {\n            this.moveCursorToPosition(start);\n        }\n    };\n\n    this.toJSON = function() {\n        if (this.rangeCount) {\n            var data = this.ranges.map(function(r) {\n                var r1 = r.clone();\n                r1.isBackwards = r.cursor == r.start;\n                return r1;\n            });\n        } else {\n            var data = this.getRange();\n            data.isBackwards = this.isBackwards();\n        }\n        return data;\n    };\n\n    this.fromJSON = function(data) {\n        if (data.start == undefined) {\n            if (this.rangeList && data.length > 1) {\n                this.toSingleRange(data[0]);\n                for (var i = data.length; i--; ) {\n                    var r = Range.fromPoints(data[i].start, data[i].end);\n                    if (data[i].isBackwards)\n                        r.cursor = r.start;\n                    this.addRange(r, true);\n                }\n                return;\n            } else {\n                data = data[0];\n            }\n        }\n        if (this.rangeList)\n            this.toSingleRange(data);\n        this.setSelectionRange(data, data.isBackwards);\n    };\n\n    this.isEqual = function(data) {\n        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n            return false;\n        if (!data.length || !this.ranges)\n            return this.getRange().isEqual(data);\n\n        for (var i = this.ranges.length; i--; ) {\n            if (!this.ranges[i].isEqual(data[i]))\n                return false;\n        }\n        return true;\n    };\n\n}).call(Selection.prototype);\n\nexports.Selection = Selection;\n});\n\nace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar config = require(\"./config\");\nvar MAX_TOKEN_COUNT = 2000;\nvar Tokenizer = function(rules) {\n    this.states = rules;\n\n    this.regExps = {};\n    this.matchMappings = {};\n    for (var key in this.states) {\n        var state = this.states[key];\n        var ruleRegExps = [];\n        var matchTotal = 0;\n        var mapping = this.matchMappings[key] = {defaultToken: \"text\"};\n        var flag = \"g\";\n\n        var splitterRurles = [];\n        for (var i = 0; i < state.length; i++) {\n            var rule = state[i];\n            if (rule.defaultToken)\n                mapping.defaultToken = rule.defaultToken;\n            if (rule.caseInsensitive)\n                flag = \"gi\";\n            if (rule.regex == null)\n                continue;\n\n            if (rule.regex instanceof RegExp)\n                rule.regex = rule.regex.toString().slice(1, -1);\n            var adjustedregex = rule.regex;\n            var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n            if (Array.isArray(rule.token)) {\n                if (rule.token.length == 1 || matchcount == 1) {\n                    rule.token = rule.token[0];\n                } else if (matchcount - 1 != rule.token.length) {\n                    this.reportError(\"number of classes and regexp groups doesn't match\", { \n                        rule: rule,\n                        groupCount: matchcount - 1\n                    });\n                    rule.token = rule.token[0];\n                } else {\n                    rule.tokenArray = rule.token;\n                    rule.token = null;\n                    rule.onMatch = this.$arrayTokens;\n                }\n            } else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                if (matchcount > 1)\n                    rule.onMatch = this.$applyToken;\n                else\n                    rule.onMatch = rule.token;\n            }\n\n            if (matchcount > 1) {\n                if (/\\\\\\d/.test(rule.regex)) {\n                    adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function(match, digit) {\n                        return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                    });\n                } else {\n                    matchcount = 1;\n                    adjustedregex = this.removeCapturingGroups(rule.regex);\n                }\n                if (!rule.splitRegex && typeof rule.token != \"string\")\n                    splitterRurles.push(rule); // flag will be known only at the very end\n            }\n\n            mapping[matchTotal] = i;\n            matchTotal += matchcount;\n\n            ruleRegExps.push(adjustedregex);\n            if (!rule.onMatch)\n                rule.onMatch = null;\n        }\n        \n        if (!ruleRegExps.length) {\n            mapping[0] = 0;\n            ruleRegExps.push(\"$\");\n        }\n        \n        splitterRurles.forEach(function(rule) {\n            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n        }, this);\n\n        this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n    }\n};\n\n(function() {\n    this.$setMaxTokenCount = function(m) {\n        MAX_TOKEN_COUNT = m | 0;\n    };\n    \n    this.$applyToken = function(str) {\n        var values = this.splitRegex.exec(str).slice(1);\n        var types = this.token.apply(this, values);\n        if (typeof types === \"string\")\n            return [{type: types, value: str}];\n\n        var tokens = [];\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i]\n                };\n        }\n        return tokens;\n    };\n\n    this.$arrayTokens = function(str) {\n        if (!str)\n            return [];\n        var values = this.splitRegex.exec(str);\n        if (!values)\n            return \"text\";\n        var tokens = [];\n        var types = this.tokenArray;\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i + 1])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i + 1]\n                };\n        }\n        return tokens;\n    };\n\n    this.removeCapturingGroups = function(src) {\n        var r = src.replace(\n            /\\\\.|\\[(?:\\\\.|[^\\\\\\]])*|\\(\\?[:=!]|(\\()/g,\n            function(x, y) {return y ? \"(?:\" : x;}\n        );\n        return r;\n    };\n\n    this.createSplitterRegexp = function(src, flag) {\n        if (src.indexOf(\"(?=\") != -1) {\n            var stack = 0;\n            var inChClass = false;\n            var lastCapture = {};\n            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function(\n                m, esc, parenOpen, parenClose, square, index\n            ) {\n                if (inChClass) {\n                    inChClass = square != \"]\";\n                } else if (square) {\n                    inChClass = true;\n                } else if (parenClose) {\n                    if (stack == lastCapture.stack) {\n                        lastCapture.end = index+1;\n                        lastCapture.stack = -1;\n                    }\n                    stack--;\n                } else if (parenOpen) {\n                    stack++;\n                    if (parenOpen.length != 1) {\n                        lastCapture.stack = stack;\n                        lastCapture.start = index;\n                    }\n                }\n                return m;\n            });\n\n            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n        }\n        if (src.charAt(0) != \"^\") src = \"^\" + src;\n        if (src.charAt(src.length - 1) != \"$\") src += \"$\";\n        \n        return new RegExp(src, (flag||\"\").replace(\"g\", \"\"));\n    };\n    this.getLineTokens = function(line, startState) {\n        if (startState && typeof startState != \"string\") {\n            var stack = startState.slice(0);\n            startState = stack[0];\n            if (startState === \"#tmp\") {\n                stack.shift();\n                startState = stack.shift();\n            }\n        } else\n            var stack = [];\n\n        var currentState = startState || \"start\";\n        var state = this.states[currentState];\n        if (!state) {\n            currentState = \"start\";\n            state = this.states[currentState];\n        }\n        var mapping = this.matchMappings[currentState];\n        var re = this.regExps[currentState];\n        re.lastIndex = 0;\n\n        var match, tokens = [];\n        var lastIndex = 0;\n        var matchAttempts = 0;\n\n        var token = {type: null, value: \"\"};\n\n        while (match = re.exec(line)) {\n            var type = mapping.defaultToken;\n            var rule = null;\n            var value = match[0];\n            var index = re.lastIndex;\n\n            if (index - value.length > lastIndex) {\n                var skipped = line.substring(lastIndex, index - value.length);\n                if (token.type == type) {\n                    token.value += skipped;\n                } else {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: type, value: skipped};\n                }\n            }\n\n            for (var i = 0; i < match.length-2; i++) {\n                if (match[i + 1] === undefined)\n                    continue;\n\n                rule = state[mapping[i]];\n\n                if (rule.onMatch)\n                    type = rule.onMatch(value, currentState, stack, line);\n                else\n                    type = rule.token;\n\n                if (rule.next) {\n                    if (typeof rule.next == \"string\") {\n                        currentState = rule.next;\n                    } else {\n                        currentState = rule.next(currentState, stack);\n                    }\n                    \n                    state = this.states[currentState];\n                    if (!state) {\n                        this.reportError(\"state doesn't exist\", currentState);\n                        currentState = \"start\";\n                        state = this.states[currentState];\n                    }\n                    mapping = this.matchMappings[currentState];\n                    lastIndex = index;\n                    re = this.regExps[currentState];\n                    re.lastIndex = index;\n                }\n                if (rule.consumeLineEnd)\n                    lastIndex = index;\n                break;\n            }\n\n            if (value) {\n                if (typeof type === \"string\") {\n                    if ((!rule || rule.merge !== false) && token.type === type) {\n                        token.value += value;\n                    } else {\n                        if (token.type)\n                            tokens.push(token);\n                        token = {type: type, value: value};\n                    }\n                } else if (type) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: null, value: \"\"};\n                    for (var i = 0; i < type.length; i++)\n                        tokens.push(type[i]);\n                }\n            }\n\n            if (lastIndex == line.length)\n                break;\n\n            lastIndex = index;\n\n            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n                if (matchAttempts > 2 * line.length) {\n                    this.reportError(\"infinite loop with in ace tokenizer\", {\n                        startState: startState,\n                        line: line\n                    });\n                }\n                while (lastIndex < line.length) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {\n                        value: line.substring(lastIndex, lastIndex += 2000),\n                        type: \"overflow\"\n                    };\n                }\n                currentState = \"start\";\n                stack = [];\n                break;\n            }\n        }\n\n        if (token.type)\n            tokens.push(token);\n        \n        if (stack.length > 1) {\n            if (stack[0] !== currentState)\n                stack.unshift(\"#tmp\", currentState);\n        }\n        return {\n            tokens : tokens,\n            state : stack.length ? stack : currentState\n        };\n    };\n    \n    this.reportError = config.reportError;\n    \n}).call(Tokenizer.prototype);\n\nexports.Tokenizer = Tokenizer;\n});\n\nace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\n\nvar TextHighlightRules = function() {\n\n    this.$rules = {\n        \"start\" : [{\n            token : \"empty_line\",\n            regex : '^$'\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n};\n\n(function() {\n\n    this.addRules = function(rules, prefix) {\n        if (!prefix) {\n            for (var key in rules)\n                this.$rules[key] = rules[key];\n            return;\n        }\n        for (var key in rules) {\n            var state = rules[key];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.next || rule.onMatch) {\n                    if (typeof rule.next == \"string\") {\n                        if (rule.next.indexOf(prefix) !== 0)\n                            rule.next = prefix + rule.next;\n                    }\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n                        rule.nextState = prefix + rule.nextState;\n                }\n            }\n            this.$rules[prefix + key] = state;\n        }\n    };\n\n    this.getRules = function() {\n        return this.$rules;\n    };\n\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n        var embedRules = typeof HighlightRules == \"function\"\n            ? new HighlightRules().getRules()\n            : HighlightRules;\n        if (states) {\n            for (var i = 0; i < states.length; i++)\n                states[i] = prefix + states[i];\n        } else {\n            states = [];\n            for (var key in embedRules)\n                states.push(prefix + key);\n        }\n\n        this.addRules(embedRules, prefix);\n\n        if (escapeRules) {\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n            for (var i = 0; i < states.length; i++)\n                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));\n        }\n\n        if (!this.$embeds)\n            this.$embeds = [];\n        this.$embeds.push(prefix);\n    };\n\n    this.getEmbeds = function() {\n        return this.$embeds;\n    };\n\n    var pushState = function(currentState, stack) {\n        if (currentState != \"start\" || stack.length)\n            stack.unshift(this.nextState, currentState);\n        return this.nextState;\n    };\n    var popState = function(currentState, stack) {\n        stack.shift();\n        return stack.shift() || \"start\";\n    };\n\n    this.normalizeRules = function() {\n        var id = 0;\n        var rules = this.$rules;\n        function processState(key) {\n            var state = rules[key];\n            state.processed = true;\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                var toInsert = null;\n                if (Array.isArray(rule)) {\n                    toInsert = rule;\n                    rule = {};\n                }\n                if (!rule.regex && rule.start) {\n                    rule.regex = rule.start;\n                    if (!rule.next)\n                        rule.next = [];\n                    rule.next.push({\n                        defaultToken: rule.token\n                    }, {\n                        token: rule.token + \".end\",\n                        regex: rule.end || rule.start,\n                        next: \"pop\"\n                    });\n                    rule.token = rule.token + \".start\";\n                    rule.push = true;\n                }\n                var next = rule.next || rule.push;\n                if (next && Array.isArray(next)) {\n                    var stateName = rule.stateName;\n                    if (!stateName)  {\n                        stateName = rule.token;\n                        if (typeof stateName != \"string\")\n                            stateName = stateName[0] || \"\";\n                        if (rules[stateName])\n                            stateName += id++;\n                    }\n                    rules[stateName] = next;\n                    rule.next = stateName;\n                    processState(stateName);\n                } else if (next == \"pop\") {\n                    rule.next = popState;\n                }\n\n                if (rule.push) {\n                    rule.nextState = rule.next || rule.push;\n                    rule.next = pushState;\n                    delete rule.push;\n                }\n\n                if (rule.rules) {\n                    for (var r in rule.rules) {\n                        if (rules[r]) {\n                            if (rules[r].push)\n                                rules[r].push.apply(rules[r], rule.rules[r]);\n                        } else {\n                            rules[r] = rule.rules[r];\n                        }\n                    }\n                }\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\n                if (includeName) {\n                    if (Array.isArray(includeName))\n                        toInsert = includeName.map(function(x) { return rules[x]; });\n                    else\n                        toInsert = rules[includeName];\n                }\n\n                if (toInsert) {\n                    var args = [i, 1].concat(toInsert);\n                    if (rule.noEscape)\n                        args = args.filter(function(x) {return !x.next;});\n                    state.splice.apply(state, args);\n                    i--;\n                }\n                \n                if (rule.keywordMap) {\n                    rule.token = this.createKeywordMapper(\n                        rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive\n                    );\n                    delete rule.defaultToken;\n                }\n            }\n        }\n        Object.keys(rules).forEach(processState, this);\n    };\n\n    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {\n        var keywords = Object.create(null);\n        Object.keys(map).forEach(function(className) {\n            var a = map[className];\n            if (ignoreCase)\n                a = a.toLowerCase();\n            var list = a.split(splitChar || \"|\");\n            for (var i = list.length; i--; )\n                keywords[list[i]] = className;\n        });\n        if (Object.getPrototypeOf(keywords)) {\n            keywords.__proto__ = null;\n        }\n        this.$keywordList = Object.keys(keywords);\n        map = null;\n        return ignoreCase\n            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }\n            : function(value) {return keywords[value] || defaultToken; };\n    };\n\n    this.getKeywords = function() {\n        return this.$keywords;\n    };\n\n}).call(TextHighlightRules.prototype);\n\nexports.TextHighlightRules = TextHighlightRules;\n});\n\nace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar Behaviour = function() {\n   this.$behaviours = {};\n};\n\n(function () {\n\n    this.add = function (name, action, callback) {\n        switch (undefined) {\n          case this.$behaviours:\n              this.$behaviours = {};\n          case this.$behaviours[name]:\n              this.$behaviours[name] = {};\n        }\n        this.$behaviours[name][action] = callback;\n    };\n    \n    this.addBehaviours = function (behaviours) {\n        for (var key in behaviours) {\n            for (var action in behaviours[key]) {\n                this.add(key, action, behaviours[key][action]);\n            }\n        }\n    };\n    \n    this.remove = function (name) {\n        if (this.$behaviours && this.$behaviours[name]) {\n            delete this.$behaviours[name];\n        }\n    };\n    \n    this.inherit = function (mode, filter) {\n        if (typeof mode === \"function\") {\n            var behaviours = new mode().getBehaviours(filter);\n        } else {\n            var behaviours = mode.getBehaviours(filter);\n        }\n        this.addBehaviours(behaviours);\n    };\n    \n    this.getBehaviours = function (filter) {\n        if (!filter) {\n            return this.$behaviours;\n        } else {\n            var ret = {};\n            for (var i = 0; i < filter.length; i++) {\n                if (this.$behaviours[filter[i]]) {\n                    ret[filter[i]] = this.$behaviours[filter[i]];\n                }\n            }\n            return ret;\n        }\n    };\n\n}).call(Behaviour.prototype);\n\nexports.Behaviour = Behaviour;\n});\n\nace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar TokenIterator = function(session, initialRow, initialColumn) {\n    this.$session = session;\n    this.$row = initialRow;\n    this.$rowTokens = session.getTokens(initialRow);\n\n    var token = session.getTokenAt(initialRow, initialColumn);\n    this.$tokenIndex = token ? token.index : -1;\n};\n\n(function() { \n    this.stepBackward = function() {\n        this.$tokenIndex -= 1;\n        \n        while (this.$tokenIndex < 0) {\n            this.$row -= 1;\n            if (this.$row < 0) {\n                this.$row = 0;\n                return null;\n            }\n                \n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = this.$rowTokens.length - 1;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };   \n    this.stepForward = function() {\n        this.$tokenIndex += 1;\n        var rowCount;\n        while (this.$tokenIndex >= this.$rowTokens.length) {\n            this.$row += 1;\n            if (!rowCount)\n                rowCount = this.$session.getLength();\n            if (this.$row >= rowCount) {\n                this.$row = rowCount - 1;\n                return null;\n            }\n\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = 0;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentToken = function () {\n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentTokenRow = function () {\n        return this.$row;\n    };     \n    this.getCurrentTokenColumn = function() {\n        var rowTokens = this.$rowTokens;\n        var tokenIndex = this.$tokenIndex;\n        var column = rowTokens[tokenIndex].start;\n        if (column !== undefined)\n            return column;\n            \n        column = 0;\n        while (tokenIndex > 0) {\n            tokenIndex -= 1;\n            column += rowTokens[tokenIndex].value.length;\n        }\n        \n        return column;  \n    };\n    this.getCurrentTokenPosition = function() {\n        return {row: this.$row, column: this.getCurrentTokenColumn()};\n    };\n    this.getCurrentTokenRange = function() {\n        var token = this.$rowTokens[this.$tokenIndex];\n        var column = this.getCurrentTokenColumn();\n        return new Range(this.$row, column, this.$row, column + token.value.length);\n    };\n    \n}).call(TokenIterator.prototype);\n\nexports.TokenIterator = TokenIterator;\n});\n\nace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\n\nvar SAFE_INSERT_IN_TOKENS =\n    [\"text\", \"paren.rparen\", \"punctuation.operator\"];\nvar SAFE_INSERT_BEFORE_TOKENS =\n    [\"text\", \"paren.rparen\", \"punctuation.operator\", \"comment\"];\n\nvar context;\nvar contextCache = {};\nvar defaultQuotes = {'\"' : '\"', \"'\" : \"'\"};\n\nvar initContext = function(editor) {\n    var id = -1;\n    if (editor.multiSelect) {\n        id = editor.selection.index;\n        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n            contextCache = {rangeCount: editor.multiSelect.rangeCount};\n    }\n    if (contextCache[id])\n        return context = contextCache[id];\n    context = contextCache[id] = {\n        autoInsertedBrackets: 0,\n        autoInsertedRow: -1,\n        autoInsertedLineEnd: \"\",\n        maybeInsertedBrackets: 0,\n        maybeInsertedRow: -1,\n        maybeInsertedLineStart: \"\",\n        maybeInsertedLineEnd: \"\"\n    };\n};\n\nvar getWrapped = function(selection, selected, opening, closing) {\n    var rowDiff = selection.end.row - selection.start.row;\n    return {\n        text: opening + selected + closing,\n        selection: [\n                0,\n                selection.start.column + 1,\n                rowDiff,\n                selection.end.column + (rowDiff ? 0 : 1)\n            ]\n    };\n};\n\nvar CstyleBehaviour = function(options) {\n    this.add(\"braces\", \"insertion\", function(state, action, editor, session, text) {\n        var cursor = editor.getCursorPosition();\n        var line = session.doc.getLine(cursor.row);\n        if (text == '{') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '{', '}');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {\n                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                    return {\n                        text: '{}',\n                        selection: [1, 1]\n                    };\n                } else {\n                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n                    return {\n                        text: '{',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == '}') {\n            initContext(editor);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == '}') {\n                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == \"\\n\" || text == \"\\r\\n\") {\n            initContext(editor);\n            var closing = \"\";\n            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n                CstyleBehaviour.clearMaybeInsertedClosing();\n            }\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === '}') {\n                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');\n                if (!openBracePos)\n                     return null;\n                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n            } else if (closing) {\n                var next_indent = this.$getIndent(line);\n            } else {\n                CstyleBehaviour.clearMaybeInsertedClosing();\n                return;\n            }\n            var indent = next_indent + session.getTabString();\n\n            return {\n                text: '\\n' + indent + '\\n' + next_indent + closing,\n                selection: [1, indent.length, 1, indent.length]\n            };\n        } else {\n            CstyleBehaviour.clearMaybeInsertedClosing();\n        }\n    });\n\n    this.add(\"braces\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '{') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.end.column, range.end.column + 1);\n            if (rightChar == '}') {\n                range.end.column++;\n                return range;\n            } else {\n                context.maybeInsertedBrackets--;\n            }\n        }\n    });\n\n    this.add(\"parens\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '(') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '(', ')');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n                return {\n                    text: '()',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ')') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ')') {\n                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"parens\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '(') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ')') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '[') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '[', ']');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n                return {\n                    text: '[]',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ']') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ']') {\n                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '[') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ']') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"insertion\", function(state, action, editor, session, text) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        if (text.length == 1 && quotes[text]) {\n            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) \n                return;\n            initContext(editor);\n            var quote = text;\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, quote, quote);\n            } else if (!selected) {\n                var cursor = editor.getCursorPosition();\n                var line = session.doc.getLine(cursor.row);\n                var leftChar = line.substring(cursor.column-1, cursor.column);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                \n                var token = session.getTokenAt(cursor.row, cursor.column);\n                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);\n                if (leftChar == \"\\\\\" && token && /escape/.test(token.type))\n                    return null;\n                \n                var stringBefore = token && /string|escape/.test(token.type);\n                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);\n                \n                var pair;\n                if (rightChar == quote) {\n                    pair = stringBefore !== stringAfter;\n                    if (pair && /string\\.end/.test(rightToken.type))\n                        pair = false;\n                } else {\n                    if (stringBefore && !stringAfter)\n                        return null; // wrap string with different quote\n                    if (stringBefore && stringAfter)\n                        return null; // do not pair quotes inside strings\n                    var wordRe = session.$mode.tokenRe;\n                    wordRe.lastIndex = 0;\n                    var isWordBefore = wordRe.test(leftChar);\n                    wordRe.lastIndex = 0;\n                    var isWordAfter = wordRe.test(leftChar);\n                    if (isWordBefore || isWordAfter)\n                        return null; // before or after alphanumeric\n                    if (rightChar && !/[\\s;,.})\\]\\\\]/.test(rightChar))\n                        return null; // there is rightChar and it isn't closing\n                    pair = true;\n                }\n                return {\n                    text: pair ? quote + quote : \"\",\n                    selection: [1,1]\n                };\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n};\n\n    \nCstyleBehaviour.isSaneInsertion = function(editor, session) {\n    var cursor = editor.getCursorPosition();\n    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n            return false;\n    }\n    iterator.stepForward();\n    return iterator.getCurrentTokenRow() !== cursor.row ||\n        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n};\n\nCstyleBehaviour.$matchTokenType = function(token, types) {\n    return types.indexOf(token.type || token) > -1;\n};\n\nCstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))\n        context.autoInsertedBrackets = 0;\n    context.autoInsertedRow = cursor.row;\n    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n    context.autoInsertedBrackets++;\n};\n\nCstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isMaybeInsertedClosing(cursor, line))\n        context.maybeInsertedBrackets = 0;\n    context.maybeInsertedRow = cursor.row;\n    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n    context.maybeInsertedLineEnd = line.substr(cursor.column);\n    context.maybeInsertedBrackets++;\n};\n\nCstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {\n    return context.autoInsertedBrackets > 0 &&\n        cursor.row === context.autoInsertedRow &&\n        bracket === context.autoInsertedLineEnd[0] &&\n        line.substr(cursor.column) === context.autoInsertedLineEnd;\n};\n\nCstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {\n    return context.maybeInsertedBrackets > 0 &&\n        cursor.row === context.maybeInsertedRow &&\n        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n};\n\nCstyleBehaviour.popAutoInsertedClosing = function() {\n    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n    context.autoInsertedBrackets--;\n};\n\nCstyleBehaviour.clearMaybeInsertedClosing = function() {\n    if (context) {\n        context.maybeInsertedBrackets = 0;\n        context.maybeInsertedRow = -1;\n    }\n};\n\n\n\noop.inherits(CstyleBehaviour, Behaviour);\n\nexports.CstyleBehaviour = CstyleBehaviour;\n});\n\nace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];\n\nvar code = 0;\nvar str = [];\nfor (var i = 0; i < wordChars.length; i += 2) {\n    str.push(code += wordChars[i]);\n    if (wordChars[i + 1])\n        str.push(45, code += wordChars[i + 1]);\n}\n\nexports.wordChars = String.fromCharCode.apply(null, str);\n\n});\n\nace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar config = require(\"../config\");\n\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar unicode = require(\"../unicode\");\nvar lang = require(\"../lib/lang\");\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\nvar Mode = function() {\n    this.HighlightRules = TextHighlightRules;\n};\n\n(function() {\n    this.$defaultBehaviour = new CstyleBehaviour();\n\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\n\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\n\n    this.getTokenizer = function() {\n        if (!this.$tokenizer) {\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n        }\n        return this.$tokenizer;\n    };\n\n    this.lineCommentStart = \"\";\n    this.blockComment = \"\";\n\n    this.toggleCommentLines = function(state, session, startRow, endRow) {\n        var doc = session.doc;\n\n        var ignoreBlankLines = true;\n        var shouldRemove = true;\n        var minIndent = Infinity;\n        var tabSize = session.getTabSize();\n        var insertAtTabStop = false;\n\n        if (!this.lineCommentStart) {\n            if (!this.blockComment)\n                return false;\n            var lineCommentStart = this.blockComment.start;\n            var lineCommentEnd = this.blockComment.end;\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n\n            var comment = function(line, i) {\n                if (testRemove(line, i))\n                    return;\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);\n                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n\n            var uncomment = function(line, i) {\n                var m;\n                if (m = line.match(regexpEnd))\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\n                if (m = line.match(regexpStart))\n                    doc.removeInLine(i, m[1].length, m[0].length);\n            };\n\n            var testRemove = function(line, row) {\n                if (regexpStart.test(line))\n                    return true;\n                var tokens = session.getTokens(row);\n                for (var i = 0; i < tokens.length; i++) {\n                    if (tokens[i].type === \"comment\")\n                        return true;\n                }\n            };\n        } else {\n            if (Array.isArray(this.lineCommentStart)) {\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n                var lineCommentStart = this.lineCommentStart[0];\n            } else {\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n                var lineCommentStart = this.lineCommentStart;\n            }\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n            \n            insertAtTabStop = session.getUseSoftTabs();\n\n            var uncomment = function(line, i) {\n                var m = line.match(regexpStart);\n                if (!m) return;\n                var start = m[1].length, end = m[0].length;\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n                    end--;\n                doc.removeInLine(i, start, end);\n            };\n            var commentWithSpace = lineCommentStart + \" \";\n            var comment = function(line, i) {\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    if (shouldInsertSpace(line, minIndent, minIndent))\n                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);\n                    else\n                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n            var testRemove = function(line, i) {\n                return regexpStart.test(line);\n            };\n            \n            var shouldInsertSpace = function(line, before, after) {\n                var spaces = 0;\n                while (before-- && line.charAt(before) == \" \")\n                    spaces++;\n                if (spaces % tabSize != 0)\n                    return false;\n                var spaces = 0;\n                while (line.charAt(after++) == \" \")\n                    spaces++;\n                if (tabSize > 2)\n                    return spaces % tabSize != tabSize - 1;\n                else\n                    return spaces % tabSize == 0;\n            };\n        }\n\n        function iter(fun) {\n            for (var i = startRow; i <= endRow; i++)\n                fun(doc.getLine(i), i);\n        }\n\n\n        var minEmptyLength = Infinity;\n        iter(function(line, i) {\n            var indent = line.search(/\\S/);\n            if (indent !== -1) {\n                if (indent < minIndent)\n                    minIndent = indent;\n                if (shouldRemove && !testRemove(line, i))\n                    shouldRemove = false;\n            } else if (minEmptyLength > line.length) {\n                minEmptyLength = line.length;\n            }\n        });\n\n        if (minIndent == Infinity) {\n            minIndent = minEmptyLength;\n            ignoreBlankLines = false;\n            shouldRemove = false;\n        }\n\n        if (insertAtTabStop && minIndent % tabSize != 0)\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n\n        iter(shouldRemove ? uncomment : comment);\n    };\n\n    this.toggleBlockComment = function(state, session, range, cursor) {\n        var comment = this.blockComment;\n        if (!comment)\n            return;\n        if (!comment.start && comment[0])\n            comment = comment[0];\n\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n        var token = iterator.getCurrentToken();\n\n        var sel = session.selection;\n        var initialRange = session.selection.toOrientedRange();\n        var startRow, colDiff;\n\n        if (token && /comment/.test(token.type)) {\n            var startRange, endRange;\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.start);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    startRange = new Range(row, column, row, column + comment.start.length);\n                    break;\n                }\n                token = iterator.stepBackward();\n            }\n\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.end);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    endRange = new Range(row, column, row, column + comment.end.length);\n                    break;\n                }\n                token = iterator.stepForward();\n            }\n            if (endRange)\n                session.remove(endRange);\n            if (startRange) {\n                session.remove(startRange);\n                startRow = startRange.start.row;\n                colDiff = -comment.start.length;\n            }\n        } else {\n            colDiff = comment.start.length;\n            startRow = range.start.row;\n            session.insert(range.end, comment.end);\n            session.insert(range.start, comment.start);\n        }\n        if (initialRange.start.row == startRow)\n            initialRange.start.column += colDiff;\n        if (initialRange.end.row == startRow)\n            initialRange.end.column += colDiff;\n        session.selection.fromOrientedRange(initialRange);\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$getIndent(line);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return false;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n    this.createWorker = function(session) {\n        return null;\n    };\n\n    this.createModeDelegates = function (mapping) {\n        this.$embeds = [];\n        this.$modes = {};\n        for (var i in mapping) {\n            if (mapping[i]) {\n                var Mode = mapping[i];\n                var id = Mode.prototype.$id;\n                var mode = config.$modes[id];\n                if (!mode)\n                    config.$modes[id] = mode = new Mode();\n                if (!config.$modes[i])\n                    config.$modes[i] = mode;\n                this.$embeds.push(i);\n                this.$modes[i] = mode;\n            }\n        }\n\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\", \n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\n\n        for (var i = 0; i < delegations.length; i++) {\n            (function(scope) {\n              var functionName = delegations[i];\n              var defaultHandler = scope[functionName];\n              scope[delegations[i]] = function() {\n                  return this.$delegator(functionName, arguments, defaultHandler);\n              };\n            }(this));\n        }\n    };\n\n    this.$delegator = function(method, args, defaultHandler) {\n        var state = args[0] || \"start\";\n        if (typeof state != \"string\") {\n            if (Array.isArray(state[2])) {\n                var language = state[2][state[2].length - 1];\n                var mode = this.$modes[language];\n                if (mode)\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\n            }\n            state = state[0] || \"start\";\n        }\n            \n        for (var i = 0; i < this.$embeds.length; i++) {\n            if (!this.$modes[this.$embeds[i]]) continue;\n\n            var split = state.split(this.$embeds[i]);\n            if (!split[0] && split[1]) {\n                args[0] = split[1];\n                var mode = this.$modes[this.$embeds[i]];\n                return mode[method].apply(mode, args);\n            }\n        }\n        var ret = defaultHandler.apply(this, args);\n        return defaultHandler ? ret : undefined;\n    };\n\n    this.transformAction = function(state, action, editor, session, param) {\n        if (this.$behaviour) {\n            var behaviours = this.$behaviour.getBehaviours();\n            for (var key in behaviours) {\n                if (behaviours[key][action]) {\n                    var ret = behaviours[key][action].apply(this, arguments);\n                    if (ret) {\n                        return ret;\n                    }\n                }\n            }\n        }\n    };\n    \n    this.getKeywords = function(append) {\n        if (!this.completionKeywords) {\n            var rules = this.$tokenizer.rules;\n            var completionKeywords = [];\n            for (var rule in rules) {\n                var ruleItr = rules[rule];\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\n                    if (typeof ruleItr[r].token === \"string\") {\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\n                            completionKeywords.push(ruleItr[r].regex);\n                    }\n                    else if (typeof ruleItr[r].token === \"object\") {\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    \n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\n                            }\n                        }\n                    }\n                }\n            }\n            this.completionKeywords = completionKeywords;\n        }\n        if (!append)\n            return this.$keywordList;\n        return completionKeywords.concat(this.$keywordList || []);\n    };\n    \n    this.$createKeywordList = function() {\n        if (!this.$highlightRules)\n            this.getTokenizer();\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        var keywords = this.$keywordList || this.$createKeywordList();\n        return keywords.map(function(word) {\n            return {\n                name: word,\n                value: word,\n                score: 0,\n                meta: \"keyword\"\n            };\n        });\n    };\n\n    this.$id = \"ace/mode/text\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nfunction throwDeltaError(delta, errorText){\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\n\nfunction positionInDocument(docLines, position) {\n    return position.row    >= 0 && position.row    <  docLines.length &&\n           position.column >= 0 && position.column <= docLines[position.row].length;\n}\n\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n       throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\n\nexports.applyDelta = function(docLines, delta, doNotValidate) {\n    \n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            } else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            } else {\n                docLines.splice(\n                    row, endRow - row + 1,\n                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)\n                );\n            }\n            break;\n    }\n};\n});\n\nace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar Anchor = exports.Anchor = function(doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    \n    if (typeof column == \"undefined\")\n        this.setPosition(row.row, row.column);\n    else\n        this.setPosition(row, column);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.getPosition = function() {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function() {\n        return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function(delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n\n        if (delta.start.row > this.row)\n            return;\n            \n        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    \n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n    }\n            \n    function $getTransformedPoint(delta, point, moveIfEqual) {\n        var deltaIsInsert = delta.action == \"insert\";\n        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);\n        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n        var deltaStart = delta.start;\n        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n            return {\n                row: point.row,\n                column: point.column\n            };\n        }\n        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n            return {\n                row: point.row + deltaRowShift,\n                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n            };\n        }\n        \n        return {\n            row: deltaStart.row,\n            column: deltaStart.column\n        };\n    }\n    this.setPosition = function(row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        } else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    this.detach = function() {\n        this.document.removeEventListener(\"change\", this.$onChange);\n    };\n    this.attach = function(doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function(row, column) {\n        var pos = {};\n\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n\n        if (column < 0)\n            pos.column = 0;\n\n        return pos;\n    };\n\n}).call(Anchor.prototype);\n\n});\n\nace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\n\nvar Document = function(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({row: 0, column: 0}, textOrLines);\n    } else {\n        this.insert({row: 0, column:0}, textOrLines);\n    }\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setValue = function(text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({row: 0, column: 0}, text);\n    };\n    this.getValue = function() {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function(row, column) {\n        return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n        this.$split = function(text) {\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n        };\n    } else {\n        this.$split = function(text) {\n            return text.split(/\\r\\n|\\r|\\n/);\n        };\n    }\n\n\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function() {\n        switch (this.$newLineMode) {\n          case \"windows\":\n            return \"\\r\\n\";\n          case \"unix\":\n            return \"\\n\";\n          default:\n            return this.$autoNewLine || \"\\n\";\n        }\n    };\n\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function(newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function() {\n        return this.$newLineMode;\n    };\n    this.isNewLine = function(text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    this.getLine = function(row) {\n        return this.$lines[row] || \"\";\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function() {\n        return this.getLines(0, this.getLength());\n    };\n    this.getLength = function() {\n        return this.$lines.length;\n    };\n    this.getTextRange = function(range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function(range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        } else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    this.insertLines = function(row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function(firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function(position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function(position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        \n        return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function(position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        \n        return this.clonePos(end);\n    };\n    \n    this.clippedPos = function(row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        } else if (row < 0) {\n            row = 0;\n        } else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return {row: row, column: column};\n    };\n    \n    this.clonePos = function(pos) {\n        return {row: pos.row, column: pos.column};\n    };\n    \n    this.pos = function(row, column) {\n        return {row: row, column: column};\n    };\n    \n    this.$clipPosition = function(position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        } else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    this.insertFullLines = function(row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        } else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({row: row, column: column}, lines);\n    };    \n    this.insertMergedLines = function(position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        \n        return this.clonePos(end);\n    };\n    this.remove = function(range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        });\n        return this.clonePos(start);\n    };\n    this.removeInLine = function(row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        }, true);\n        \n        return this.clonePos(start);\n    };\n    this.removeFullLines = function(firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine  = lastRow  < this.getLength() - 1;\n        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );\n        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );\n        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );\n        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); \n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        \n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    this.removeNewLine = function(row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    this.replace = function(range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        \n        return end;\n    };\n    this.applyDeltas = function(deltas) {\n        for (var i=0; i<deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    this.revertDeltas = function(deltas) {\n        for (var i=deltas.length-1; i>=0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    this.applyDelta = function(delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        \n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    \n    this.$splitAndapplyLargeDelta = function(delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row; \n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    this.revertDelta = function(delta) {\n        this.applyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    this.indexToPosition = function(index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return {row: i, column: index + lines[i].length + newlineLength};\n        }\n        return {row: l-1, column: index + lines[l-1].length + newlineLength};\n    };\n    this.positionToIndex = function(pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n\n        return index + pos.column;\n    };\n\n}).call(Document.prototype);\n\nexports.Document = Document;\n});\n\nace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar BackgroundTokenizer = function(tokenizer, editor) {\n    this.running = false;\n    this.lines = [];\n    this.states = [];\n    this.currentLine = 0;\n    this.tokenizer = tokenizer;\n\n    var self = this;\n\n    this.$worker = function() {\n        if (!self.running) { return; }\n\n        var workerStart = new Date();\n        var currentLine = self.currentLine;\n        var endLine = -1;\n        var doc = self.doc;\n\n        var startLine = currentLine;\n        while (self.lines[currentLine])\n            currentLine++;\n        \n        var len = doc.getLength();\n        var processedLines = 0;\n        self.running = false;\n        while (currentLine < len) {\n            self.$tokenizeRow(currentLine);\n            endLine = currentLine;\n            do {\n                currentLine++;\n            } while (self.lines[currentLine]);\n            processedLines ++;\n            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\n                self.running = setTimeout(self.$worker, 20);\n                break;\n            }\n        }\n        self.currentLine = currentLine;\n        \n        if (endLine == -1)\n            endLine = currentLine;\n        \n        if (startLine <= endLine)\n            self.fireUpdateEvent(startLine, endLine);\n    };\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n    this.setTokenizer = function(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.lines = [];\n        this.states = [];\n\n        this.start(0);\n    };\n    this.setDocument = function(doc) {\n        this.doc = doc;\n        this.lines = [];\n        this.states = [];\n\n        this.stop();\n    };\n    this.fireUpdateEvent = function(firstRow, lastRow) {\n        var data = {\n            first: firstRow,\n            last: lastRow\n        };\n        this._signal(\"update\", {data: data});\n    };\n    this.start = function(startRow) {\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n        this.lines.splice(this.currentLine, this.lines.length);\n        this.states.splice(this.currentLine, this.states.length);\n\n        this.stop();\n        this.running = setTimeout(this.$worker, 700);\n    };\n    \n    this.scheduleStart = function() {\n        if (!this.running)\n            this.running = setTimeout(this.$worker, 700);\n    };\n\n    this.$updateOnChange = function(delta) {\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n            this.lines[startRow] = null;\n        } else if (delta.action == \"remove\") {\n            this.lines.splice(startRow, len + 1, null);\n            this.states.splice(startRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(startRow, 1);\n            this.lines.splice.apply(this.lines, args);\n            this.states.splice.apply(this.states, args);\n        }\n\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n\n        this.stop();\n    };\n    this.stop = function() {\n        if (this.running)\n            clearTimeout(this.running);\n        this.running = false;\n    };\n    this.getTokens = function(row) {\n        return this.lines[row] || this.$tokenizeRow(row);\n    };\n    this.getState = function(row) {\n        if (this.currentLine == row)\n            this.$tokenizeRow(row);\n        return this.states[row] || \"start\";\n    };\n\n    this.$tokenizeRow = function(row) {\n        var line = this.doc.getLine(row);\n        var state = this.states[row - 1];\n\n        var data = this.tokenizer.getLineTokens(line, state, row);\n\n        if (this.states[row] + \"\" !== data.state + \"\") {\n            this.states[row] = data.state;\n            this.lines[row + 1] = null;\n            if (this.currentLine > row + 1)\n                this.currentLine = row + 1;\n        } else if (this.currentLine == row) {\n            this.currentLine = row + 1;\n        }\n\n        return this.lines[row] = data.tokens;\n    };\n\n}).call(BackgroundTokenizer.prototype);\n\nexports.BackgroundTokenizer = BackgroundTokenizer;\n});\n\nace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar SearchHighlight = function(regExp, clazz, type) {\n    this.setRegexp(regExp);\n    this.clazz = clazz;\n    this.type = type || \"text\";\n};\n\n(function() {\n    this.MAX_RANGES = 500;\n    \n    this.setRegexp = function(regExp) {\n        if (this.regExp+\"\" == regExp+\"\")\n            return;\n        this.regExp = regExp;\n        this.cache = [];\n    };\n\n    this.update = function(html, markerLayer, session, config) {\n        if (!this.regExp)\n            return;\n        var start = config.firstRow, end = config.lastRow;\n\n        for (var i = start; i <= end; i++) {\n            var ranges = this.cache[i];\n            if (ranges == null) {\n                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n                if (ranges.length > this.MAX_RANGES)\n                    ranges = ranges.slice(0, this.MAX_RANGES);\n                ranges = ranges.map(function(match) {\n                    return new Range(i, match.offset, i, match.offset + match.length);\n                });\n                this.cache[i] = ranges.length ? ranges : \"\";\n            }\n\n            for (var j = ranges.length; j --; ) {\n                markerLayer.drawSingleLineMarker(\n                    html, ranges[j].toScreenRange(session), this.clazz, config);\n            }\n        }\n    };\n\n}).call(SearchHighlight.prototype);\n\nexports.SearchHighlight = SearchHighlight;\n});\n\nace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nfunction FoldLine(foldData, folds) {\n    this.foldData = foldData;\n    if (Array.isArray(folds)) {\n        this.folds = folds;\n    } else {\n        folds = this.folds = [ folds ];\n    }\n\n    var last = folds[folds.length - 1];\n    this.range = new Range(folds[0].start.row, folds[0].start.column,\n                           last.end.row, last.end.column);\n    this.start = this.range.start;\n    this.end   = this.range.end;\n\n    this.folds.forEach(function(fold) {\n        fold.setFoldLine(this);\n    }, this);\n}\n\n(function() {\n    this.shiftRow = function(shift) {\n        this.start.row += shift;\n        this.end.row += shift;\n        this.folds.forEach(function(fold) {\n            fold.start.row += shift;\n            fold.end.row += shift;\n        });\n    };\n\n    this.addFold = function(fold) {\n        if (fold.sameRow) {\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n            }\n            this.folds.push(fold);\n            this.folds.sort(function(a, b) {\n                return -a.range.compareEnd(b.start.row, b.start.column);\n            });\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n                this.end.row = fold.end.row;\n                this.end.column =  fold.end.column;\n            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n                this.start.row = fold.start.row;\n                this.start.column = fold.start.column;\n            }\n        } else if (fold.start.row == this.end.row) {\n            this.folds.push(fold);\n            this.end.row = fold.end.row;\n            this.end.column = fold.end.column;\n        } else if (fold.end.row == this.start.row) {\n            this.folds.unshift(fold);\n            this.start.row = fold.start.row;\n            this.start.column = fold.start.column;\n        } else {\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n        }\n        fold.foldLine = this;\n    };\n\n    this.containsRow = function(row) {\n        return row >= this.start.row && row <= this.end.row;\n    };\n\n    this.walk = function(callback, endRow, endColumn) {\n        var lastEnd = 0,\n            folds = this.folds,\n            fold,\n            cmp, stop, isNewRow = true;\n\n        if (endRow == null) {\n            endRow = this.end.row;\n            endColumn = this.end.column;\n        }\n\n        for (var i = 0; i < folds.length; i++) {\n            fold = folds[i];\n\n            cmp = fold.range.compareStart(endRow, endColumn);\n            if (cmp == -1) {\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\n                return;\n            }\n\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n            if (stop || cmp === 0) {\n                return;\n            }\n            isNewRow = !fold.sameRow;\n            lastEnd = fold.end.column;\n        }\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\n    };\n\n    this.getNextFoldTo = function(row, column) {\n        var fold, cmp;\n        for (var i = 0; i < this.folds.length; i++) {\n            fold = this.folds[i];\n            cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                return {\n                    fold: fold,\n                    kind: \"after\"\n                };\n            } else if (cmp === 0) {\n                return {\n                    fold: fold,\n                    kind: \"inside\"\n                };\n            }\n        }\n        return null;\n    };\n\n    this.addRemoveChars = function(row, column, len) {\n        var ret = this.getNextFoldTo(row, column),\n            fold, folds;\n        if (ret) {\n            fold = ret.fold;\n            if (ret.kind == \"inside\"\n                && fold.start.column != column\n                && fold.start.row != row)\n            {\n                window.console && window.console.log(row, column, fold);\n            } else if (fold.start.row == row) {\n                folds = this.folds;\n                var i = folds.indexOf(fold);\n                if (i === 0) {\n                    this.start.column += len;\n                }\n                for (i; i < folds.length; i++) {\n                    fold = folds[i];\n                    fold.start.column += len;\n                    if (!fold.sameRow) {\n                        return;\n                    }\n                    fold.end.column += len;\n                }\n                this.end.column += len;\n            }\n        }\n    };\n\n    this.split = function(row, column) {\n        var pos = this.getNextFoldTo(row, column);\n        \n        if (!pos || pos.kind == \"inside\")\n            return null;\n            \n        var fold = pos.fold;\n        var folds = this.folds;\n        var foldData = this.foldData;\n        \n        var i = folds.indexOf(fold);\n        var foldBefore = folds[i - 1];\n        this.end.row = foldBefore.end.row;\n        this.end.column = foldBefore.end.column;\n        folds = folds.splice(i, folds.length - i);\n\n        var newFoldLine = new FoldLine(foldData, folds);\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n        return newFoldLine;\n    };\n\n    this.merge = function(foldLineNext) {\n        var folds = foldLineNext.folds;\n        for (var i = 0; i < folds.length; i++) {\n            this.addFold(folds[i]);\n        }\n        var foldData = this.foldData;\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\n    };\n\n    this.toString = function() {\n        var ret = [this.range.toString() + \": [\" ];\n\n        this.folds.forEach(function(fold) {\n            ret.push(\"  \" + fold.toString());\n        });\n        ret.push(\"]\");\n        return ret.join(\"\\n\");\n    };\n\n    this.idxToPosition = function(idx) {\n        var lastFoldEndColumn = 0;\n\n        for (var i = 0; i < this.folds.length; i++) {\n            var fold = this.folds[i];\n\n            idx -= fold.start.column - lastFoldEndColumn;\n            if (idx < 0) {\n                return {\n                    row: fold.start.row,\n                    column: fold.start.column + idx\n                };\n            }\n\n            idx -= fold.placeholder.length;\n            if (idx < 0) {\n                return fold.start;\n            }\n\n            lastFoldEndColumn = fold.end.column;\n        }\n\n        return {\n            row: this.end.row,\n            column: this.end.column + idx\n        };\n    };\n}).call(FoldLine.prototype);\n\nexports.FoldLine = FoldLine;\n});\n\nace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar Range = require(\"./range\").Range;\nvar comparePoints = Range.comparePoints;\n\nvar RangeList = function() {\n    this.ranges = [];\n};\n\n(function() {\n    this.comparePoints = comparePoints;\n\n    this.pointIndex = function(pos, excludeEdges, startIndex) {\n        var list = this.ranges;\n\n        for (var i = startIndex || 0; i < list.length; i++) {\n            var range = list[i];\n            var cmpEnd = comparePoints(pos, range.end);\n            if (cmpEnd > 0)\n                continue;\n            var cmpStart = comparePoints(pos, range.start);\n            if (cmpEnd === 0)\n                return excludeEdges && cmpStart !== 0 ? -i-2 : i;\n            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n                return i;\n\n            return -i-1;\n        }\n        return -i - 1;\n    };\n\n    this.add = function(range) {\n        var excludeEdges = !range.isEmpty();\n        var startIndex = this.pointIndex(range.start, excludeEdges);\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n\n        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        else\n            endIndex++;\n        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n    };\n\n    this.addList = function(list) {\n        var removed = [];\n        for (var i = list.length; i--; ) {\n            removed.push.apply(removed, this.add(list[i]));\n        }\n        return removed;\n    };\n\n    this.substractPoint = function(pos) {\n        var i = this.pointIndex(pos);\n\n        if (i >= 0)\n            return this.ranges.splice(i, 1);\n    };\n    this.merge = function() {\n        var removed = [];\n        var list = this.ranges;\n        \n        list = list.sort(function(a, b) {\n            return comparePoints(a.start, b.start);\n        });\n        \n        var next = list[0], range;\n        for (var i = 1; i < list.length; i++) {\n            range = next;\n            next = list[i];\n            var cmp = comparePoints(range.end, next.start);\n            if (cmp < 0)\n                continue;\n\n            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n                continue;\n\n            if (comparePoints(range.end, next.end) < 0) {\n                range.end.row = next.end.row;\n                range.end.column = next.end.column;\n            }\n\n            list.splice(i, 1);\n            removed.push(next);\n            next = range;\n            i--;\n        }\n        \n        this.ranges = list;\n\n        return removed;\n    };\n\n    this.contains = function(row, column) {\n        return this.pointIndex({row: row, column: column}) >= 0;\n    };\n\n    this.containsPoint = function(pos) {\n        return this.pointIndex(pos) >= 0;\n    };\n\n    this.rangeAtPoint = function(pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges[i];\n    };\n\n\n    this.clipRows = function(startRow, endRow) {\n        var list = this.ranges;\n        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n            return [];\n\n        var startIndex = this.pointIndex({row: startRow, column: 0});\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n\n        var clipped = [];\n        for (var i = startIndex; i < endIndex; i++) {\n            clipped.push(list[i]);\n        }\n        return clipped;\n    };\n\n    this.removeAll = function() {\n        return this.ranges.splice(0, this.ranges.length);\n    };\n\n    this.attach = function(session) {\n        if (this.session)\n            this.detach();\n\n        this.session = session;\n        this.onChange = this.$onChange.bind(this);\n\n        this.session.on('change', this.onChange);\n    };\n\n    this.detach = function() {\n        if (!this.session)\n            return;\n        this.session.removeListener('change', this.onChange);\n        this.session = null;\n    };\n\n    this.$onChange = function(delta) {\n        var start = delta.start;\n        var end = delta.end;\n        var startRow = start.row;\n        var endRow = end.row;\n        var ranges = this.ranges;\n        for (var i = 0, n = ranges.length; i < n; i++) {\n            var r = ranges[i];\n            if (r.end.row >= startRow)\n                break;\n        }\n        \n        if (delta.action == \"insert\") {\n            var lineDif = endRow - startRow;\n            var colDiff = -start.column + end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > startRow)\n                    break;\n    \n                if (r.start.row == startRow && r.start.column >= start.column) {\n                    if (r.start.column == start.column && this.$insertRight) {\n                    } else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                if (r.end.row == startRow && r.end.column >= start.column) {\n                    if (r.end.column == start.column && this.$insertRight) {\n                        continue;\n                    }\n                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {\n                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)\n                            r.end.column -= colDiff;\n                    }\n                    r.end.column += colDiff;\n                    r.end.row += lineDif;\n                }\n            }\n        } else {\n            var lineDif = startRow - endRow;\n            var colDiff = start.column - end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                \n                if (r.start.row > endRow)\n                    break;\n                    \n                if (r.end.row < endRow\n                    && (\n                        startRow < r.end.row \n                        || startRow == r.end.row && start.column < r.end.column\n                    )\n                ) {\n                    r.end.row = startRow;\n                    r.end.column = start.column;\n                }\n                else if (r.end.row == endRow) {\n                    if (r.end.column <= end.column) {\n                        if (lineDif || r.end.column > start.column) {\n                            r.end.column = start.column;\n                            r.end.row = start.row;\n                        }\n                    }\n                    else {\n                        r.end.column += colDiff;\n                        r.end.row += lineDif;\n                    }\n                }\n                else if (r.end.row > endRow) {\n                    r.end.row += lineDif;\n                }\n                \n                if (r.start.row < endRow\n                    && (\n                        startRow < r.start.row \n                        || startRow == r.start.row && start.column < r.start.column\n                    )\n                ) {\n                    r.start.row = startRow;\n                    r.start.column = start.column;\n                }\n                else if (r.start.row == endRow) {\n                    if (r.start.column <= end.column) {\n                        if (lineDif || r.start.column > start.column) {\n                            r.start.column = start.column;\n                            r.start.row = start.row;\n                        }\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                else if (r.start.row > endRow) {\n                    r.start.row += lineDif;\n                }\n            }\n        }\n\n        if (lineDif != 0 && i < n) {\n            for (; i < n; i++) {\n                var r = ranges[i];\n                r.start.row += lineDif;\n                r.end.row += lineDif;\n            }\n        }\n    };\n\n}).call(RangeList.prototype);\n\nexports.RangeList = RangeList;\n});\n\nace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/range_list\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar RangeList = require(\"../range_list\").RangeList;\nvar oop = require(\"../lib/oop\");\nvar Fold = exports.Fold = function(range, placeholder) {\n    this.foldLine = null;\n    this.placeholder = placeholder;\n    this.range = range;\n    this.start = range.start;\n    this.end = range.end;\n\n    this.sameRow = range.start.row == range.end.row;\n    this.subFolds = this.ranges = [];\n};\n\noop.inherits(Fold, RangeList);\n\n(function() {\n\n    this.toString = function() {\n        return '\"' + this.placeholder + '\" ' + this.range.toString();\n    };\n\n    this.setFoldLine = function(foldLine) {\n        this.foldLine = foldLine;\n        this.subFolds.forEach(function(fold) {\n            fold.setFoldLine(foldLine);\n        });\n    };\n\n    this.clone = function() {\n        var range = this.range.clone();\n        var fold = new Fold(range, this.placeholder);\n        this.subFolds.forEach(function(subFold) {\n            fold.subFolds.push(subFold.clone());\n        });\n        fold.collapseChildren = this.collapseChildren;\n        return fold;\n    };\n\n    this.addSubFold = function(fold) {\n        if (this.range.isEqual(fold))\n            return;\n\n        if (!this.range.containsRange(fold))\n            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n        consumeRange(fold, this.start);\n\n        var row = fold.start.row, column = fold.start.column;\n        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n            cmp = this.subFolds[i].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterStart = this.subFolds[i];\n\n        if (cmp == 0)\n            return afterStart.addSubFold(fold);\n        var row = fold.range.end.row, column = fold.range.end.column;\n        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n            cmp = this.subFolds[j].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterEnd = this.subFolds[j];\n\n        if (cmp == 0)\n            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n\n        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n        fold.setFoldLine(this.foldLine);\n\n        return fold;\n    };\n    \n    this.restoreRange = function(range) {\n        return restoreRange(range, this.start);\n    };\n\n}).call(Fold.prototype);\n\nfunction consumePoint(point, anchor) {\n    point.row -= anchor.row;\n    if (point.row == 0)\n        point.column -= anchor.column;\n}\nfunction consumeRange(range, anchor) {\n    consumePoint(range.start, anchor);\n    consumePoint(range.end, anchor);\n}\nfunction restorePoint(point, anchor) {\n    if (point.row == 0)\n        point.column += anchor.column;\n    point.row += anchor.row;\n}\nfunction restoreRange(range, anchor) {\n    restorePoint(range.start, anchor);\n    restorePoint(range.end, anchor);\n}\n\n});\n\nace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar FoldLine = require(\"./fold_line\").FoldLine;\nvar Fold = require(\"./fold\").Fold;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nfunction Folding() {\n    this.getFoldAt = function(row, column, side) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var folds = foldLine.folds;\n        for (var i = 0; i < folds.length; i++) {\n            var fold = folds[i];\n            if (fold.range.contains(row, column)) {\n                if (side == 1 && fold.range.isEnd(row, column)) {\n                    continue;\n                } else if (side == -1 && fold.range.isStart(row, column)) {\n                    continue;\n                }\n                return fold;\n            }\n        }\n    };\n    this.getFoldsInRange = function(range) {\n        var start = range.start;\n        var end = range.end;\n        var foldLines = this.$foldData;\n        var foundFolds = [];\n\n        start.column += 1;\n        end.column -= 1;\n\n        for (var i = 0; i < foldLines.length; i++) {\n            var cmp = foldLines[i].range.compareRange(range);\n            if (cmp == 2) {\n                continue;\n            }\n            else if (cmp == -2) {\n                break;\n            }\n\n            var folds = foldLines[i].folds;\n            for (var j = 0; j < folds.length; j++) {\n                var fold = folds[j];\n                cmp = fold.range.compareRange(range);\n                if (cmp == -2) {\n                    break;\n                } else if (cmp == 2) {\n                    continue;\n                } else\n                if (cmp == 42) {\n                    break;\n                }\n                foundFolds.push(fold);\n            }\n        }\n        start.column -= 1;\n        end.column += 1;\n\n        return foundFolds;\n    };\n\n    this.getFoldsInRangeList = function(ranges) {\n        if (Array.isArray(ranges)) {\n            var folds = [];\n            ranges.forEach(function(range) {\n                folds = folds.concat(this.getFoldsInRange(range));\n            }, this);\n        } else {\n            var folds = this.getFoldsInRange(ranges);\n        }\n        return folds;\n    };\n    this.getAllFolds = function() {\n        var folds = [];\n        var foldLines = this.$foldData;\n        \n        for (var i = 0; i < foldLines.length; i++)\n            for (var j = 0; j < foldLines[i].folds.length; j++)\n                folds.push(foldLines[i].folds[j]);\n\n        return folds;\n    };\n    this.getFoldStringAt = function(row, column, trim, foldLine) {\n        foldLine = foldLine || this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var lastFold = {\n            end: { column: 0 }\n        };\n        var str, fold;\n        for (var i = 0; i < foldLine.folds.length; i++) {\n            fold = foldLine.folds[i];\n            var cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                str = this\n                    .getLine(fold.start.row)\n                    .substring(lastFold.end.column, fold.start.column);\n                break;\n            }\n            else if (cmp === 0) {\n                return null;\n            }\n            lastFold = fold;\n        }\n        if (!str)\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n\n        if (trim == -1)\n            return str.substring(0, column - lastFold.end.column);\n        else if (trim == 1)\n            return str.substring(column - lastFold.end.column);\n        else\n            return str;\n    };\n\n    this.getFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n                return foldLine;\n            } else if (foldLine.end.row > docRow) {\n                return null;\n            }\n        }\n        return null;\n    };\n    this.getNextFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n        }\n        return null;\n    };\n\n    this.getFoldedRowCount = function(first, last) {\n        var foldData = this.$foldData, rowCount = last-first+1;\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i],\n                end = foldLine.end.row,\n                start = foldLine.start.row;\n            if (end >= last) {\n                if (start < last) {\n                    if (start >= first)\n                        rowCount -= last-start;\n                    else\n                        rowCount = 0; // in one fold\n                }\n                break;\n            } else if (end >= first){\n                if (start >= first) // fold inside range\n                    rowCount -=  end-start;\n                else\n                    rowCount -=  end-first+1;\n            }\n        }\n        return rowCount;\n    };\n\n    this.$addFoldLine = function(foldLine) {\n        this.$foldData.push(foldLine);\n        this.$foldData.sort(function(a, b) {\n            return a.start.row - b.start.row;\n        });\n        return foldLine;\n    };\n    this.addFold = function(placeholder, range) {\n        var foldData = this.$foldData;\n        var added = false;\n        var fold;\n        \n        if (placeholder instanceof Fold)\n            fold = placeholder;\n        else {\n            fold = new Fold(range, placeholder);\n            fold.collapseChildren = range.collapseChildren;\n        }\n        this.$clipRangeToDocument(fold.range);\n\n        var startRow = fold.start.row;\n        var startColumn = fold.start.column;\n        var endRow = fold.end.row;\n        var endColumn = fold.end.column;\n        if (!(startRow < endRow || \n            startRow == endRow && startColumn <= endColumn - 2))\n            throw new Error(\"The range has to be at least 2 characters width\");\n\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\n        if (startFold && endFold == startFold)\n            return startFold.addSubFold(fold);\n\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\n            this.removeFold(startFold);\n        \n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n            this.removeFold(endFold);\n        var folds = this.getFoldsInRange(fold.range);\n        if (folds.length > 0) {\n            this.removeFolds(folds);\n            folds.forEach(function(subFold) {\n                fold.addSubFold(subFold);\n            });\n        }\n\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (endRow == foldLine.start.row) {\n                foldLine.addFold(fold);\n                added = true;\n                break;\n            } else if (startRow == foldLine.end.row) {\n                foldLine.addFold(fold);\n                added = true;\n                if (!fold.sameRow) {\n                    var foldLineNext = foldData[i + 1];\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\n                        foldLine.merge(foldLineNext);\n                        break;\n                    }\n                }\n                break;\n            } else if (endRow <= foldLine.start.row) {\n                break;\n            }\n        }\n\n        if (!added)\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n\n        if (this.$useWrapMode)\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n        else\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\n\n        return fold;\n    };\n\n    this.addFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.addFold(fold);\n        }, this);\n    };\n\n    this.removeFold = function(fold) {\n        var foldLine = fold.foldLine;\n        var startRow = foldLine.start.row;\n        var endRow = foldLine.end.row;\n\n        var foldLines = this.$foldData;\n        var folds = foldLine.folds;\n        if (folds.length == 1) {\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\n        } else\n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n            folds.pop();\n            foldLine.end.row = folds[folds.length - 1].end.row;\n            foldLine.end.column = folds[folds.length - 1].end.column;\n        } else\n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n            folds.shift();\n            foldLine.start.row = folds[0].start.row;\n            foldLine.start.column = folds[0].start.column;\n        } else\n        if (fold.sameRow) {\n            folds.splice(folds.indexOf(fold), 1);\n        } else\n        {\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n            folds = newFoldLine.folds;\n            folds.shift();\n            newFoldLine.start.row = folds[0].start.row;\n            newFoldLine.start.column = folds[0].start.column;\n        }\n\n        if (!this.$updating) {\n            if (this.$useWrapMode)\n                this.$updateWrapData(startRow, endRow);\n            else\n                this.$updateRowLengthCache(startRow, endRow);\n        }\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\n    };\n\n    this.removeFolds = function(folds) {\n        var cloneFolds = [];\n        for (var i = 0; i < folds.length; i++) {\n            cloneFolds.push(folds[i]);\n        }\n\n        cloneFolds.forEach(function(fold) {\n            this.removeFold(fold);\n        }, this);\n        this.$modified = true;\n    };\n\n    this.expandFold = function(fold) {\n        this.removeFold(fold);\n        fold.subFolds.forEach(function(subFold) {\n            fold.restoreRange(subFold);\n            this.addFold(subFold);\n        }, this);\n        if (fold.collapseChildren > 0) {\n            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);\n        }\n        fold.subFolds = [];\n    };\n\n    this.expandFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.expandFold(fold);\n        }, this);\n    };\n\n    this.unfold = function(location, expandInner) {\n        var range, folds;\n        if (location == null) {\n            range = new Range(0, 0, this.getLength(), 0);\n            expandInner = true;\n        } else if (typeof location == \"number\")\n            range = new Range(location, 0, location, this.getLine(location).length);\n        else if (\"row\" in location)\n            range = Range.fromPoints(location, location);\n        else\n            range = location;\n        \n        folds = this.getFoldsInRangeList(range);\n        if (expandInner) {\n            this.removeFolds(folds);\n        } else {\n            var subFolds = folds;\n            while (subFolds.length) {\n                this.expandFolds(subFolds);\n                subFolds = this.getFoldsInRangeList(range);\n            }\n        }\n        if (folds.length)\n            return folds;\n    };\n    this.isRowFolded = function(docRow, startFoldRow) {\n        return !!this.getFoldLine(docRow, startFoldRow);\n    };\n\n    this.getRowFoldEnd = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.end.row : docRow;\n    };\n\n    this.getRowFoldStart = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.start.row : docRow;\n    };\n\n    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {\n        if (startRow == null)\n            startRow = foldLine.start.row;\n        if (startColumn == null)\n            startColumn = 0;\n        if (endRow == null)\n            endRow = foldLine.end.row;\n        if (endColumn == null)\n            endColumn = this.getLine(endRow).length;\n        var doc = this.doc;\n        var textLine = \"\";\n\n        foldLine.walk(function(placeholder, row, column, lastColumn) {\n            if (row < startRow)\n                return;\n            if (row == startRow) {\n                if (column < startColumn)\n                    return;\n                lastColumn = Math.max(startColumn, lastColumn);\n            }\n\n            if (placeholder != null) {\n                textLine += placeholder;\n            } else {\n                textLine += doc.getLine(row).substring(lastColumn, column);\n            }\n        }, endRow, endColumn);\n        return textLine;\n    };\n\n    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {\n        var foldLine = this.getFoldLine(row);\n\n        if (!foldLine) {\n            var line;\n            line = this.doc.getLine(row);\n            return line.substring(startColumn || 0, endColumn || line.length);\n        } else {\n            return this.getFoldDisplayLine(\n                foldLine, row, endColumn, startRow, startColumn);\n        }\n    };\n\n    this.$cloneFoldData = function() {\n        var fd = [];\n        fd = this.$foldData.map(function(foldLine) {\n            var folds = foldLine.folds.map(function(fold) {\n                return fold.clone();\n            });\n            return new FoldLine(fd, folds);\n        });\n\n        return fd;\n    };\n\n    this.toggleFold = function(tryToUnfold) {\n        var selection = this.selection;\n        var range = selection.getRange();\n        var fold;\n        var bracketPos;\n\n        if (range.isEmpty()) {\n            var cursor = range.start;\n            fold = this.getFoldAt(cursor.row, cursor.column);\n\n            if (fold) {\n                this.expandFold(fold);\n                return;\n            } else if (bracketPos = this.findMatchingBracket(cursor)) {\n                if (range.comparePoint(bracketPos) == 1) {\n                    range.end = bracketPos;\n                } else {\n                    range.start = bracketPos;\n                    range.start.column++;\n                    range.end.column--;\n                }\n            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {\n                if (range.comparePoint(bracketPos) == 1)\n                    range.end = bracketPos;\n                else\n                    range.start = bracketPos;\n\n                range.start.column++;\n            } else {\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n            }\n        } else {\n            var folds = this.getFoldsInRange(range);\n            if (tryToUnfold && folds.length) {\n                this.expandFolds(folds);\n                return;\n            } else if (folds.length == 1 ) {\n                fold = folds[0];\n            }\n        }\n\n        if (!fold)\n            fold = this.getFoldAt(range.start.row, range.start.column);\n\n        if (fold && fold.range.toString() == range.toString()) {\n            this.expandFold(fold);\n            return;\n        }\n\n        var placeholder = \"...\";\n        if (!range.isMultiLine()) {\n            placeholder = this.getTextRange(range);\n            if (placeholder.length < 4)\n                return;\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n        }\n\n        this.addFold(placeholder, range);\n    };\n\n    this.getCommentFoldRange = function(row, column, dir) {\n        var iterator = new TokenIterator(this, row, column);\n        var token = iterator.getCurrentToken();\n        var type = token.type;\n        if (token && /^comment|string/.test(type)) {\n            type = type.match(/comment|string/)[0];\n            if (type == \"comment\")\n                type += \"|doc-start\";\n            var re = new RegExp(type);\n            var range = new Range();\n            if (dir != 1) {\n                do {\n                    token = iterator.stepBackward();\n                } while (token && re.test(token.type));\n                iterator.stepForward();\n            }\n            \n            range.start.row = iterator.getCurrentTokenRow();\n            range.start.column = iterator.getCurrentTokenColumn() + 2;\n\n            iterator = new TokenIterator(this, row, column);\n            \n            if (dir != -1) {\n                var lastRow = -1;\n                do {\n                    token = iterator.stepForward();\n                    if (lastRow == -1) {\n                        var state = this.getState(iterator.$row);\n                        if (!re.test(state))\n                            lastRow = iterator.$row;\n                    } else if (iterator.$row > lastRow) {\n                        break;\n                    }\n                } while (token && re.test(token.type));\n                token = iterator.stepBackward();\n            } else\n                token = iterator.getCurrentToken();\n\n            range.end.row = iterator.getCurrentTokenRow();\n            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;\n            return range;\n        }\n    };\n\n    this.foldAll = function(startRow, endRow, depth) {\n        if (depth == undefined)\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\n        var foldWidgets = this.foldWidgets;\n        if (!foldWidgets)\n            return; // mode doesn't support folding\n        endRow = endRow || this.getLength();\n        startRow = startRow || 0;\n        for (var row = startRow; row < endRow; row++) {\n            if (foldWidgets[row] == null)\n                foldWidgets[row] = this.getFoldWidget(row);\n            if (foldWidgets[row] != \"start\")\n                continue;\n\n            var range = this.getFoldWidgetRange(row);\n            if (range && range.isMultiLine()\n                && range.end.row <= endRow\n                && range.start.row >= startRow\n            ) {\n                row = range.end.row;\n                try {\n                    var fold = this.addFold(\"...\", range);\n                    if (fold)\n                        fold.collapseChildren = depth;\n                } catch(e) {}\n            }\n        }\n    };\n    this.$foldStyles = {\n        \"manual\": 1,\n        \"markbegin\": 1,\n        \"markbeginend\": 1\n    };\n    this.$foldStyle = \"markbegin\";\n    this.setFoldStyle = function(style) {\n        if (!this.$foldStyles[style])\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n        \n        if (this.$foldStyle == style)\n            return;\n\n        this.$foldStyle = style;\n        \n        if (style == \"manual\")\n            this.unfold();\n        var mode = this.$foldMode;\n        this.$setFolding(null);\n        this.$setFolding(mode);\n    };\n\n    this.$setFolding = function(foldMode) {\n        if (this.$foldMode == foldMode)\n            return;\n            \n        this.$foldMode = foldMode;\n        \n        this.off('change', this.$updateFoldWidgets);\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n        this._signal(\"changeAnnotation\");\n        \n        if (!foldMode || this.$foldStyle == \"manual\") {\n            this.foldWidgets = null;\n            return;\n        }\n        \n        this.foldWidgets = [];\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n        \n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\n        this.on('change', this.$updateFoldWidgets);\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n    };\n\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n        var fw = this.foldWidgets;\n        if (!fw || (ignoreCurrent && fw[row]))\n            return {};\n\n        var i = row - 1, firstRange;\n        while (i >= 0) {\n            var c = fw[i];\n            if (c == null)\n                c = fw[i] = this.getFoldWidget(i);\n\n            if (c == \"start\") {\n                var range = this.getFoldWidgetRange(i);\n                if (!firstRange)\n                    firstRange = range;\n                if (range && range.end.row >= row)\n                    break;\n            }\n            i--;\n        }\n\n        return {\n            range: i !== -1 && range,\n            firstRange: firstRange\n        };\n    };\n\n    this.onFoldWidgetClick = function(row, e) {\n        e = e.domEvent;\n        var options = {\n            children: e.shiftKey,\n            all: e.ctrlKey || e.metaKey,\n            siblings: e.altKey\n        };\n        \n        var range = this.$toggleFoldWidget(row, options);\n        if (!range) {\n            var el = (e.target || e.srcElement);\n            if (el && /ace_fold-widget/.test(el.className))\n                el.className += \" ace_invalid\";\n        }\n    };\n    \n    this.$toggleFoldWidget = function(row, options) {\n        if (!this.getFoldWidget)\n            return;\n        var type = this.getFoldWidget(row);\n        var line = this.getLine(row);\n\n        var dir = type === \"end\" ? -1 : 1;\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n\n        if (fold) {\n            if (options.children || options.all)\n                this.removeFold(fold);\n            else\n                this.expandFold(fold);\n            return fold;\n        }\n\n        var range = this.getFoldWidgetRange(row, true);\n        if (range && !range.isMultiLine()) {\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n            if (fold && range.isEqual(fold.range)) {\n                this.removeFold(fold);\n                return fold;\n            }\n        }\n        \n        if (options.siblings) {\n            var data = this.getParentFoldRangeData(row);\n            if (data.range) {\n                var startRow = data.range.start.row + 1;\n                var endRow = data.range.end.row;\n            }\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n        } else if (options.children) {\n            endRow = range ? range.end.row : this.getLength();\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\n        } else if (range) {\n            if (options.all) \n                range.collapseChildren = 10000;\n            this.addFold(\"...\", range);\n        }\n        \n        return range;\n    };\n    \n    \n    \n    this.toggleFoldWidget = function(toggleParent) {\n        var row = this.selection.getCursor().row;\n        row = this.getRowFoldStart(row);\n        var range = this.$toggleFoldWidget(row, {});\n        \n        if (range)\n            return;\n        var data = this.getParentFoldRangeData(row, true);\n        range = data.range || data.firstRange;\n        \n        if (range) {\n            row = range.start.row;\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n\n            if (fold) {\n                this.removeFold(fold);\n            } else {\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n\n    this.updateFoldWidgets = function(delta) {\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n\n        if (len === 0) {\n            this.foldWidgets[firstRow] = null;\n        } else if (delta.action == 'remove') {\n            this.foldWidgets.splice(firstRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\n        }\n    };\n    this.tokenizerUpdateFoldWidgets = function(e) {\n        var rows = e.data;\n        if (rows.first != rows.last) {\n            if (this.foldWidgets.length > rows.first)\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\n        }\n    };\n}\n\nexports.Folding = Folding;\n\n});\n\nace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\n\nfunction BracketMatch() {\n\n    this.findMatchingBracket = function(position, chr) {\n        if (position.column == 0) return null;\n\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);\n        if (charBeforeCursor == \"\") return null;\n\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match)\n            return null;\n\n        if (match[1])\n            return this.$findClosingBracket(match[1], position);\n        else\n            return this.$findOpeningBracket(match[2], position);\n    };\n    \n    this.getBracketRange = function(pos) {\n        var line = this.getLine(pos.row);\n        var before = true, range;\n\n        var chr = line.charAt(pos.column-1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = {row: pos.row, column: pos.column + 1};\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n            before = false;\n        }\n        if (!match)\n            return null;\n\n        if (match[1]) {\n            var bracketPos = this.$findClosingBracket(match[1], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(pos, bracketPos);\n            if (!before) {\n                range.end.column++;\n                range.start.column--;\n            }\n            range.cursor = range.end;\n        } else {\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(bracketPos, pos);\n            if (!before) {\n                range.start.column++;\n                range.end.column--;\n            }\n            range.cursor = range.start;\n        }\n        \n        return range;\n    };\n\n    this.$brackets = {\n        \")\": \"(\",\n        \"(\": \")\",\n        \"]\": \"[\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"<\": \">\",\n        \">\": \"<\"\n    };\n\n    this.$findOpeningBracket = function(bracket, position, typeRe) {\n        var openBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        \n         if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n        var value = token.value;\n        \n        while (true) {\n        \n            while (valueIndex >= 0) {\n                var chr = value.charAt(valueIndex);\n                if (chr == openBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex -= 1;\n            }\n            do {\n                token = iterator.stepBackward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n                \n            value = token.value;\n            valueIndex = value.length - 1;\n        }\n        \n        return null;\n    };\n\n    this.$findClosingBracket = function(bracket, position, typeRe) {\n        var closingBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n\n        if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n\n        while (true) {\n\n            var value = token.value;\n            var valueLength = value.length;\n            while (valueIndex < valueLength) {\n                var chr = value.charAt(valueIndex);\n                if (chr == closingBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex += 1;\n            }\n            do {\n                token = iterator.stepForward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n\n            valueIndex = 0;\n        }\n        \n        return null;\n    };\n}\nexports.BracketMatch = BracketMatch;\n\n});\n\nace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/bidihandler\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\nvar config = require(\"./config\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Selection = require(\"./selection\").Selection;\nvar TextMode = require(\"./mode/text\").Mode;\nvar Range = require(\"./range\").Range;\nvar Document = require(\"./document\").Document;\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\n\nvar EditSession = function(text, mode) {\n    this.$breakpoints = [];\n    this.$decorations = [];\n    this.$frontMarkers = {};\n    this.$backMarkers = {};\n    this.$markerId = 1;\n    this.$undoSelect = true;\n\n    this.$foldData = [];\n    this.id = \"session\" + (++EditSession.$uid);\n    this.$foldData.toString = function() {\n        return this.join(\"\\n\");\n    };\n    this.on(\"changeFold\", this.onChangeFold.bind(this));\n    this.$onChange = this.onChange.bind(this);\n\n    if (typeof text != \"object\" || !text.getLine)\n        text = new Document(text);\n\n    this.setDocument(text);\n    this.selection = new Selection(this);\n    this.$bidiHandler = new BidiHandler(this);\n\n    config.resetOptions(this);\n    this.setMode(mode);\n    config._signal(\"session\", this);\n};\n\n\nEditSession.$uid = 0;\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setDocument = function(doc) {\n        if (this.doc)\n            this.doc.removeListener(\"change\", this.$onChange);\n\n        this.doc = doc;\n        doc.on(\"change\", this.$onChange);\n\n        if (this.bgTokenizer)\n            this.bgTokenizer.setDocument(this.getDocument());\n\n        this.resetCaches();\n    };\n    this.getDocument = function() {\n        return this.doc;\n    };\n    this.$resetRowCache = function(docRow) {\n        if (!docRow) {\n            this.$docRowCache = [];\n            this.$screenRowCache = [];\n            return;\n        }\n        var l = this.$docRowCache.length;\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n        if (l > i) {\n            this.$docRowCache.splice(i, l);\n            this.$screenRowCache.splice(i, l);\n        }\n    };\n\n    this.$getRowCacheIndex = function(cacheArray, val) {\n        var low = 0;\n        var hi = cacheArray.length - 1;\n\n        while (low <= hi) {\n            var mid = (low + hi) >> 1;\n            var c = cacheArray[mid];\n\n            if (val > c)\n                low = mid + 1;\n            else if (val < c)\n                hi = mid - 1;\n            else\n                return mid;\n        }\n\n        return low -1;\n    };\n\n    this.resetCaches = function() {\n        this.$modified = true;\n        this.$wrapData = [];\n        this.$rowLengthCache = [];\n        this.$resetRowCache(0);\n        if (this.bgTokenizer)\n            this.bgTokenizer.start(0);\n    };\n\n    this.onChangeFold = function(e) {\n        var fold = e.data;\n        this.$resetRowCache(fold.start.row);\n    };\n\n    this.onChange = function(delta) {\n        this.$modified = true;\n        this.$bidiHandler.onChange(delta);\n        this.$resetRowCache(delta.start.row);\n\n        var removedFolds = this.$updateInternalDataOnChange(delta);\n        if (!this.$fromUndo && this.$undoManager) {\n            if (removedFolds && removedFolds.length) {\n                this.$undoManager.add({\n                    action: \"removeFolds\",\n                    folds:  removedFolds\n                }, this.mergeUndoDeltas);\n                this.mergeUndoDeltas = true;\n            }\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\n            this.mergeUndoDeltas = true;\n            \n            this.$informUndoManager.schedule();\n        }\n\n        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);\n        this._signal(\"change\", delta);\n    };\n    this.setValue = function(text) {\n        this.doc.setValue(text);\n        this.selection.moveTo(0, 0);\n\n        this.$resetRowCache(0);\n        this.setUndoManager(this.$undoManager);\n        this.getUndoManager().reset();\n    };\n    this.getValue =\n    this.toString = function() {\n        return this.doc.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.getState = function(row) {\n        return this.bgTokenizer.getState(row);\n    };\n    this.getTokens = function(row) {\n        return this.bgTokenizer.getTokens(row);\n    };\n    this.getTokenAt = function(row, column) {\n        var tokens = this.bgTokenizer.getTokens(row);\n        var token, c = 0;\n        if (column == null) {\n            var i = tokens.length - 1;\n            c = this.getLine(row).length;\n        } else {\n            for (var i = 0; i < tokens.length; i++) {\n                c += tokens[i].value.length;\n                if (c >= column)\n                    break;\n            }\n        }\n        token = tokens[i];\n        if (!token)\n            return null;\n        token.index = i;\n        token.start = c - token.value.length;\n        return token;\n    };\n    this.setUndoManager = function(undoManager) {\n        this.$undoManager = undoManager;\n        \n        if (this.$informUndoManager)\n            this.$informUndoManager.cancel();\n        \n        if (undoManager) {\n            var self = this;\n            undoManager.addSession(this);\n            this.$syncInformUndoManager = function() {\n                self.$informUndoManager.cancel();\n                self.mergeUndoDeltas = false;\n            };\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n        } else {\n            this.$syncInformUndoManager = function() {};\n        }\n    };\n    this.markUndoGroup = function() {\n        if (this.$syncInformUndoManager)\n            this.$syncInformUndoManager();\n    };\n    \n    this.$defaultUndoManager = {\n        undo: function() {},\n        redo: function() {},\n        reset: function() {},\n        add: function() {},\n        addSelection: function() {},\n        startNewGroup: function() {},\n        addSession: function() {}\n    };\n    this.getUndoManager = function() {\n        return this.$undoManager || this.$defaultUndoManager;\n    };\n    this.getTabString = function() {\n        if (this.getUseSoftTabs()) {\n            return lang.stringRepeat(\" \", this.getTabSize());\n        } else {\n            return \"\\t\";\n        }\n    };\n    this.setUseSoftTabs = function(val) {\n        this.setOption(\"useSoftTabs\", val);\n    };\n    this.getUseSoftTabs = function() {\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n    };\n    this.setTabSize = function(tabSize) {\n        this.setOption(\"tabSize\", tabSize);\n    };\n    this.getTabSize = function() {\n        return this.$tabSize;\n    };\n    this.isTabStop = function(position) {\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n    };\n    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\n    };\n    this.getNavigateWithinSoftTabs = function() {\n        return this.$navigateWithinSoftTabs;\n    };\n\n    this.$overwrite = false;\n    this.setOverwrite = function(overwrite) {\n        this.setOption(\"overwrite\", overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.$overwrite;\n    };\n    this.toggleOverwrite = function() {\n        this.setOverwrite(!this.$overwrite);\n    };\n    this.addGutterDecoration = function(row, className) {\n        if (!this.$decorations[row])\n            this.$decorations[row] = \"\";\n        this.$decorations[row] += \" \" + className;\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.removeGutterDecoration = function(row, className) {\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.getBreakpoints = function() {\n        return this.$breakpoints;\n    };\n    this.setBreakpoints = function(rows) {\n        this.$breakpoints = [];\n        for (var i=0; i<rows.length; i++) {\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n        }\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoints = function() {\n        this.$breakpoints = [];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.setBreakpoint = function(row, className) {\n        if (className === undefined)\n            className = \"ace_breakpoint\";\n        if (className)\n            this.$breakpoints[row] = className;\n        else\n            delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoint = function(row) {\n        delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.addMarker = function(range, clazz, type, inFront) {\n        var id = this.$markerId++;\n\n        var marker = {\n            range : range,\n            type : type || \"line\",\n            renderer: typeof type == \"function\" ? type : null,\n            clazz : clazz,\n            inFront: !!inFront,\n            id: id\n        };\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return id;\n    };\n    this.addDynamicMarker = function(marker, inFront) {\n        if (!marker.update)\n            return;\n        var id = this.$markerId++;\n        marker.id = id;\n        marker.inFront = !!inFront;\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return marker;\n    };\n    this.removeMarker = function(markerId) {\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n        if (!marker)\n            return;\n\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n        delete (markers[markerId]);\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n    };\n    this.getMarkers = function(inFront) {\n        return inFront ? this.$frontMarkers : this.$backMarkers;\n    };\n\n    this.highlight = function(re) {\n        if (!this.$searchHighlight) {\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n            this.$searchHighlight = this.addDynamicMarker(highlight);\n        }\n        this.$searchHighlight.setRegexp(re);\n    };\n    this.highlightLines = function(startRow, endRow, clazz, inFront) {\n        if (typeof endRow != \"number\") {\n            clazz = endRow;\n            endRow = startRow;\n        }\n        if (!clazz)\n            clazz = \"ace_step\";\n\n        var range = new Range(startRow, 0, endRow, Infinity);\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n        return range;\n    };\n    this.setAnnotations = function(annotations) {\n        this.$annotations = annotations;\n        this._signal(\"changeAnnotation\", {});\n    };\n    this.getAnnotations = function() {\n        return this.$annotations || [];\n    };\n    this.clearAnnotations = function() {\n        this.setAnnotations([]);\n    };\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r?\\n)/m);\n        if (match) {\n            this.$autoNewLine = match[1];\n        } else {\n            this.$autoNewLine = \"\\n\";\n        }\n    };\n    this.getWordRange = function(row, column) {\n        var line = this.getLine(row);\n\n        var inToken = false;\n        if (column > 0)\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n\n        if (!inToken)\n            inToken = !!line.charAt(column).match(this.tokenRe);\n\n        if (inToken)\n            var re = this.tokenRe;\n        else if (/^\\s+$/.test(line.slice(column-1, column+1)))\n            var re = /\\s/;\n        else\n            var re = this.nonTokenRe;\n\n        var start = column;\n        if (start > 0) {\n            do {\n                start--;\n            }\n            while (start >= 0 && line.charAt(start).match(re));\n            start++;\n        }\n\n        var end = column;\n        while (end < line.length && line.charAt(end).match(re)) {\n            end++;\n        }\n\n        return new Range(row, start, row, end);\n    };\n    this.getAWordRange = function(row, column) {\n        var wordRange = this.getWordRange(row, column);\n        var line = this.getLine(wordRange.end.row);\n\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n            wordRange.end.column += 1;\n        }\n        return wordRange;\n    };\n    this.setNewLineMode = function(newLineMode) {\n        this.doc.setNewLineMode(newLineMode);\n    };\n    this.getNewLineMode = function() {\n        return this.doc.getNewLineMode();\n    };\n    this.setUseWorker = function(useWorker) { this.setOption(\"useWorker\", useWorker); };\n    this.getUseWorker = function() { return this.$useWorker; };\n    this.onReloadTokenizer = function(e) {\n        var rows = e.data;\n        this.bgTokenizer.start(rows.first);\n        this._signal(\"tokenizerUpdate\", e);\n    };\n\n    this.$modes = config.$modes;\n    this.$mode = null;\n    this.$modeId = null;\n    this.setMode = function(mode, cb) {\n        if (mode && typeof mode === \"object\") {\n            if (mode.getTokenizer)\n                return this.$onChangeMode(mode);\n            var options = mode;\n            var path = options.path;\n        } else {\n            path = mode || \"ace/mode/text\";\n        }\n        if (!this.$modes[\"ace/mode/text\"])\n            this.$modes[\"ace/mode/text\"] = new TextMode();\n\n        if (this.$modes[path] && !options) {\n            this.$onChangeMode(this.$modes[path]);\n            cb && cb();\n            return;\n        }\n        this.$modeId = path;\n        config.loadModule([\"mode\", path], function(m) {\n            if (this.$modeId !== path)\n                return cb && cb();\n            if (this.$modes[path] && !options) {\n                this.$onChangeMode(this.$modes[path]);\n            } else if (m && m.Mode) {\n                m = new m.Mode(options);\n                if (!options) {\n                    this.$modes[path] = m;\n                    m.$id = path;\n                }\n                this.$onChangeMode(m);\n            }\n            cb && cb();\n        }.bind(this));\n        if (!this.$mode)\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n    };\n\n    this.$onChangeMode = function(mode, $isPlaceholder) {\n        if (!$isPlaceholder)\n            this.$modeId = mode.$id;\n        if (this.$mode === mode) \n            return;\n\n        this.$mode = mode;\n\n        this.$stopWorker();\n\n        if (this.$useWorker)\n            this.$startWorker();\n\n        var tokenizer = mode.getTokenizer();\n\n        if(tokenizer.addEventListener !== undefined) {\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n            tokenizer.addEventListener(\"update\", onReloadTokenizer);\n        }\n\n        if (!this.bgTokenizer) {\n            this.bgTokenizer = new BackgroundTokenizer(tokenizer);\n            var _self = this;\n            this.bgTokenizer.addEventListener(\"update\", function(e) {\n                _self._signal(\"tokenizerUpdate\", e);\n            });\n        } else {\n            this.bgTokenizer.setTokenizer(tokenizer);\n        }\n\n        this.bgTokenizer.setDocument(this.getDocument());\n\n        this.tokenRe = mode.tokenRe;\n        this.nonTokenRe = mode.nonTokenRe;\n\n        \n        if (!$isPlaceholder) {\n            if (mode.attachToSession)\n                mode.attachToSession(this);\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n            this.$setFolding(mode.foldingRules);\n            this.bgTokenizer.start(0);\n            this._emit(\"changeMode\");\n        }\n    };\n\n    this.$stopWorker = function() {\n        if (this.$worker) {\n            this.$worker.terminate();\n            this.$worker = null;\n        }\n    };\n\n    this.$startWorker = function() {\n        try {\n            this.$worker = this.$mode.createWorker(this);\n        } catch (e) {\n            config.warn(\"Could not load worker\", e);\n            this.$worker = null;\n        }\n    };\n    this.getMode = function() {\n        return this.$mode;\n    };\n\n    this.$scrollTop = 0;\n    this.setScrollTop = function(scrollTop) {\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n            return;\n\n        this.$scrollTop = scrollTop;\n        this._signal(\"changeScrollTop\", scrollTop);\n    };\n    this.getScrollTop = function() {\n        return this.$scrollTop;\n    };\n\n    this.$scrollLeft = 0;\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n            return;\n\n        this.$scrollLeft = scrollLeft;\n        this._signal(\"changeScrollLeft\", scrollLeft);\n    };\n    this.getScrollLeft = function() {\n        return this.$scrollLeft;\n    };\n    this.getScreenWidth = function() {\n        this.$computeWidth();\n        if (this.lineWidgets) \n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n        return this.screenWidth;\n    };\n    \n    this.getLineWidgetMaxWidth = function() {\n        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;\n        var width = 0;\n        this.lineWidgets.forEach(function(w) {\n            if (w && w.screenWidth > width)\n                width = w.screenWidth;\n        });\n        return this.lineWidgetWidth = width;\n    };\n\n    this.$computeWidth = function(force) {\n        if (this.$modified || force) {\n            this.$modified = false;\n\n            if (this.$useWrapMode)\n                return this.screenWidth = this.$wrapLimit;\n\n            var lines = this.doc.getAllLines();\n            var cache = this.$rowLengthCache;\n            var longestScreenLine = 0;\n            var foldIndex = 0;\n            var foldLine = this.$foldData[foldIndex];\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\n            var len = lines.length;\n\n            for (var i = 0; i < len; i++) {\n                if (i > foldStart) {\n                    i = foldLine.end.row + 1;\n                    if (i >= len)\n                        break;\n                    foldLine = this.$foldData[foldIndex++];\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n\n                if (cache[i] == null)\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n\n                if (cache[i] > longestScreenLine)\n                    longestScreenLine = cache[i];\n            }\n            this.screenWidth = longestScreenLine;\n        }\n    };\n    this.getLine = function(row) {\n        return this.doc.getLine(row);\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.doc.getLines(firstRow, lastRow);\n    };\n    this.getLength = function() {\n        return this.doc.getLength();\n    };\n    this.getTextRange = function(range) {\n        return this.doc.getTextRange(range || this.selection.getRange());\n    };\n    this.insert = function(position, text) {\n        return this.doc.insert(position, text);\n    };\n    this.remove = function(range) {\n        return this.doc.remove(range);\n    };\n    this.removeFullLines = function(firstRow, lastRow){\n        return this.doc.removeFullLines(firstRow, lastRow);\n    };\n    this.undoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = deltas.length - 1; i != -1; i--) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.revertDelta(delta);\n            } else if (delta.folds) {\n                this.addFolds(delta.folds);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionBefore)\n                this.selection.fromJSON(deltas.selectionBefore);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\n        }\n        this.$fromUndo = false;\n    };\n    this.redoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.applyDelta(delta);\n            }\n        }\n\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionAfter)\n                this.selection.fromJSON(deltas.selectionAfter);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\n        }\n        this.$fromUndo = false;\n    };\n    this.setUndoSelect = function(enable) {\n        this.$undoSelect = enable;\n    };\n\n    this.$getUndoSelection = function(deltas, isUndo) {\n        function isInsert(delta) {\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\n        }\n\n        var range, point;\n        var lastDeltaIsInsert;\n\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (!delta.start) continue; // skip folds\n            if (!range) {\n                if (isInsert(delta)) {\n                    range = Range.fromPoints(delta.start, delta.end);\n                    lastDeltaIsInsert = true;\n                } else {\n                    range = Range.fromPoints(delta.start, delta.start);\n                    lastDeltaIsInsert = false;\n                }\n                continue;\n            }\n            \n            if (isInsert(delta)) {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range.setStart(point);\n                }\n                point = delta.end;\n                if (range.compare(point.row, point.column) == 1) {\n                    range.setEnd(point);\n                }\n                lastDeltaIsInsert = true;\n            } else {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n                lastDeltaIsInsert = false;\n            }\n        }\n        return range;\n    };\n    this.replace = function(range, text) {\n        return this.doc.replace(range, text);\n    };\n    this.moveText = function(fromRange, toPosition, copy) {\n        var text = this.getTextRange(fromRange);\n        var folds = this.getFoldsInRange(fromRange);\n\n        var toRange = Range.fromPoints(toPosition, toPosition);\n        if (!copy) {\n            this.remove(fromRange);\n            var rowDiff = fromRange.start.row - fromRange.end.row;\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n            if (collDiff) {\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n                    toRange.start.column += collDiff;\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n                    toRange.end.column += collDiff;\n            }\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n                toRange.start.row += rowDiff;\n                toRange.end.row += rowDiff;\n            }\n        }\n\n        toRange.end = this.insert(toRange.start, text);\n        if (folds.length) {\n            var oldStart = fromRange.start;\n            var newStart = toRange.start;\n            var rowDiff = newStart.row - oldStart.row;\n            var collDiff = newStart.column - oldStart.column;\n            this.addFolds(folds.map(function(x) {\n                x = x.clone();\n                if (x.start.row == oldStart.row)\n                    x.start.column += collDiff;\n                if (x.end.row == oldStart.row)\n                    x.end.column += collDiff;\n                x.start.row += rowDiff;\n                x.end.row += rowDiff;\n                return x;\n            }));\n        }\n\n        return toRange;\n    };\n    this.indentRows = function(startRow, endRow, indentString) {\n        indentString = indentString.replace(/\\t/g, this.getTabString());\n        for (var row=startRow; row<=endRow; row++)\n            this.doc.insertInLine({row: row, column: 0}, indentString);\n    };\n    this.outdentRows = function (range) {\n        var rowRange = range.collapseRows();\n        var deleteRange = new Range(0, 0, 0, 0);\n        var size = this.getTabSize();\n\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n            var line = this.getLine(i);\n\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            for (var j = 0; j < size; ++j)\n                if (line.charAt(j) != ' ')\n                    break;\n            if (j < size && line.charAt(j) == '\\t') {\n                deleteRange.start.column = j;\n                deleteRange.end.column = j + 1;\n            } else {\n                deleteRange.start.column = 0;\n                deleteRange.end.column = j;\n            }\n            this.remove(deleteRange);\n        }\n    };\n\n    this.$moveLines = function(firstRow, lastRow, dir) {\n        firstRow = this.getRowFoldStart(firstRow);\n        lastRow = this.getRowFoldEnd(lastRow);\n        if (dir < 0) {\n            var row = this.getRowFoldStart(firstRow + dir);\n            if (row < 0) return 0;\n            var diff = row-firstRow;\n        } else if (dir > 0) {\n            var row = this.getRowFoldEnd(lastRow + dir);\n            if (row > this.doc.getLength()-1) return 0;\n            var diff = row-lastRow;\n        } else {\n            firstRow = this.$clipRowToDocument(firstRow);\n            lastRow = this.$clipRowToDocument(lastRow);\n            var diff = lastRow - firstRow + 1;\n        }\n\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n        var folds = this.getFoldsInRange(range).map(function(x){\n            x = x.clone();\n            x.start.row += diff;\n            x.end.row += diff;\n            return x;\n        });\n        \n        var lines = dir == 0\n            ? this.doc.getLines(firstRow, lastRow)\n            : this.doc.removeFullLines(firstRow, lastRow);\n        this.doc.insertFullLines(firstRow+diff, lines);\n        folds.length && this.addFolds(folds);\n        return diff;\n    };\n    this.moveLinesUp = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, -1);\n    };\n    this.moveLinesDown = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 1);\n    };\n    this.duplicateLines = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 0);\n    };\n\n\n    this.$clipRowToDocument = function(row) {\n        return Math.max(0, Math.min(row, this.doc.getLength()-1));\n    };\n\n    this.$clipColumnToRow = function(row, column) {\n        if (column < 0)\n            return 0;\n        return Math.min(this.doc.getLine(row).length, column);\n    };\n\n\n    this.$clipPositionToDocument = function(row, column) {\n        column = Math.max(0, column);\n\n        if (row < 0) {\n            row = 0;\n            column = 0;\n        } else {\n            var len = this.doc.getLength();\n            if (row >= len) {\n                row = len - 1;\n                column = this.doc.getLine(len-1).length;\n            } else {\n                column = Math.min(this.doc.getLine(row).length, column);\n            }\n        }\n\n        return {\n            row: row,\n            column: column\n        };\n    };\n\n    this.$clipRangeToDocument = function(range) {\n        if (range.start.row < 0) {\n            range.start.row = 0;\n            range.start.column = 0;\n        } else {\n            range.start.column = this.$clipColumnToRow(\n                range.start.row,\n                range.start.column\n            );\n        }\n\n        var len = this.doc.getLength() - 1;\n        if (range.end.row > len) {\n            range.end.row = len;\n            range.end.column = this.doc.getLine(len).length;\n        } else {\n            range.end.column = this.$clipColumnToRow(\n                range.end.row,\n                range.end.column\n            );\n        }\n        return range;\n    };\n    this.$wrapLimit = 80;\n    this.$useWrapMode = false;\n    this.$wrapLimitRange = {\n        min : null,\n        max : null\n    };\n    this.setUseWrapMode = function(useWrapMode) {\n        if (useWrapMode != this.$useWrapMode) {\n            this.$useWrapMode = useWrapMode;\n            this.$modified = true;\n            this.$resetRowCache(0);\n            if (useWrapMode) {\n                var len = this.getLength();\n                this.$wrapData = Array(len);\n                this.$updateWrapData(0, len - 1);\n            }\n\n            this._signal(\"changeWrapMode\");\n        }\n    };\n    this.getUseWrapMode = function() {\n        return this.$useWrapMode;\n    };\n    this.setWrapLimitRange = function(min, max) {\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n            this.$wrapLimitRange = { min: min, max: max };\n            this.$modified = true;\n            this.$bidiHandler.markAsDirty();\n            if (this.$useWrapMode)\n                this._signal(\"changeWrapMode\");\n        }\n    };\n    this.adjustWrapLimit = function(desiredLimit, $printMargin) {\n        var limits = this.$wrapLimitRange;\n        if (limits.max < 0)\n            limits = {min: $printMargin, max: $printMargin};\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n            this.$wrapLimit = wrapLimit;\n            this.$modified = true;\n            if (this.$useWrapMode) {\n                this.$updateWrapData(0, this.getLength() - 1);\n                this.$resetRowCache(0);\n                this._signal(\"changeWrapLimit\");\n            }\n            return true;\n        }\n        return false;\n    };\n\n    this.$constrainWrapLimit = function(wrapLimit, min, max) {\n        if (min)\n            wrapLimit = Math.max(min, wrapLimit);\n\n        if (max)\n            wrapLimit = Math.min(max, wrapLimit);\n\n        return wrapLimit;\n    };\n    this.getWrapLimit = function() {\n        return this.$wrapLimit;\n    };\n    this.setWrapLimit = function (limit) {\n        this.setWrapLimitRange(limit, limit);\n    };\n    this.getWrapLimitRange = function() {\n        return {\n            min : this.$wrapLimitRange.min,\n            max : this.$wrapLimitRange.max\n        };\n    };\n\n    this.$updateInternalDataOnChange = function(delta) {\n        var useWrapMode = this.$useWrapMode;\n        var action = delta.action;\n        var start = delta.start;\n        var end = delta.end;\n        var firstRow = start.row;\n        var lastRow = end.row;\n        var len = lastRow - firstRow;\n        var removedFolds = null;\n        \n        this.$updating = true;\n        if (len != 0) {\n            if (action === \"remove\") {\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n\n                var foldLines = this.$foldData;\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                var foldLine = this.getFoldLine(end.row);\n                var idx = 0;\n                if (foldLine) {\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n                    foldLine.shiftRow(-len);\n\n                    var foldLineBefore = this.getFoldLine(firstRow);\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\n                        foldLineBefore.merge(foldLine);\n                        foldLine = foldLineBefore;\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= end.row) {\n                        foldLine.shiftRow(-len);\n                    }\n                }\n\n                lastRow = firstRow;\n            } else {\n                var args = Array(len);\n                args.unshift(firstRow, 0);\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\n                arr.splice.apply(arr, args);\n                var foldLines = this.$foldData;\n                var foldLine = this.getFoldLine(firstRow);\n                var idx = 0;\n                if (foldLine) {\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\n                    if (cmp == 0) {\n                        foldLine = foldLine.split(start.row, start.column);\n                        if (foldLine) {\n                            foldLine.shiftRow(len);\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n                        }\n                    } else\n                    if (cmp == -1) {\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n                        foldLine.shiftRow(len);\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= firstRow) {\n                        foldLine.shiftRow(len);\n                    }\n                }\n            }\n        } else {\n            len = Math.abs(delta.start.column - delta.end.column);\n            if (action === \"remove\") {\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                len = -len;\n            }\n            var foldLine = this.getFoldLine(firstRow);\n            if (foldLine) {\n                foldLine.addRemoveChars(firstRow, start.column, len);\n            }\n        }\n\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n        }\n        this.$updating = false;\n\n        if (useWrapMode)\n            this.$updateWrapData(firstRow, lastRow);\n        else\n            this.$updateRowLengthCache(firstRow, lastRow);\n\n        return removedFolds;\n    };\n\n    this.$updateRowLengthCache = function(firstRow, lastRow, b) {\n        this.$rowLengthCache[firstRow] = null;\n        this.$rowLengthCache[lastRow] = null;\n    };\n\n    this.$updateWrapData = function(firstRow, lastRow) {\n        var lines = this.doc.getAllLines();\n        var tabSize = this.getTabSize();\n        var wrapData = this.$wrapData;\n        var wrapLimit = this.$wrapLimit;\n        var tokens;\n        var foldLine;\n\n        var row = firstRow;\n        lastRow = Math.min(lastRow, lines.length - 1);\n        while (row <= lastRow) {\n            foldLine = this.getFoldLine(row, foldLine);\n            if (!foldLine) {\n                tokens = this.$getDisplayTokens(lines[row]);\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row ++;\n            } else {\n                tokens = [];\n                foldLine.walk(function(placeholder, row, column, lastColumn) {\n                        var walkTokens;\n                        if (placeholder != null) {\n                            walkTokens = this.$getDisplayTokens(\n                                            placeholder, tokens.length);\n                            walkTokens[0] = PLACEHOLDER_START;\n                            for (var i = 1; i < walkTokens.length; i++) {\n                                walkTokens[i] = PLACEHOLDER_BODY;\n                            }\n                        } else {\n                            walkTokens = this.$getDisplayTokens(\n                                lines[row].substring(lastColumn, column),\n                                tokens.length);\n                        }\n                        tokens = tokens.concat(walkTokens);\n                    }.bind(this),\n                    foldLine.end.row,\n                    lines[foldLine.end.row].length + 1\n                );\n\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row = foldLine.end.row + 1;\n            }\n        }\n    };\n    var CHAR = 1,\n        CHAR_EXT = 2,\n        PLACEHOLDER_START = 3,\n        PLACEHOLDER_BODY =  4,\n        PUNCTUATION = 9,\n        SPACE = 10,\n        TAB = 11,\n        TAB_SPACE = 12;\n\n\n    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {\n        if (tokens.length == 0) {\n            return [];\n        }\n\n        var splits = [];\n        var displayLength = tokens.length;\n        var lastSplit = 0, lastDocSplit = 0;\n\n        var isCode = this.$wrapAsCode;\n\n        var indentedSoftWrap = this.$indentedSoftWrap;\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\n\n        function getWrapIndent() {\n            var indentation = 0;\n            if (maxIndent === 0)\n                return indentation;\n            if (indentedSoftWrap) {\n                for (var i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    if (token == SPACE)\n                        indentation += 1;\n                    else if (token == TAB)\n                        indentation += tabSize;\n                    else if (token == TAB_SPACE)\n                        continue;\n                    else\n                        break;\n                }\n            }\n            if (isCode && indentedSoftWrap !== false)\n                indentation += tabSize;\n            return Math.min(indentation, maxIndent);\n        }\n        function addSplit(screenPos) {\n            var len = screenPos - lastSplit;\n            for (var i = lastSplit; i < screenPos; i++) {\n                var ch = tokens[i];\n                if (ch === 12 || ch === 2) len -= 1;\n            }\n\n            if (!splits.length) {\n                indent = getWrapIndent();\n                splits.indent = indent;\n            }\n            lastDocSplit += len;\n            splits.push(lastDocSplit);\n            lastSplit = screenPos;\n        }\n        var indent = 0;\n        while (displayLength - lastSplit > wrapLimit - indent) {\n            var split = lastSplit + wrapLimit - indent;\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n                addSplit(split);\n                continue;\n            }\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n                for (split; split != lastSplit - 1; split--) {\n                    if (tokens[split] == PLACEHOLDER_START) {\n                        break;\n                    }\n                }\n                if (split > lastSplit) {\n                    addSplit(split);\n                    continue;\n                }\n                split = lastSplit + wrapLimit;\n                for (split; split < tokens.length; split++) {\n                    if (tokens[split] != PLACEHOLDER_BODY) {\n                        break;\n                    }\n                }\n                if (split == tokens.length) {\n                    break;  // Breaks the while-loop.\n                }\n                addSplit(split);\n                continue;\n            }\n            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                split --;\n            }\n            if (isCode) {\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                    split --;\n                }\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\n                    split --;\n                }\n            } else {\n                while (split > minSplit && tokens[split] < SPACE) {\n                    split --;\n                }\n            }\n            if (split > minSplit) {\n                addSplit(++split);\n                continue;\n            }\n            split = lastSplit + wrapLimit;\n            if (tokens[split] == CHAR_EXT)\n                split--;\n            addSplit(split - indent);\n        }\n        return splits;\n    };\n    this.$getDisplayTokens = function(str, offset) {\n        var arr = [];\n        var tabSize;\n        offset = offset || 0;\n\n        for (var i = 0; i < str.length; i++) {\n            var c = str.charCodeAt(i);\n            if (c == 9) {\n                tabSize = this.getScreenTabSize(arr.length + offset);\n                arr.push(TAB);\n                for (var n = 1; n < tabSize; n++) {\n                    arr.push(TAB_SPACE);\n                }\n            }\n            else if (c == 32) {\n                arr.push(SPACE);\n            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {\n                arr.push(PUNCTUATION);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                arr.push(CHAR, CHAR_EXT);\n            } else {\n                arr.push(CHAR);\n            }\n        }\n        return arr;\n    };\n    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n        if (maxScreenColumn == 0)\n            return [0, 0];\n        if (maxScreenColumn == null)\n            maxScreenColumn = Infinity;\n        screenColumn = screenColumn || 0;\n\n        var c, column;\n        for (column = 0; column < str.length; column++) {\n            c = str.charCodeAt(column);\n            if (c == 9) {\n                screenColumn += this.getScreenTabSize(screenColumn);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                screenColumn += 2;\n            } else {\n                screenColumn += 1;\n            }\n            if (screenColumn > maxScreenColumn) {\n                break;\n            }\n        }\n\n        return [screenColumn, column];\n    };\n\n    this.lineWidgets = null;\n    this.getRowLength = function(row) {\n        if (this.lineWidgets)\n            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else \n            h = 0;\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1 + h;\n        } else {\n            return this.$wrapData[row].length + 1 + h;\n        }\n    };\n    this.getRowLineCount = function(row) {\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1;\n        } else {\n            return this.$wrapData[row].length + 1;\n        }\n    };\n\n    this.getRowWrapIndent = function(screenRow) {\n        if (this.$useWrapMode) {\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n            var splits = this.$wrapData[pos.row];\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\n        } else {\n            return 0;\n        }\n    };\n    this.getScreenLastRowColumn = function(screenRow) {\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n        return this.documentToScreenColumn(pos.row, pos.column);\n    };\n    this.getDocumentLastRowColumn = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.getScreenLastRowColumn(screenRow);\n    };\n    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n    };\n    this.getRowSplitData = function(row) {\n        if (!this.$useWrapMode) {\n            return undefined;\n        } else {\n            return this.$wrapData[row];\n        }\n    };\n    this.getScreenTabSize = function(screenColumn) {\n        return this.$tabSize - screenColumn % this.$tabSize;\n    };\n\n\n    this.screenToDocumentRow = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n    };\n\n\n    this.screenToDocumentColumn = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n    };\n    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {\n        if (screenRow < 0)\n            return {row: 0, column: 0};\n\n        var line;\n        var docRow = 0;\n        var docColumn = 0;\n        var column;\n        var row = 0;\n        var rowLength = 0;\n\n        var rowCache = this.$screenRowCache;\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var docRow = this.$docRowCache[i];\n            var doCache = screenRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var maxRow = this.getLength() - 1;\n        var foldLine = this.getNextFoldLine(docRow);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (row <= screenRow) {\n            rowLength = this.getRowLength(docRow);\n            if (row + rowLength > screenRow || docRow >= maxRow) {\n                break;\n            } else {\n                row += rowLength;\n                docRow++;\n                if (docRow > foldStart) {\n                    docRow = foldLine.end.row+1;\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n            }\n\n            if (doCache) {\n                this.$docRowCache.push(docRow);\n                this.$screenRowCache.push(row);\n            }\n        }\n\n        if (foldLine && foldLine.start.row <= docRow) {\n            line = this.getFoldDisplayLine(foldLine);\n            docRow = foldLine.start.row;\n        } else if (row + rowLength <= screenRow || docRow > maxRow) {\n            return {\n                row: maxRow,\n                column: this.getLine(maxRow).length\n            };\n        } else {\n            line = this.getLine(docRow);\n            foldLine = null;\n        }\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\n        if (this.$useWrapMode) {\n            var splits = this.$wrapData[docRow];\n            if (splits) {\n                column = splits[splitIndex];\n                if(splitIndex > 0 && splits.length) {\n                    wrapIndent = splits.indent;\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n                    line = line.substring(docColumn);\n                }\n            }\n        }\n\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\n\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\n        if (this.$useWrapMode && docColumn >= column)\n            docColumn = column - 1;\n\n        if (foldLine)\n            return foldLine.idxToPosition(docColumn);\n\n        return {row: docRow, column: docColumn};\n    };\n    this.documentToScreenPosition = function(docRow, docColumn) {\n        if (typeof docColumn === \"undefined\")\n            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);\n        else\n            pos = this.$clipPositionToDocument(docRow, docColumn);\n\n        docRow = pos.row;\n        docColumn = pos.column;\n\n        var screenRow = 0;\n        var foldStartRow = null;\n        var fold = null;\n        fold = this.getFoldAt(docRow, docColumn, 1);\n        if (fold) {\n            docRow = fold.start.row;\n            docColumn = fold.start.column;\n        }\n\n        var rowEnd, row = 0;\n\n\n        var rowCache = this.$docRowCache;\n        var i = this.$getRowCacheIndex(rowCache, docRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var screenRow = this.$screenRowCache[i];\n            var doCache = docRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var foldLine = this.getNextFoldLine(row);\n        var foldStart = foldLine ?foldLine.start.row :Infinity;\n\n        while (row < docRow) {\n            if (row >= foldStart) {\n                rowEnd = foldLine.end.row + 1;\n                if (rowEnd > docRow)\n                    break;\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n                foldStart = foldLine ?foldLine.start.row :Infinity;\n            }\n            else {\n                rowEnd = row + 1;\n            }\n\n            screenRow += this.getRowLength(row);\n            row = rowEnd;\n\n            if (doCache) {\n                this.$docRowCache.push(row);\n                this.$screenRowCache.push(screenRow);\n            }\n        }\n        var textLine = \"\";\n        if (foldLine && row >= foldStart) {\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n            foldStartRow = foldLine.start.row;\n        } else {\n            textLine = this.getLine(docRow).substring(0, docColumn);\n            foldStartRow = docRow;\n        }\n        var wrapIndent = 0;\n        if (this.$useWrapMode) {\n            var wrapRow = this.$wrapData[foldStartRow];\n            if (wrapRow) {\n                var screenRowOffset = 0;\n                while (textLine.length >= wrapRow[screenRowOffset]) {\n                    screenRow ++;\n                    screenRowOffset++;\n                }\n                textLine = textLine.substring(\n                    wrapRow[screenRowOffset - 1] || 0, textLine.length\n                );\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\n            }\n        }\n\n        return {\n            row: screenRow,\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\n        };\n    };\n    this.documentToScreenColumn = function(row, docColumn) {\n        return this.documentToScreenPosition(row, docColumn).column;\n    };\n    this.documentToScreenRow = function(docRow, docColumn) {\n        return this.documentToScreenPosition(docRow, docColumn).row;\n    };\n    this.getScreenLength = function() {\n        var screenRows = 0;\n        var fold = null;\n        if (!this.$useWrapMode) {\n            screenRows = this.getLength();\n            var foldData = this.$foldData;\n            for (var i = 0; i < foldData.length; i++) {\n                fold = foldData[i];\n                screenRows -= fold.end.row - fold.start.row;\n            }\n        } else {\n            var lastRow = this.$wrapData.length;\n            var row = 0, i = 0;\n            var fold = this.$foldData[i++];\n            var foldStart = fold ? fold.start.row :Infinity;\n\n            while (row < lastRow) {\n                var splits = this.$wrapData[row];\n                screenRows += splits ? splits.length + 1 : 1;\n                row ++;\n                if (row > foldStart) {\n                    row = fold.end.row+1;\n                    fold = this.$foldData[i++];\n                    foldStart = fold ?fold.start.row :Infinity;\n                }\n            }\n        }\n        if (this.lineWidgets)\n            screenRows += this.$getWidgetScreenLength();\n\n        return screenRows;\n    };\n    this.$setFontMetrics = function(fm) {\n        if (!this.$enableVarChar) return;\n        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n            if (maxScreenColumn === 0)\n                return [0, 0];\n            if (!maxScreenColumn)\n                maxScreenColumn = Infinity;\n            screenColumn = screenColumn || 0;\n            \n            var c, column;\n            for (column = 0; column < str.length; column++) {\n                c = str.charAt(column);\n                if (c === \"\\t\") {\n                    screenColumn += this.getScreenTabSize(screenColumn);\n                } else {\n                    screenColumn += fm.getCharacterWidth(c);\n                }\n                if (screenColumn > maxScreenColumn) {\n                    break;\n                }\n            }\n            \n            return [screenColumn, column];\n        };\n    };\n    \n    this.destroy = function() {\n        if (this.bgTokenizer) {\n            this.bgTokenizer.setDocument(null);\n            this.bgTokenizer = null;\n        }\n        this.$stopWorker();\n    };\n\n    this.isFullWidth = isFullWidth;\n    function isFullWidth(c) {\n        if (c < 0x1100)\n            return false;\n        return c >= 0x1100 && c <= 0x115F ||\n               c >= 0x11A3 && c <= 0x11A7 ||\n               c >= 0x11FA && c <= 0x11FF ||\n               c >= 0x2329 && c <= 0x232A ||\n               c >= 0x2E80 && c <= 0x2E99 ||\n               c >= 0x2E9B && c <= 0x2EF3 ||\n               c >= 0x2F00 && c <= 0x2FD5 ||\n               c >= 0x2FF0 && c <= 0x2FFB ||\n               c >= 0x3000 && c <= 0x303E ||\n               c >= 0x3041 && c <= 0x3096 ||\n               c >= 0x3099 && c <= 0x30FF ||\n               c >= 0x3105 && c <= 0x312D ||\n               c >= 0x3131 && c <= 0x318E ||\n               c >= 0x3190 && c <= 0x31BA ||\n               c >= 0x31C0 && c <= 0x31E3 ||\n               c >= 0x31F0 && c <= 0x321E ||\n               c >= 0x3220 && c <= 0x3247 ||\n               c >= 0x3250 && c <= 0x32FE ||\n               c >= 0x3300 && c <= 0x4DBF ||\n               c >= 0x4E00 && c <= 0xA48C ||\n               c >= 0xA490 && c <= 0xA4C6 ||\n               c >= 0xA960 && c <= 0xA97C ||\n               c >= 0xAC00 && c <= 0xD7A3 ||\n               c >= 0xD7B0 && c <= 0xD7C6 ||\n               c >= 0xD7CB && c <= 0xD7FB ||\n               c >= 0xF900 && c <= 0xFAFF ||\n               c >= 0xFE10 && c <= 0xFE19 ||\n               c >= 0xFE30 && c <= 0xFE52 ||\n               c >= 0xFE54 && c <= 0xFE66 ||\n               c >= 0xFE68 && c <= 0xFE6B ||\n               c >= 0xFF01 && c <= 0xFF60 ||\n               c >= 0xFFE0 && c <= 0xFFE6;\n    }\n\n}).call(EditSession.prototype);\n\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\n\n\nconfig.defineOptions(EditSession.prototype, \"session\", {\n    wrap: {\n        set: function(value) {\n            if (!value || value == \"off\")\n                value = false;\n            else if (value == \"free\")\n                value = true;\n            else if (value == \"printMargin\")\n                value = -1;\n            else if (typeof value == \"string\")\n                value = parseInt(value, 10) || false;\n\n            if (this.$wrap == value)\n                return;\n            this.$wrap = value;\n            if (!value) {\n                this.setUseWrapMode(false);\n            } else {\n                var col = typeof value == \"number\" ? value : null;\n                this.setWrapLimitRange(col, col);\n                this.setUseWrapMode(true);\n            }\n        },\n        get: function() {\n            if (this.getUseWrapMode()) {\n                if (this.$wrap == -1)\n                    return \"printMargin\";\n                if (!this.getWrapLimitRange().min)\n                    return \"free\";\n                return this.$wrap;\n            }\n            return \"off\";\n        },\n        handlesSet: true\n    },    \n    wrapMethod: {\n        set: function(val) {\n            val = val == \"auto\"\n                ? this.$mode.type != \"text\"\n                : val != \"text\";\n            if (val != this.$wrapAsCode) {\n                this.$wrapAsCode = val;\n                if (this.$useWrapMode) {\n                    this.$useWrapMode = false;\n                    this.setUseWrapMode(true);\n                }\n            }\n        },\n        initialValue: \"auto\"\n    },\n    indentedSoftWrap: {\n        set: function() {\n            if (this.$useWrapMode) {\n                this.$useWrapMode = false;\n                this.setUseWrapMode(true);\n            }\n        },\n        initialValue: true \n    },\n    firstLineNumber: {\n        set: function() {this._signal(\"changeBreakpoint\");},\n        initialValue: 1\n    },\n    useWorker: {\n        set: function(useWorker) {\n            this.$useWorker = useWorker;\n\n            this.$stopWorker();\n            if (useWorker)\n                this.$startWorker();\n        },\n        initialValue: true\n    },\n    useSoftTabs: {initialValue: true},\n    tabSize: {\n        set: function(tabSize) {\n            tabSize = parseInt(tabSize);\n            if (isNaN(tabSize) || this.$tabSize === tabSize) return;\n\n            this.$modified = true;\n            this.$rowLengthCache = [];\n            this.$tabSize = tabSize;\n            this._signal(\"changeTabSize\");\n        },\n        initialValue: 4,\n        handlesSet: true\n    },\n    navigateWithinSoftTabs: {initialValue: false},\n    foldStyle: {\n        set: function(val) {this.setFoldStyle(val);},\n        handlesSet: true\n    },\n    overwrite: {\n        set: function(val) {this._signal(\"changeOverwrite\");},\n        initialValue: false\n    },\n    newLineMode: {\n        set: function(val) {this.doc.setNewLineMode(val);},\n        get: function() {return this.doc.getNewLineMode();},\n        handlesSet: true\n    },\n    mode: {\n        set: function(val) { this.setMode(val); },\n        get: function() { return this.$modeId; },\n        handlesSet: true\n    }\n});\n\nexports.EditSession = EditSession;\n});\n\nace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar Search = function() {\n    this.$options = {};\n};\n\n(function() {\n    this.set = function(options) {\n        oop.mixin(this.$options, options);\n        return this;\n    };\n    this.getOptions = function() {\n        return lang.copyObject(this.$options);\n    };\n    this.setOptions = function(options) {\n        this.$options = options;\n    };\n    this.find = function(session) {\n        var options = this.$options;\n        var iterator = this.$matchIterator(session, options);\n        if (!iterator)\n            return false;\n\n        var firstRange = null;\n        iterator.forEach(function(sr, sc, er, ec) {\n            firstRange = new Range(sr, sc, er, ec);\n            if (sc == ec && options.start && options.start.start\n                && options.skipCurrent != false && firstRange.isEqual(options.start)\n            ) {\n                firstRange = null;\n                return false;\n            }\n            \n            return true;\n        });\n\n        return firstRange;\n    };\n    this.findAll = function(session) {\n        var options = this.$options;\n        if (!options.needle)\n            return [];\n        this.$assembleRegExp(options);\n\n        var range = options.range;\n        var lines = range\n            ? session.getLines(range.start.row, range.end.row)\n            : session.doc.getAllLines();\n\n        var ranges = [];\n        var re = options.re;\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var maxRow = lines.length - len;\n            var prevRange;\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n                for (var j = 0; j < len; j++)\n                    if (lines[row + j].search(re[j]) == -1)\n                        continue outer;\n                \n                var startLine = lines[row];\n                var line = lines[row + len - 1];\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n                var endIndex = line.match(re[len - 1])[0].length;\n                \n                if (prevRange && prevRange.end.row === row &&\n                    prevRange.end.column > startIndex\n                ) {\n                    continue;\n                }\n                ranges.push(prevRange = new Range(\n                    row, startIndex, row + len - 1, endIndex\n                ));\n                if (len > 2)\n                    row = row + len - 2;\n            }\n        } else {\n            for (var i = 0; i < lines.length; i++) {\n                var matches = lang.getMatchOffsets(lines[i], re);\n                for (var j = 0; j < matches.length; j++) {\n                    var match = matches[j];\n                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n                }\n            }\n        }\n\n        if (range) {\n            var startColumn = range.start.column;\n            var endColumn = range.start.column;\n            var i = 0, j = ranges.length - 1;\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)\n                i++;\n\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)\n                j--;\n            \n            ranges = ranges.slice(i, j + 1);\n            for (i = 0, j = ranges.length; i < j; i++) {\n                ranges[i].start.row += range.start.row;\n                ranges[i].end.row += range.start.row;\n            }\n        }\n\n        return ranges;\n    };\n    this.replace = function(input, replacement) {\n        var options = this.$options;\n\n        var re = this.$assembleRegExp(options);\n        if (options.$isMultiLine)\n            return replacement;\n\n        if (!re)\n            return;\n\n        var match = re.exec(input);\n        if (!match || match[0].length != input.length)\n            return null;\n        \n        replacement = input.replace(re, replacement);\n        if (options.preserveCase) {\n            replacement = replacement.split(\"\");\n            for (var i = Math.min(input.length, input.length); i--; ) {\n                var ch = input[i];\n                if (ch && ch.toLowerCase() != ch)\n                    replacement[i] = replacement[i].toUpperCase();\n                else\n                    replacement[i] = replacement[i].toLowerCase();\n            }\n            replacement = replacement.join(\"\");\n        }\n        \n        return replacement;\n    };\n\n    this.$assembleRegExp = function(options, $disableFakeMultiline) {\n        if (options.needle instanceof RegExp)\n            return options.re = options.needle;\n\n        var needle = options.needle;\n\n        if (!options.needle)\n            return options.re = false;\n\n        if (!options.regExp)\n            needle = lang.escapeRegExp(needle);\n\n        if (options.wholeWord)\n            needle = addWordBoundary(needle, options);\n\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n        if (options.$isMultiLine)\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n\n        try {\n            var re = new RegExp(needle, modifier);\n        } catch(e) {\n            re = false;\n        }\n        return options.re = re;\n    };\n\n    this.$assembleMultilineRegExp = function(needle, modifier) {\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n        var re = [];\n        for (var i = 0; i < parts.length; i++) try {\n            re.push(new RegExp(parts[i], modifier));\n        } catch(e) {\n            return false;\n        }\n        return re;\n    };\n\n    this.$matchIterator = function(session, options) {\n        var re = this.$assembleRegExp(options);\n        if (!re)\n            return false;\n        var backwards = options.backwards == true;\n        var skipCurrent = options.skipCurrent != false;\n\n        var range = options.range;\n        var start = options.start;\n        if (!start)\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n         \n        if (start.start)\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n\n        var firstRow = range ? range.start.row : 0;\n        var lastRow = range ? range.end.row : session.getLength() - 1;\n        \n        if (backwards) {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row--; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n            };\n        }\n        else {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row = row + 1; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n            };\n        }\n        \n        if (options.$isMultiLine) {\n            var len = re.length;\n            var forEachInLine = function(row, offset, callback) {\n                var startRow = backwards ? row - len + 1 : row;\n                if (startRow < 0) return;\n                var line = session.getLine(startRow);\n                var startIndex = line.search(re[0]);\n                if (!backwards && startIndex < offset || startIndex === -1) return;\n                for (var i = 1; i < len; i++) {\n                    line = session.getLine(startRow + i);\n                    if (line.search(re[i]) == -1)\n                        return;\n                }\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (backwards && endIndex > offset) return;\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\n                    return true;\n            };\n        }\n        else if (backwards) {\n            var forEachInLine = function(row, endIndex, callback) {\n                var line = session.getLine(row);\n                var matches = [];\n                var m, last = 0;\n                re.lastIndex = 0;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (!length) {\n                        if (last >= line.length) break;\n                        re.lastIndex = last += 1;\n                    }\n                    if (m.index + length > endIndex)\n                        break;\n                    matches.push(m.index, length);\n                }\n                for (var i = matches.length - 1; i >= 0; i -= 2) {\n                    var column = matches[i - 1];\n                    var length = matches[i];\n                    if (callback(row, column, row, column + length))\n                        return true;\n                }\n            };\n        }\n        else {\n            var forEachInLine = function(row, startIndex, callback) {\n                var line = session.getLine(row);\n                var last;\n                var m;\n                re.lastIndex = startIndex;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (callback(row, last, row,last + length))\n                        return true;\n                    if (!length) {\n                        re.lastIndex = last += 1;\n                        if (last >= line.length) return false;\n                    }\n                }\n            };\n        }\n        return {forEach: forEach};\n    };\n\n}).call(Search.prototype);\n\nfunction addWordBoundary(needle, options) {\n    function wordBoundary(c) {\n        if (/\\w/.test(c) || options.regExp) return \"\\\\b\";\n        return \"\";\n    }\n    return wordBoundary(needle[0]) + needle\n        + wordBoundary(needle[needle.length - 1]);\n}\n\nexports.Search = Search;\n});\n\nace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil = require(\"../lib/keys\");\nvar useragent = require(\"../lib/useragent\");\nvar KEY_MODS = keyUtil.KEY_MODS;\n\nfunction HashHandler(config, platform) {\n    this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n    this.commands = {};\n    this.commandKeyBinding = {};\n    this.addCommands(config);\n    this.$singleCommand = true;\n}\n\nfunction MultiHashHandler(config, platform) {\n    HashHandler.call(this, config, platform);\n    this.$singleCommand = false;\n}\n\nMultiHashHandler.prototype = HashHandler.prototype;\n\n(function() {\n    \n\n    this.addCommand = function(command) {\n        if (this.commands[command.name])\n            this.removeCommand(command);\n\n        this.commands[command.name] = command;\n\n        if (command.bindKey)\n            this._buildKeyHash(command);\n    };\n\n    this.removeCommand = function(command, keepCommand) {\n        var name = command && (typeof command === 'string' ? command : command.name);\n        command = this.commands[name];\n        if (!keepCommand)\n            delete this.commands[name];\n        var ckb = this.commandKeyBinding;\n        for (var keyId in ckb) {\n            var cmdGroup = ckb[keyId];\n            if (cmdGroup == command) {\n                delete ckb[keyId];\n            } else if (Array.isArray(cmdGroup)) {\n                var i = cmdGroup.indexOf(command);\n                if (i != -1) {\n                    cmdGroup.splice(i, 1);\n                    if (cmdGroup.length == 1)\n                        ckb[keyId] = cmdGroup[0];\n                }\n            }\n        }\n    };\n\n    this.bindKey = function(key, command, position) {\n        if (typeof key == \"object\" && key) {\n            if (position == undefined)\n                position = key.position;\n            key = key[this.platform];\n        }\n        if (!key)\n            return;\n        if (typeof command == \"function\")\n            return this.addCommand({exec: command, bindKey: key, name: command.name || key});\n        \n        key.split(\"|\").forEach(function(keyPart) {\n            var chain = \"\";\n            if (keyPart.indexOf(\" \") != -1) {\n                var parts = keyPart.split(/\\s+/);\n                keyPart = parts.pop();\n                parts.forEach(function(keyPart) {\n                    var binding = this.parseKeys(keyPart);\n                    var id = KEY_MODS[binding.hashId] + binding.key;\n                    chain += (chain ? \" \" : \"\") + id;\n                    this._addCommandToBinding(chain, \"chainKeys\");\n                }, this);\n                chain += \" \";\n            }\n            var binding = this.parseKeys(keyPart);\n            var id = KEY_MODS[binding.hashId] + binding.key;\n            this._addCommandToBinding(chain + id, command, position);\n        }, this);\n    };\n    \n    function getPosition(command) {\n        return typeof command == \"object\" && command.bindKey\n            && command.bindKey.position \n            || (command.isDefault ? -100 : 0);\n    }\n    this._addCommandToBinding = function(keyId, command, position) {\n        var ckb = this.commandKeyBinding, i;\n        if (!command) {\n            delete ckb[keyId];\n        } else if (!ckb[keyId] || this.$singleCommand) {\n            ckb[keyId] = command;\n        } else {\n            if (!Array.isArray(ckb[keyId])) {\n                ckb[keyId] = [ckb[keyId]];\n            } else if ((i = ckb[keyId].indexOf(command)) != -1) {\n                ckb[keyId].splice(i, 1);\n            }\n            \n            if (typeof position != \"number\") {\n                position = getPosition(command);\n            }\n\n            var commands = ckb[keyId];\n            for (i = 0; i < commands.length; i++) {\n                var other = commands[i];\n                var otherPos = getPosition(other);\n                if (otherPos > position)\n                    break;\n            }\n            commands.splice(i, 0, command);\n        }\n    };\n\n    this.addCommands = function(commands) {\n        commands && Object.keys(commands).forEach(function(name) {\n            var command = commands[name];\n            if (!command)\n                return;\n            \n            if (typeof command === \"string\")\n                return this.bindKey(command, name);\n\n            if (typeof command === \"function\")\n                command = { exec: command };\n\n            if (typeof command !== \"object\")\n                return;\n\n            if (!command.name)\n                command.name = name;\n\n            this.addCommand(command);\n        }, this);\n    };\n\n    this.removeCommands = function(commands) {\n        Object.keys(commands).forEach(function(name) {\n            this.removeCommand(commands[name]);\n        }, this);\n    };\n\n    this.bindKeys = function(keyList) {\n        Object.keys(keyList).forEach(function(key) {\n            this.bindKey(key, keyList[key]);\n        }, this);\n    };\n\n    this._buildKeyHash = function(command) {\n        this.bindKey(command.bindKey, command);\n    };\n    this.parseKeys = function(keys) {\n        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function(x){return x;});\n        var key = parts.pop();\n\n        var keyCode = keyUtil[key];\n        if (keyUtil.FUNCTION_KEYS[keyCode])\n            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n        else if (!parts.length)\n            return {key: key, hashId: -1};\n        else if (parts.length == 1 && parts[0] == \"shift\")\n            return {key: key.toUpperCase(), hashId: -1};\n\n        var hashId = 0;\n        for (var i = parts.length; i--;) {\n            var modifier = keyUtil.KEY_MODS[parts[i]];\n            if (modifier == null) {\n                if (typeof console != \"undefined\")\n                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n                return false;\n            }\n            hashId |= modifier;\n        }\n        return {key: key, hashId: hashId};\n    };\n\n    this.findKeyCommand = function findKeyCommand(hashId, keyString) {\n        var key = KEY_MODS[hashId] + keyString;\n        return this.commandKeyBinding[key];\n    };\n\n    this.handleKeyboard = function(data, hashId, keyString, keyCode) {\n        if (keyCode < 0) return;\n        var key = KEY_MODS[hashId] + keyString;\n        var command = this.commandKeyBinding[key];\n        if (data.$keyChain) {\n            data.$keyChain += \" \" + key;\n            command = this.commandKeyBinding[data.$keyChain] || command;\n        }\n        \n        if (command) {\n            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n                data.$keyChain = data.$keyChain || key;\n                return {command: \"null\"};\n            }\n        }\n        \n        if (data.$keyChain) {\n            if ((!hashId || hashId == 4) && keyString.length == 1)\n                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input\n            else if (hashId == -1 || keyCode > 0)\n                data.$keyChain = \"\"; // reset keyChain\n        }\n        return {command: command};\n    };\n    \n    this.getStatusText = function(editor, data) {\n        return data.$keyChain || \"\";\n    };\n\n}).call(HashHandler.prototype);\n\nexports.HashHandler = HashHandler;\nexports.MultiHashHandler = MultiHashHandler;\n});\n\nace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar MultiHashHandler = require(\"../keyboard/hash_handler\").MultiHashHandler;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CommandManager = function(platform, commands) {\n    MultiHashHandler.call(this, commands, platform);\n    this.byName = this.commands;\n    this.setDefaultHandler(\"exec\", function(e) {\n        return e.command.exec(e.editor, e.args || {});\n    });\n};\n\noop.inherits(CommandManager, MultiHashHandler);\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.exec = function(command, editor, args) {\n        if (Array.isArray(command)) {\n            for (var i = command.length; i--; ) {\n                if (this.exec(command[i], editor, args)) return true;\n            }\n            return false;\n        }\n\n        if (typeof command === \"string\")\n            command = this.commands[command];\n\n        if (!command)\n            return false;\n\n        if (editor && editor.$readOnly && !command.readOnly)\n            return false;\n\n        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))\n            return false;\n\n        var e = {editor: editor, command: command, args: args};\n        e.returnValue = this._emit(\"exec\", e);\n        this._signal(\"afterExec\", e);\n\n        return e.returnValue === false ? false : true;\n    };\n\n    this.toggleRecording = function(editor) {\n        if (this.$inReplay)\n            return;\n\n        editor && editor._emit(\"changeStatus\");\n        if (this.recording) {\n            this.macro.pop();\n            this.removeEventListener(\"exec\", this.$addCommandToMacro);\n\n            if (!this.macro.length)\n                this.macro = this.oldMacro;\n\n            return this.recording = false;\n        }\n        if (!this.$addCommandToMacro) {\n            this.$addCommandToMacro = function(e) {\n                this.macro.push([e.command, e.args]);\n            }.bind(this);\n        }\n\n        this.oldMacro = this.macro;\n        this.macro = [];\n        this.on(\"exec\", this.$addCommandToMacro);\n        return this.recording = true;\n    };\n\n    this.replay = function(editor) {\n        if (this.$inReplay || !this.macro)\n            return;\n\n        if (this.recording)\n            return this.toggleRecording(editor);\n\n        try {\n            this.$inReplay = true;\n            this.macro.forEach(function(x) {\n                if (typeof x == \"string\")\n                    this.exec(x, editor);\n                else\n                    this.exec(x[0], editor, x[1]);\n            }, this);\n        } finally {\n            this.$inReplay = false;\n        }\n    };\n\n    this.trimMacro = function(m) {\n        return m.map(function(x){\n            if (typeof x[0] != \"string\")\n                x[0] = x[0].name;\n            if (!x[1])\n                x = x[0];\n            return x;\n        });\n    };\n\n}).call(CommandManager.prototype);\n\nexports.CommandManager = CommandManager;\n\n});\n\nace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\nvar config = require(\"../config\");\nvar Range = require(\"../range\").Range;\n\nfunction bindKey(win, mac) {\n    return {win: win, mac: mac};\n}\nexports.commands = [{\n    name: \"showSettingsMenu\",\n    bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/settings_menu\", function(module) {\n            module.init(editor);\n            editor.showSettingsMenu();\n        });\n    },\n    readOnly: true\n}, {\n    name: \"goToNextError\",\n    bindKey: bindKey(\"Alt-E\", \"F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, 1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"goToPreviousError\",\n    bindKey: bindKey(\"Alt-Shift-E\", \"Shift-F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, -1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selectall\",\n    description: \"Select all\",\n    bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n    exec: function(editor) { editor.selectAll(); },\n    readOnly: true\n}, {\n    name: \"centerselection\",\n    description: \"Center selection\",\n    bindKey: bindKey(null, \"Ctrl-L\"),\n    exec: function(editor) { editor.centerSelection(); },\n    readOnly: true\n}, {\n    name: \"gotoline\",\n    description: \"Go to line...\",\n    bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n    exec: function(editor, line) {\n        if (typeof line === \"number\" && !isNaN(line))\n            editor.gotoLine(line);\n        editor.prompt({ $type: \"gotoLine\" });\n    },\n    readOnly: true\n}, {\n    name: \"fold\",\n    bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n    exec: function(editor) { editor.session.toggleFold(false); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfold\",\n    bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n    exec: function(editor) { editor.session.toggleFold(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleFoldWidget\",\n    bindKey: bindKey(\"F2\", \"F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleParentFoldWidget\",\n    bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldall\",\n    description: \"Fold all\",\n    bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n    exec: function(editor) { editor.session.foldAll(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldOther\",\n    description: \"Fold other\",\n    bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n    exec: function(editor) { \n        editor.session.foldAll();\n        editor.session.unfold(editor.selection.getAllRanges());\n    },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfoldall\",\n    description: \"Unfold all\",\n    bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n    exec: function(editor) { editor.session.unfold(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findnext\",\n    description: \"Find next\",\n    bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n    exec: function(editor) { editor.findNext(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findprevious\",\n    description: \"Find previous\",\n    bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n    exec: function(editor) { editor.findPrevious(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"selectOrFindNext\",\n    description: \"Select or find next\",\n    bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n    exec: function(editor) {\n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findNext(); \n    },\n    readOnly: true\n}, {\n    name: \"selectOrFindPrevious\",\n    description: \"Select or find previous\",\n    bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n    exec: function(editor) { \n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findPrevious();\n    },\n    readOnly: true\n}, {\n    name: \"find\",\n    description: \"Find\",\n    bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor);});\n    },\n    readOnly: true\n}, {\n    name: \"overwrite\",\n    description: \"Overwrite\",\n    bindKey: \"Insert\",\n    exec: function(editor) { editor.toggleOverwrite(); },\n    readOnly: true\n}, {\n    name: \"selecttostart\",\n    description: \"Select to start\",\n    bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Home|Command-Shift-Up\"),\n    exec: function(editor) { editor.getSelection().selectFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotostart\",\n    description: \"Go to start\",\n    bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n    exec: function(editor) { editor.navigateFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectup\",\n    description: \"Select up\",\n    bindKey: bindKey(\"Shift-Up\", \"Shift-Up|Ctrl-Shift-P\"),\n    exec: function(editor) { editor.getSelection().selectUp(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golineup\",\n    description: \"Go line up\",\n    bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n    exec: function(editor, args) { editor.navigateUp(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttoend\",\n    description: \"Select to end\",\n    bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-End|Command-Shift-Down\"),\n    exec: function(editor) { editor.getSelection().selectFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotoend\",\n    description: \"Go to end\",\n    bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n    exec: function(editor) { editor.navigateFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectdown\",\n    description: \"Select down\",\n    bindKey: bindKey(\"Shift-Down\", \"Shift-Down|Ctrl-Shift-N\"),\n    exec: function(editor) { editor.getSelection().selectDown(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golinedown\",\n    description: \"Go line down\",\n    bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n    exec: function(editor, args) { editor.navigateDown(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordleft\",\n    description: \"Select word left\",\n    bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n    exec: function(editor) { editor.getSelection().selectWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordleft\",\n    description: \"Go to word left\",\n    bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n    exec: function(editor) { editor.navigateWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolinestart\",\n    description: \"Select to line start\",\n    bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left|Ctrl-Shift-A\"),\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolinestart\",\n    description: \"Go to line start\",\n    bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n    exec: function(editor) { editor.navigateLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectleft\",\n    description: \"Select left\",\n    bindKey: bindKey(\"Shift-Left\", \"Shift-Left|Ctrl-Shift-B\"),\n    exec: function(editor) { editor.getSelection().selectLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoleft\",\n    description: \"Go to left\",\n    bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n    exec: function(editor, args) { editor.navigateLeft(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordright\",\n    description: \"Select word right\",\n    bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordright\",\n    description: \"Go to word right\",\n    bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n    exec: function(editor) { editor.navigateWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolineend\",\n    description: \"Select to line end\",\n    bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right|Shift-End|Ctrl-Shift-E\"),\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolineend\",\n    description: \"Go to line end\",\n    bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n    exec: function(editor) { editor.navigateLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectright\",\n    description: \"Select right\",\n    bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoright\",\n    description: \"Go to right\",\n    bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n    exec: function(editor, args) { editor.navigateRight(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectpagedown\",\n    description: \"Select page down\",\n    bindKey: \"Shift-PageDown\",\n    exec: function(editor) { editor.selectPageDown(); },\n    readOnly: true\n}, {\n    name: \"pagedown\",\n    description: \"Page down\",\n    bindKey: bindKey(null, \"Option-PageDown\"),\n    exec: function(editor) { editor.scrollPageDown(); },\n    readOnly: true\n}, {\n    name: \"gotopagedown\",\n    description: \"Go to page down\",\n    bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n    exec: function(editor) { editor.gotoPageDown(); },\n    readOnly: true\n}, {\n    name: \"selectpageup\",\n    description: \"Select page up\",\n    bindKey: \"Shift-PageUp\",\n    exec: function(editor) { editor.selectPageUp(); },\n    readOnly: true\n}, {\n    name: \"pageup\",\n    description: \"Page up\",\n    bindKey: bindKey(null, \"Option-PageUp\"),\n    exec: function(editor) { editor.scrollPageUp(); },\n    readOnly: true\n}, {\n    name: \"gotopageup\",\n    description: \"Go to page up\",\n    bindKey: \"PageUp\",\n    exec: function(editor) { editor.gotoPageUp(); },\n    readOnly: true\n}, {\n    name: \"scrollup\",\n    description: \"Scroll up\",\n    bindKey: bindKey(\"Ctrl-Up\", null),\n    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"scrolldown\",\n    description: \"Scroll down\",\n    bindKey: bindKey(\"Ctrl-Down\", null),\n    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"selectlinestart\",\n    description: \"Select line start\",\n    bindKey: \"Shift-Home\",\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectlineend\",\n    description: \"Select line end\",\n    bindKey: \"Shift-End\",\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"togglerecording\",\n    description: \"Toggle recording\",\n    bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n    exec: function(editor) { editor.commands.toggleRecording(editor); },\n    readOnly: true\n}, {\n    name: \"replaymacro\",\n    description: \"Replay macro\",\n    bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n    exec: function(editor) { editor.commands.replay(editor); },\n    readOnly: true\n}, {\n    name: \"jumptomatching\",\n    description: \"Jump to matching\",\n    bindKey: bindKey(\"Ctrl-P\", \"Ctrl-P\"),\n    exec: function(editor) { editor.jumpToMatching(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selecttomatching\",\n    description: \"Select to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-P\", \"Ctrl-Shift-P\"),\n    exec: function(editor) { editor.jumpToMatching(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"expandToMatching\",\n    description: \"Expand to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-M\", \"Ctrl-Shift-M\"),\n    exec: function(editor) { editor.jumpToMatching(true, true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"passKeysToBrowser\",\n    description: \"Pass keys to browser\",\n    bindKey: bindKey(null, null),\n    exec: function() {},\n    passEvent: true,\n    readOnly: true\n}, {\n    name: \"copy\",\n    description: \"Copy\",\n    exec: function(editor) {\n    },\n    readOnly: true\n},\n{\n    name: \"cut\",\n    description: \"Cut\",\n    exec: function(editor) {\n        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();\n        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();\n        editor._emit(\"cut\", range);\n\n        if (!range.isEmpty())\n            editor.session.remove(range);\n        editor.clearSelection();\n    },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"paste\",\n    description: \"Paste\",\n    exec: function(editor, args) {\n        editor.$handlePaste(args);\n    },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removeline\",\n    description: \"Remove line\",\n    bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n    exec: function(editor) { editor.removeLines(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"duplicateSelection\",\n    description: \"Duplicate selection\",\n    bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n    exec: function(editor) { editor.duplicateSelection(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"sortlines\",\n    description: \"Sort lines\",\n    bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n    exec: function(editor) { editor.sortLines(); },\n    scrollIntoView: \"selection\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"togglecomment\",\n    description: \"Toggle comment\",\n    bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n    exec: function(editor) { editor.toggleCommentLines(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"toggleBlockComment\",\n    description: \"Toggle block comment\",\n    bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n    exec: function(editor) { editor.toggleBlockComment(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"modifyNumberUp\",\n    description: \"Modify number up\",\n    bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n    exec: function(editor) { editor.modifyNumber(1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"modifyNumberDown\",\n    description: \"Modify number down\",\n    bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n    exec: function(editor) { editor.modifyNumber(-1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"replace\",\n    description: \"Replace\",\n    bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor, true);});\n    }\n}, {\n    name: \"undo\",\n    description: \"Undo\",\n    bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n    exec: function(editor) { editor.undo(); }\n}, {\n    name: \"redo\",\n    description: \"Redo\",\n    bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n    exec: function(editor) { editor.redo(); }\n}, {\n    name: \"copylinesup\",\n    description: \"Copy lines up\",\n    bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n    exec: function(editor) { editor.copyLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesup\",\n    description: \"Move lines up\",\n    bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n    exec: function(editor) { editor.moveLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"copylinesdown\",\n    description: \"Copy lines down\",\n    bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n    exec: function(editor) { editor.copyLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesdown\",\n    description: \"Move lines down\",\n    bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n    exec: function(editor) { editor.moveLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"del\",\n    description: \"Delete\",\n    bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n    exec: function(editor) { editor.remove(\"right\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"backspace\",\n    description: \"Backspace\",\n    bindKey: bindKey(\n        \"Shift-Backspace|Backspace\",\n        \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"\n    ),\n    exec: function(editor) { editor.remove(\"left\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"cut_or_delete\",\n    description: \"Cut or delete\",\n    bindKey: bindKey(\"Shift-Delete\", null),\n    exec: function(editor) { \n        if (editor.selection.isEmpty()) {\n            editor.remove(\"left\");\n        } else {\n            return false;\n        }\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestart\",\n    description: \"Remove to line start\",\n    bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n    exec: function(editor) { editor.removeToLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineend\",\n    description: \"Remove to line end\",\n    bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K|Command-Delete\"),\n    exec: function(editor) { editor.removeToLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestarthard\",\n    description: \"Remove to line start hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Backspace\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.start.column = 0;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineendhard\",\n    description: \"Remove to line end hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Delete\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.end.column = Number.MAX_VALUE;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordleft\",\n    description: \"Remove word left\",\n    bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n    exec: function(editor) { editor.removeWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordright\",\n    description: \"Remove word right\",\n    bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n    exec: function(editor) { editor.removeWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"outdent\",\n    description: \"Outdent\",\n    bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"indent\",\n    description: \"Indent\",\n    bindKey: bindKey(\"Tab\", \"Tab\"),\n    exec: function(editor) { editor.indent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockoutdent\",\n    description: \"Block outdent\",\n    bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockindent\",\n    description: \"Block indent\",\n    bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n    exec: function(editor) { editor.blockIndent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"insertstring\",\n    description: \"Insert string\",\n    exec: function(editor, str) { editor.insert(str); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"inserttext\",\n    description: \"Insert text\",\n    exec: function(editor, args) {\n        editor.insert(lang.stringRepeat(args.text  || \"\", args.times || 1));\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"splitline\",\n    description: \"Split line\",\n    bindKey: bindKey(null, \"Ctrl-O\"),\n    exec: function(editor) { editor.splitLine(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"transposeletters\",\n    description: \"Transpose letters\",\n    bindKey: bindKey(\"Alt-Shift-X\", \"Ctrl-T\"),\n    exec: function(editor) { editor.transposeLetters(); },\n    multiSelectAction: function(editor) {editor.transposeSelections(1); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"touppercase\",\n    description: \"To uppercase\",\n    bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n    exec: function(editor) { editor.toUpperCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"tolowercase\",\n    description: \"To lowercase\",\n    bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n    exec: function(editor) { editor.toLowerCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"expandtoline\",\n    description: \"Expand to line\",\n    bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n\n        range.start.column = range.end.column = 0;\n        range.end.row++;\n        editor.selection.setRange(range, false);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"joinlines\",\n    description: \"Join lines\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var isBackwards = editor.selection.isBackwards();\n        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;\n        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n        var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n        var insertLine = editor.session.doc.getLine(selectionStart.row);\n\n        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n            if (curLine.length !== 0) {\n                curLine = \" \" + curLine;\n            }\n            insertLine += curLine;\n        }\n\n        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n            insertLine += editor.session.doc.getNewLineCharacter();\n        }\n\n        editor.clearSelection();\n        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n\n        if (selectedCount > 0) {\n            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n        } else {\n            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n        }\n    },\n    multiSelectAction: \"forEach\",\n    readOnly: true\n}, {\n    name: \"invertSelection\",\n    description: \"Invert selection\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var endRow = editor.session.doc.getLength() - 1;\n        var endCol = editor.session.doc.getLine(endRow).length;\n        var ranges = editor.selection.rangeList.ranges;\n        var newRanges = [];\n        if (ranges.length < 1) {\n            ranges = [editor.selection.getRange()];\n        }\n\n        for (var i = 0; i < ranges.length; i++) {\n            if (i == (ranges.length - 1)) {\n                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n                }\n            }\n\n            if (i === 0) {\n                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n                }\n            } else {\n                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));\n            }\n        }\n\n        editor.exitMultiSelectMode();\n        editor.clearSelection();\n\n        for(var i = 0; i < newRanges.length; i++) {\n            editor.selection.addRange(newRanges[i], false);\n        }\n    },\n    readOnly: true,\n    scrollIntoView: \"none\"\n}, {\n    name: \"openCommandPallete\",\n    description: \"Open command pallete\",\n    bindKey: bindKey(\"F1\", \"F1\"),\n    exec: function(editor) {\n        editor.prompt({ $type: \"commands\" });\n    },\n    readOnly: true\n}, {\n    name: \"modeSelect\",\n    description: \"Change language mode...\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        editor.prompt({ $type: \"modes\" });\n    },\n    readOnly: true\n}];\n\n});\n\nace.define(\"ace/clipboard\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nmodule.exports = { lineMode: false };\n\n});\n\nace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\",\"ace/clipboard\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar useragent = require(\"./lib/useragent\");\nvar TextInput = require(\"./keyboard/textinput\").TextInput;\nvar MouseHandler = require(\"./mouse/mouse_handler\").MouseHandler;\nvar FoldHandler = require(\"./mouse/fold_handler\").FoldHandler;\nvar KeyBinding = require(\"./keyboard/keybinding\").KeyBinding;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Search = require(\"./search\").Search;\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar CommandManager = require(\"./commands/command_manager\").CommandManager;\nvar defaultCommands = require(\"./commands/default_commands\").commands;\nvar config = require(\"./config\");\nvar TokenIterator = require(\"./token_iterator\").TokenIterator;\n\nvar clipboard = require(\"./clipboard\");\nvar Editor = function(renderer, session, options) {\n    var container = renderer.getContainerElement();\n    this.container = container;\n    this.renderer = renderer;\n    this.id = \"editor\" + (++Editor.$uid);\n\n    this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n    if (typeof document == \"object\") {\n        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);\n        this.renderer.textarea = this.textInput.getElement();\n        this.$mouseHandler = new MouseHandler(this);\n        new FoldHandler(this);\n    }\n\n    this.keyBinding = new KeyBinding(this);\n\n    this.$search = new Search().set({\n        wrap: true\n    });\n\n    this.$historyTracker = this.$historyTracker.bind(this);\n    this.commands.on(\"exec\", this.$historyTracker);\n\n    this.$initOperationListeners();\n    \n    this._$emitInputEvent = lang.delayedCall(function() {\n        this._signal(\"input\", {});\n        if (this.session && this.session.bgTokenizer)\n            this.session.bgTokenizer.scheduleStart();\n    }.bind(this));\n    \n    this.on(\"change\", function(_, _self) {\n        _self._$emitInputEvent.schedule(31);\n    });\n\n    this.setSession(session || options && options.session || new EditSession(\"\"));\n    config.resetOptions(this);\n    if (options)\n        this.setOptions(options);\n    config._signal(\"editor\", this);\n};\n\nEditor.$uid = 0;\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$initOperationListeners = function() {\n        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n\n        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));\n        this.on(\"change\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.docChanged = true;\n        }.bind(this), true);\n        \n        this.on(\"changeSelection\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.selectionChanged = true;\n        }.bind(this), true);\n    };\n\n    this.curOp = null;\n    this.prevOp = {};\n    this.startOperation = function(commandEvent) {\n        if (this.curOp) {\n            if (!commandEvent || this.curOp.command)\n                return;\n            this.prevOp = this.curOp;\n        }\n        if (!commandEvent) {\n            this.previousCommand = null;\n            commandEvent = {};\n        }\n\n        this.$opResetTimer.schedule();\n        this.curOp = this.session.curOp = {\n            command: commandEvent.command || {},\n            args: commandEvent.args,\n            scrollTop: this.renderer.scrollTop\n        };\n        this.curOp.selectionBefore = this.selection.toJSON();\n    };\n\n    this.endOperation = function(e) {\n        if (this.curOp) {\n            if (e && e.returnValue === false)\n                return (this.curOp = null);\n            if (e == true && this.curOp.command && this.curOp.command.name == \"mouse\")\n                return;\n            this._signal(\"beforeEndOperation\");\n            if (!this.curOp) return;\n            var command = this.curOp.command;\n            var scrollIntoView = command && command.scrollIntoView;\n            if (scrollIntoView) {\n                switch (scrollIntoView) {\n                    case \"center-animate\":\n                        scrollIntoView = \"animate\";\n                    case \"center\":\n                        this.renderer.scrollCursorIntoView(null, 0.5);\n                        break;\n                    case \"animate\":\n                    case \"cursor\":\n                        this.renderer.scrollCursorIntoView();\n                        break;\n                    case \"selectionPart\":\n                        var range = this.selection.getRange();\n                        var config = this.renderer.layerConfig;\n                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                if (scrollIntoView == \"animate\")\n                    this.renderer.animateScrolling(this.curOp.scrollTop);\n            }\n            var sel = this.selection.toJSON();\n            this.curOp.selectionAfter = sel;\n            this.$lastSel = this.selection.toJSON();\n            this.session.getUndoManager().addSelection(sel);\n            this.prevOp = this.curOp;\n            this.curOp = null;\n        }\n    };\n    this.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\n    this.$historyTracker = function(e) {\n        if (!this.$mergeUndoDeltas)\n            return;\n\n        var prev = this.prevOp;\n        var mergeableCommands = this.$mergeableCommands;\n        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n        if (e.command.name == \"insertstring\") {\n            var text = e.args;\n            if (this.mergeNextCommand === undefined)\n                this.mergeNextCommand = true;\n\n            shouldMerge = shouldMerge\n                && this.mergeNextCommand // previous command allows to coalesce with\n                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n\n            this.mergeNextCommand = true;\n        } else {\n            shouldMerge = shouldMerge\n                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n        }\n\n        if (\n            this.$mergeUndoDeltas != \"always\"\n            && Date.now() - this.sequenceStartTime > 2000\n        ) {\n            shouldMerge = false; // the sequence is too long\n        }\n\n        if (shouldMerge)\n            this.session.mergeUndoDeltas = true;\n        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n            this.sequenceStartTime = Date.now();\n    };\n    this.setKeyboardHandler = function(keyboardHandler, cb) {\n        if (keyboardHandler && typeof keyboardHandler === \"string\" && keyboardHandler != \"ace\") {\n            this.$keybindingId = keyboardHandler;\n            var _self = this;\n            config.loadModule([\"keybinding\", keyboardHandler], function(module) {\n                if (_self.$keybindingId == keyboardHandler)\n                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n                cb && cb();\n            });\n        } else {\n            this.$keybindingId = null;\n            this.keyBinding.setKeyboardHandler(keyboardHandler);\n            cb && cb();\n        }\n    };\n    this.getKeyboardHandler = function() {\n        return this.keyBinding.getKeyboardHandler();\n    };\n    this.setSession = function(session) {\n        if (this.session == session)\n            return;\n        if (this.curOp) this.endOperation();\n        this.curOp = {};\n\n        var oldSession = this.session;\n        if (oldSession) {\n            this.session.off(\"change\", this.$onDocumentChange);\n            this.session.off(\"changeMode\", this.$onChangeMode);\n            this.session.off(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.session.off(\"changeTabSize\", this.$onChangeTabSize);\n            this.session.off(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.session.off(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.session.off(\"changeFold\", this.$onChangeFold);\n            this.session.off(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.session.off(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.session.off(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.session.off(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.session.off(\"changeOverwrite\", this.$onCursorChange);\n            this.session.off(\"changeScrollTop\", this.$onScrollTopChange);\n            this.session.off(\"changeScrollLeft\", this.$onScrollLeftChange);\n\n            var selection = this.session.getSelection();\n            selection.off(\"changeCursor\", this.$onCursorChange);\n            selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n\n        this.session = session;\n        if (session) {\n            this.$onDocumentChange = this.onDocumentChange.bind(this);\n            session.on(\"change\", this.$onDocumentChange);\n            this.renderer.setSession(session);\n    \n            this.$onChangeMode = this.onChangeMode.bind(this);\n            session.on(\"changeMode\", this.$onChangeMode);\n    \n            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n            session.on(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n    \n            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n            session.on(\"changeTabSize\", this.$onChangeTabSize);\n    \n            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n            session.on(\"changeWrapLimit\", this.$onChangeWrapLimit);\n    \n            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n            session.on(\"changeWrapMode\", this.$onChangeWrapMode);\n    \n            this.$onChangeFold = this.onChangeFold.bind(this);\n            session.on(\"changeFold\", this.$onChangeFold);\n    \n            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n            this.session.on(\"changeFrontMarker\", this.$onChangeFrontMarker);\n    \n            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n            this.session.on(\"changeBackMarker\", this.$onChangeBackMarker);\n    \n            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n            this.session.on(\"changeBreakpoint\", this.$onChangeBreakpoint);\n    \n            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n            this.session.on(\"changeAnnotation\", this.$onChangeAnnotation);\n    \n            this.$onCursorChange = this.onCursorChange.bind(this);\n            this.session.on(\"changeOverwrite\", this.$onCursorChange);\n    \n            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n            this.session.on(\"changeScrollTop\", this.$onScrollTopChange);\n    \n            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n            this.session.on(\"changeScrollLeft\", this.$onScrollLeftChange);\n    \n            this.selection = session.getSelection();\n            this.selection.on(\"changeCursor\", this.$onCursorChange);\n    \n            this.$onSelectionChange = this.onSelectionChange.bind(this);\n            this.selection.on(\"changeSelection\", this.$onSelectionChange);\n    \n            this.onChangeMode();\n    \n            this.onCursorChange();\n    \n            this.onScrollTopChange();\n            this.onScrollLeftChange();\n            this.onSelectionChange();\n            this.onChangeFrontMarker();\n            this.onChangeBackMarker();\n            this.onChangeBreakpoint();\n            this.onChangeAnnotation();\n            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n            this.renderer.updateFull();\n        } else {\n            this.selection = null;\n            this.renderer.setSession(session);\n        }\n\n        this._signal(\"changeSession\", {\n            session: session,\n            oldSession: oldSession\n        });\n        \n        this.curOp = null;\n        \n        oldSession && oldSession._signal(\"changeEditor\", {oldEditor: this});\n        session && session._signal(\"changeEditor\", {editor: this});\n        \n        if (session && session.bgTokenizer)\n            session.bgTokenizer.scheduleStart();\n    };\n    this.getSession = function() {\n        return this.session;\n    };\n    this.setValue = function(val, cursorPos) {\n        this.session.doc.setValue(val);\n\n        if (!cursorPos)\n            this.selectAll();\n        else if (cursorPos == 1)\n            this.navigateFileEnd();\n        else if (cursorPos == -1)\n            this.navigateFileStart();\n\n        return val;\n    };\n    this.getValue = function() {\n        return this.session.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.resize = function(force) {\n        this.renderer.onResize(force);\n    };\n    this.setTheme = function(theme, cb) {\n        this.renderer.setTheme(theme, cb);\n    };\n    this.getTheme = function() {\n        return this.renderer.getTheme();\n    };\n    this.setStyle = function(style) {\n        this.renderer.setStyle(style);\n    };\n    this.unsetStyle = function(style) {\n        this.renderer.unsetStyle(style);\n    };\n    this.getFontSize = function () {\n        return this.getOption(\"fontSize\") ||\n           dom.computedStyle(this.container).fontSize;\n    };\n    this.setFontSize = function(size) {\n        this.setOption(\"fontSize\", size);\n    };\n\n    this.$highlightBrackets = function() {\n        if (this.session.$bracketHighlight) {\n            this.session.removeMarker(this.session.$bracketHighlight);\n            this.session.$bracketHighlight = null;\n        }\n\n        if (this.$highlightPending) {\n            return;\n        }\n        var self = this;\n        this.$highlightPending = true;\n        setTimeout(function() {\n            self.$highlightPending = false;\n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            var pos = session.findMatchingBracket(self.getCursorPosition());\n            if (pos) {\n                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);\n            } else if (session.$mode.getMatching) {\n                var range = session.$mode.getMatching(self.session);\n            }\n            if (range)\n                session.$bracketHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n        }, 50);\n    };\n    this.$highlightTags = function() {\n        if (this.$highlightTagPending)\n            return;\n        var self = this;\n        this.$highlightTagPending = true;\n        setTimeout(function() {\n            self.$highlightTagPending = false;\n            \n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            \n            var pos = self.getCursorPosition();\n            var iterator = new TokenIterator(self.session, pos.row, pos.column);\n            var token = iterator.getCurrentToken();\n            \n            if (!token || !/\\b(?:tag-open|tag-name)/.test(token.type)) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            if (token.type.indexOf(\"tag-open\") != -1) {\n                token = iterator.stepForward();\n                if (!token)\n                    return;\n            }\n            \n            var tag = token.value;\n            var depth = 0;\n            var prevToken = iterator.stepBackward();\n            \n            if (prevToken.value == '<'){\n                do {\n                    prevToken = token;\n                    token = iterator.stepForward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<'){\n                            depth++;\n                        } else if (prevToken.value === '</'){\n                            depth--;\n                        }\n                    }\n                    \n                } while (token && depth >= 0);\n            } else {\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                        } else if (prevToken.value === '</') {\n                            depth--;\n                        }\n                    }\n                } while (prevToken && depth <= 0);\n                iterator.stepForward();\n            }\n            \n            if (!token) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            var row = iterator.getCurrentTokenRow();\n            var column = iterator.getCurrentTokenColumn();\n            var range = new Range(row, column, row, column+token.value.length);\n            var sbm = session.$backMarkers[session.$tagHighlight];\n            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n            }\n            \n            if (!session.$tagHighlight)\n                session.$tagHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n        }, 50);\n    };\n    this.focus = function() {\n        var _self = this;\n        setTimeout(function() {\n            if (!_self.isFocused())\n                _self.textInput.focus();\n        });\n        this.textInput.focus();\n    };\n    this.isFocused = function() {\n        return this.textInput.isFocused();\n    };\n    this.blur = function() {\n        this.textInput.blur();\n    };\n    this.onFocus = function(e) {\n        if (this.$isFocused)\n            return;\n        this.$isFocused = true;\n        this.renderer.showCursor();\n        this.renderer.visualizeFocus();\n        this._emit(\"focus\", e);\n    };\n    this.onBlur = function(e) {\n        if (!this.$isFocused)\n            return;\n        this.$isFocused = false;\n        this.renderer.hideCursor();\n        this.renderer.visualizeBlur();\n        this._emit(\"blur\", e);\n    };\n\n    this.$cursorChange = function() {\n        this.renderer.updateCursor();\n    };\n    this.onDocumentChange = function(delta) {\n        var wrap = this.session.$useWrapMode;\n        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);\n        this.renderer.updateLines(delta.start.row, lastRow, wrap);\n\n        this._signal(\"change\", delta);\n        this.$cursorChange();\n        this.$updateHighlightActiveLine();\n    };\n\n    this.onTokenizerUpdate = function(e) {\n        var rows = e.data;\n        this.renderer.updateLines(rows.first, rows.last);\n    };\n\n\n    this.onScrollTopChange = function() {\n        this.renderer.scrollToY(this.session.getScrollTop());\n    };\n\n    this.onScrollLeftChange = function() {\n        this.renderer.scrollToX(this.session.getScrollLeft());\n    };\n    this.onCursorChange = function() {\n        this.$cursorChange();\n\n        this.$highlightBrackets();\n        this.$highlightTags();\n        this.$updateHighlightActiveLine();\n        this._signal(\"changeSelection\");\n    };\n\n    this.$updateHighlightActiveLine = function() {\n        var session = this.getSession();\n\n        var highlight;\n        if (this.$highlightActiveLine) {\n            if (this.$selectionStyle != \"line\" || !this.selection.isMultiLine())\n                highlight = this.getCursorPosition();\n            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())\n                highlight = false;\n            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n                highlight = false;\n        }\n\n        if (session.$highlightLineMarker && !highlight) {\n            session.removeMarker(session.$highlightLineMarker.id);\n            session.$highlightLineMarker = null;\n        } else if (!session.$highlightLineMarker && highlight) {\n            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n            session.$highlightLineMarker = range;\n        } else if (highlight) {\n            session.$highlightLineMarker.start.row = highlight.row;\n            session.$highlightLineMarker.end.row = highlight.row;\n            session.$highlightLineMarker.start.column = highlight.column;\n            session._signal(\"changeBackMarker\");\n        }\n    };\n\n    this.onSelectionChange = function(e) {\n        var session = this.session;\n\n        if (session.$selectionMarker) {\n            session.removeMarker(session.$selectionMarker);\n        }\n        session.$selectionMarker = null;\n\n        if (!this.selection.isEmpty()) {\n            var range = this.selection.getRange();\n            var style = this.getSelectionStyle();\n            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n        } else {\n            this.$updateHighlightActiveLine();\n        }\n\n        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n        this.session.highlight(re);\n\n        this._signal(\"changeSelection\");\n    };\n\n    this.$getSelectionHighLightRegexp = function() {\n        var session = this.session;\n\n        var selection = this.getSelectionRange();\n        if (selection.isEmpty() || selection.isMultiLine())\n            return;\n\n        var startColumn = selection.start.column;\n        var endColumn = selection.end.column;\n        var line = session.getLine(selection.start.row);\n        \n        var needle = line.substring(startColumn, endColumn);\n        if (needle.length > 5000 || !/[\\w\\d]/.test(needle))\n            return;\n\n        var re = this.$search.$assembleRegExp({\n            wholeWord: true,\n            caseSensitive: true,\n            needle: needle\n        });\n        \n        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);\n        if (!re.test(wordWithBoundary))\n            return;\n        \n        return re;\n    };\n\n\n    this.onChangeFrontMarker = function() {\n        this.renderer.updateFrontMarkers();\n    };\n\n    this.onChangeBackMarker = function() {\n        this.renderer.updateBackMarkers();\n    };\n\n\n    this.onChangeBreakpoint = function() {\n        this.renderer.updateBreakpoints();\n    };\n\n    this.onChangeAnnotation = function() {\n        this.renderer.setAnnotations(this.session.getAnnotations());\n    };\n\n\n    this.onChangeMode = function(e) {\n        this.renderer.updateText();\n        this._emit(\"changeMode\", e);\n    };\n\n\n    this.onChangeWrapLimit = function() {\n        this.renderer.updateFull();\n    };\n\n    this.onChangeWrapMode = function() {\n        this.renderer.onResize(true);\n    };\n\n\n    this.onChangeFold = function() {\n        this.$updateHighlightActiveLine();\n        this.renderer.updateFull();\n    };\n    this.getSelectedText = function() {\n        return this.session.getTextRange(this.getSelectionRange());\n    };\n    this.getCopyText = function() {\n        var text = this.getSelectedText();\n        var nl = this.session.doc.getNewLineCharacter();\n        var copyLine= false;\n        if (!text && this.$copyWithEmptySelection) {\n            copyLine = true;\n            var ranges = this.selection.getAllRanges();\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (i && ranges[i - 1].start.row == range.start.row)\n                    continue;\n                text += this.session.getLine(range.start.row) + nl;\n            }\n        }\n        var e = {text: text};\n        this._signal(\"copy\", e);\n        clipboard.lineMode = copyLine ? e.text : \"\";\n        return e.text;\n    };\n    this.onCopy = function() {\n        this.commands.exec(\"copy\", this);\n    };\n    this.onCut = function() {\n        this.commands.exec(\"cut\", this);\n    };\n    this.onPaste = function(text, event) {\n        var e = {text: text, event: event};\n        this.commands.exec(\"paste\", this, e);\n    };\n    \n    this.$handlePaste = function(e) {\n        if (typeof e == \"string\") \n            e = {text: e};\n        this._signal(\"paste\", e);\n        var text = e.text;\n\n        var lineMode = text == clipboard.lineMode;\n        var session = this.session;\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {\n            if (lineMode)\n                session.insert({ row: this.selection.lead.row, column: 0 }, text);\n            else\n                this.insert(text);\n        } else if (lineMode) {\n            this.selection.rangeList.ranges.forEach(function(range) {\n                session.insert({ row: range.start.row, column: 0 }, text);\n            });\n        } else {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var ranges = this.selection.rangeList.ranges;\n    \n            if (lines.length > ranges.length || lines.length < 2 || !lines[1])\n                return this.commands.exec(\"insertstring\", this, text);\n    \n            for (var i = ranges.length; i--;) {\n                var range = ranges[i];\n                if (!range.isEmpty())\n                    session.remove(range);\n    \n                session.insert(range.start, lines[i]);\n            }\n        }\n    };\n\n    this.execCommand = function(command, args) {\n        return this.commands.exec(command, this, args);\n    };\n    this.insert = function(text, pasted) {\n        var session = this.session;\n        var mode = session.getMode();\n        var cursor = this.getCursorPosition();\n\n        if (this.getBehavioursEnabled() && !pasted) {\n            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n            if (transform) {\n                if (text !== transform.text) {\n                    if (!this.inVirtualSelectionMode) {\n                        this.session.mergeUndoDeltas = false;\n                        this.mergeNextCommand = false;\n                    }\n                }\n                text = transform.text;\n\n            }\n        }\n        \n        if (text == \"\\t\")\n            text = this.session.getTabString();\n        if (!this.selection.isEmpty()) {\n            var range = this.getSelectionRange();\n            cursor = this.session.remove(range);\n            this.clearSelection();\n        }\n        else if (this.session.getOverwrite() && text.indexOf(\"\\n\") == -1) {\n            var range = new Range.fromPoints(cursor, cursor);\n            range.end.column += text.length;\n            this.session.remove(range);\n        }\n\n        if (text == \"\\n\" || text == \"\\r\\n\") {\n            var line = session.getLine(cursor.row);\n            if (cursor.column > line.search(/\\S|$/)) {\n                var d = line.substr(cursor.column).search(/\\S|$/);\n                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n            }\n        }\n        this.clearSelection();\n\n        var start = cursor.column;\n        var lineState = session.getState(cursor.row);\n        var line = session.getLine(cursor.row);\n        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n        var end = session.insert(cursor, text);\n\n        if (transform && transform.selection) {\n            if (transform.selection.length == 2) { // Transform relative to the current column\n                this.selection.setSelectionRange(\n                    new Range(cursor.row, start + transform.selection[0],\n                              cursor.row, start + transform.selection[1]));\n            } else { // Transform relative to the current row.\n                this.selection.setSelectionRange(\n                    new Range(cursor.row + transform.selection[0],\n                              transform.selection[1],\n                              cursor.row + transform.selection[2],\n                              transform.selection[3]));\n            }\n        }\n\n        if (session.getDocument().isNewLine(text)) {\n            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n\n            session.insert({row: cursor.row+1, column: 0}, lineIndent);\n        }\n        if (shouldOutdent)\n            mode.autoOutdent(lineState, session, cursor.row);\n    };\n\n    this.onTextInput = function(text, composition) {\n        if (!composition)\n            return this.keyBinding.onTextInput(text);\n        \n        this.startOperation({command: { name: \"insertstring\" }});\n        var applyComposition = this.applyComposition.bind(this, text, composition);\n        if (this.selection.rangeCount)\n            this.forEachSelection(applyComposition);\n        else\n            applyComposition();\n        this.endOperation();\n    };\n    \n    this.applyComposition = function(text, composition) {\n        if (composition.extendLeft || composition.extendRight) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.extendLeft;\n            r.end.column += composition.extendRight;\n            this.selection.setRange(r);\n            if (!text && !r.isEmpty())\n                this.remove();\n        }\n        if (text || !this.selection.isEmpty())\n            this.insert(text, true);\n        if (composition.restoreStart || composition.restoreEnd) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.restoreStart;\n            r.end.column -= composition.restoreEnd;\n            this.selection.setRange(r);\n        }\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        this.keyBinding.onCommandKey(e, hashId, keyCode);\n    };\n    this.setOverwrite = function(overwrite) {\n        this.session.setOverwrite(overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.session.getOverwrite();\n    };\n    this.toggleOverwrite = function() {\n        this.session.toggleOverwrite();\n    };\n    this.setScrollSpeed = function(speed) {\n        this.setOption(\"scrollSpeed\", speed);\n    };\n    this.getScrollSpeed = function() {\n        return this.getOption(\"scrollSpeed\");\n    };\n    this.setDragDelay = function(dragDelay) {\n        this.setOption(\"dragDelay\", dragDelay);\n    };\n    this.getDragDelay = function() {\n        return this.getOption(\"dragDelay\");\n    };\n    this.setSelectionStyle = function(val) {\n        this.setOption(\"selectionStyle\", val);\n    };\n    this.getSelectionStyle = function() {\n        return this.getOption(\"selectionStyle\");\n    };\n    this.setHighlightActiveLine = function(shouldHighlight) {\n        this.setOption(\"highlightActiveLine\", shouldHighlight);\n    };\n    this.getHighlightActiveLine = function() {\n        return this.getOption(\"highlightActiveLine\");\n    };\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    this.setHighlightSelectedWord = function(shouldHighlight) {\n        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n    };\n    this.getHighlightSelectedWord = function() {\n        return this.$highlightSelectedWord;\n    };\n\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.renderer.setAnimatedScroll(shouldAnimate);\n    };\n\n    this.getAnimatedScroll = function(){\n        return this.renderer.getAnimatedScroll();\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.renderer.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.renderer.getShowInvisibles();\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.renderer.setDisplayIndentGuides(display);\n    };\n\n    this.getDisplayIndentGuides = function() {\n        return this.renderer.getDisplayIndentGuides();\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.renderer.setShowPrintMargin(showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.renderer.getShowPrintMargin();\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.renderer.setPrintMarginColumn(showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.renderer.getPrintMarginColumn();\n    };\n    this.setReadOnly = function(readOnly) {\n        this.setOption(\"readOnly\", readOnly);\n    };\n    this.getReadOnly = function() {\n        return this.getOption(\"readOnly\");\n    };\n    this.setBehavioursEnabled = function (enabled) {\n        this.setOption(\"behavioursEnabled\", enabled);\n    };\n    this.getBehavioursEnabled = function () {\n        return this.getOption(\"behavioursEnabled\");\n    };\n    this.setWrapBehavioursEnabled = function (enabled) {\n        this.setOption(\"wrapBehavioursEnabled\", enabled);\n    };\n    this.getWrapBehavioursEnabled = function () {\n        return this.getOption(\"wrapBehavioursEnabled\");\n    };\n    this.setShowFoldWidgets = function(show) {\n        this.setOption(\"showFoldWidgets\", show);\n\n    };\n    this.getShowFoldWidgets = function() {\n        return this.getOption(\"showFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(fade) {\n        this.setOption(\"fadeFoldWidgets\", fade);\n    };\n\n    this.getFadeFoldWidgets = function() {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    this.remove = function(dir) {\n        if (this.selection.isEmpty()){\n            if (dir == \"left\")\n                this.selection.selectLeft();\n            else\n                this.selection.selectRight();\n        }\n\n        var range = this.getSelectionRange();\n        if (this.getBehavioursEnabled()) {\n            var session = this.session;\n            var state = session.getState(range.start.row);\n            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n\n            if (range.end.column === 0) {\n                var text = session.getTextRange(range);\n                if (text[text.length - 1] == \"\\n\") {\n                    var line = session.getLine(range.end.row);\n                    if (/^\\s+$/.test(line)) {\n                        range.end.column = line.length;\n                    }\n                }\n            }\n            if (new_range)\n                range = new_range;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.removeWordRight = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordRight();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeWordLeft = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordLeft();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineStart = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineStart();\n        if (this.selection.isEmpty())\n            this.selection.selectLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineEnd = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineEnd();\n\n        var range = this.getSelectionRange();\n        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n            range.end.column = 0;\n            range.end.row++;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.splitLine = function() {\n        if (!this.selection.isEmpty()) {\n            this.session.remove(this.getSelectionRange());\n            this.clearSelection();\n        }\n\n        var cursor = this.getCursorPosition();\n        this.insert(\"\\n\");\n        this.moveCursorToPosition(cursor);\n    };\n    this.transposeLetters = function() {\n        if (!this.selection.isEmpty()) {\n            return;\n        }\n\n        var cursor = this.getCursorPosition();\n        var column = cursor.column;\n        if (column === 0)\n            return;\n\n        var line = this.session.getLine(cursor.row);\n        var swap, range;\n        if (column < line.length) {\n            swap = line.charAt(column) + line.charAt(column-1);\n            range = new Range(cursor.row, column-1, cursor.row, column+1);\n        }\n        else {\n            swap = line.charAt(column-1) + line.charAt(column-2);\n            range = new Range(cursor.row, column-2, cursor.row, column);\n        }\n        this.session.replace(range, swap);\n        this.session.selection.moveToPosition(range.end);\n    };\n    this.toLowerCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toLowerCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.toUpperCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toUpperCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.indent = function() {\n        var session = this.session;\n        var range = this.getSelectionRange();\n\n        if (range.start.row < range.end.row) {\n            var rows = this.$getSelectedRows();\n            session.indentRows(rows.first, rows.last, \"\\t\");\n            return;\n        } else if (range.start.column < range.end.column) {\n            var text = session.getTextRange(range);\n            if (!/^\\s+$/.test(text)) {\n                var rows = this.$getSelectedRows();\n                session.indentRows(rows.first, rows.last, \"\\t\");\n                return;\n            }\n        }\n        \n        var line = session.getLine(range.start.row);\n        var position = range.start;\n        var size = session.getTabSize();\n        var column = session.documentToScreenColumn(position.row, position.column);\n\n        if (this.session.getUseSoftTabs()) {\n            var count = (size - column % size);\n            var indentString = lang.stringRepeat(\" \", count);\n        } else {\n            var count = column % size;\n            while (line[range.start.column - 1] == \" \" && count) {\n                range.start.column--;\n                count--;\n            }\n            this.selection.setSelectionRange(range);\n            indentString = \"\\t\";\n        }\n        return this.insert(indentString);\n    };\n    this.blockIndent = function() {\n        var rows = this.$getSelectedRows();\n        this.session.indentRows(rows.first, rows.last, \"\\t\");\n    };\n    this.blockOutdent = function() {\n        var selection = this.session.getSelection();\n        this.session.outdentRows(selection.getRange());\n    };\n    this.sortLines = function() {\n        var rows = this.$getSelectedRows();\n        var session = this.session;\n\n        var lines = [];\n        for (var i = rows.first; i <= rows.last; i++)\n            lines.push(session.getLine(i));\n\n        lines.sort(function(a, b) {\n            if (a.toLowerCase() < b.toLowerCase()) return -1;\n            if (a.toLowerCase() > b.toLowerCase()) return 1;\n            return 0;\n        });\n\n        var deleteRange = new Range(0, 0, 0, 0);\n        for (var i = rows.first; i <= rows.last; i++) {\n            var line = session.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            deleteRange.end.column = line.length;\n            session.replace(deleteRange, lines[i-rows.first]);\n        }\n    };\n    this.toggleCommentLines = function() {\n        var state = this.session.getState(this.getCursorPosition().row);\n        var rows = this.$getSelectedRows();\n        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n    };\n\n    this.toggleBlockComment = function() {\n        var cursor = this.getCursorPosition();\n        var state = this.session.getState(cursor.row);\n        var range = this.getSelectionRange();\n        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n    };\n    this.getNumberAt = function(row, column) {\n        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n        _numberRx.lastIndex = 0;\n\n        var s = this.session.getLine(row);\n        while (_numberRx.lastIndex < column) {\n            var m = _numberRx.exec(s);\n            if(m.index <= column && m.index+m[0].length >= column){\n                var number = {\n                    value: m[0],\n                    start: m.index,\n                    end: m.index+m[0].length\n                };\n                return number;\n            }\n        }\n        return null;\n    };\n    this.modifyNumber = function(amount) {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        var charRange = new Range(row, column-1, row, column);\n\n        var c = this.session.getTextRange(charRange);\n        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n            var nr = this.getNumberAt(row, column);\n            if (nr) {\n                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n                var decimals = nr.start + nr.value.length - fp;\n\n                var t = parseFloat(nr.value);\n                t *= Math.pow(10, decimals);\n\n\n                if(fp !== nr.end && column < fp){\n                    amount *= Math.pow(10, nr.end - column - 1);\n                } else {\n                    amount *= Math.pow(10, nr.end - column);\n                }\n\n                t += amount;\n                t /= Math.pow(10, decimals);\n                var nnr = t.toFixed(decimals);\n                var replaceRange = new Range(row, nr.start, row, nr.end);\n                this.session.replace(replaceRange, nnr);\n                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));\n\n            }\n        } else {\n            this.toggleWord();\n        }\n    };\n\n    this.$toggleWordPairs = [\n        [\"first\", \"last\"],\n        [\"true\", \"false\"],\n        [\"yes\", \"no\"],\n        [\"width\", \"height\"],\n        [\"top\", \"bottom\"],\n        [\"right\", \"left\"],\n        [\"on\", \"off\"],\n        [\"x\", \"y\"],\n        [\"get\", \"set\"],\n        [\"max\", \"min\"],\n        [\"horizontal\", \"vertical\"],\n        [\"show\", \"hide\"],\n        [\"add\", \"remove\"],\n        [\"up\", \"down\"],\n        [\"before\", \"after\"],\n        [\"even\", \"odd\"],\n        [\"inside\", \"outside\"],\n        [\"next\", \"previous\"],\n        [\"increase\", \"decrease\"],\n        [\"attach\", \"detach\"],\n        [\"&&\", \"||\"],\n        [\"==\", \"!=\"]\n    ];\n\n    this.toggleWord = function () {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        this.selection.selectWord();\n        var currentState = this.getSelectedText();\n        var currWordStart = this.selection.getWordRange().start.column;\n        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\\s/);\n        var delta = column - currWordStart - 1;\n        if (delta < 0) delta = 0;\n        var curLength = 0, itLength = 0;\n        var that = this;\n        if (currentState.match(/[A-Za-z0-9_]+/)) {\n            wordParts.forEach(function (item, i) {\n                itLength = curLength + item.length;\n                if (delta >= curLength && delta <= itLength) {\n                    currentState = item;\n                    that.selection.clearSelection();\n                    that.moveCursorTo(row, curLength + currWordStart);\n                    that.selection.selectTo(row, itLength + currWordStart);\n                }\n                curLength = itLength;\n            });\n        }\n\n        var wordPairs = this.$toggleWordPairs;\n        var reg;\n        for (var i = 0; i < wordPairs.length; i++) {\n            var item = wordPairs[i];\n            for (var j = 0; j <= 1; j++) {\n                var negate = +!j;\n                var firstCondition = currentState.match(new RegExp('^\\\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\\\s?$', 'i'));\n                if (firstCondition) {\n                    var secondCondition = currentState.match(new RegExp('([_]|^|\\\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\\\s)', 'g'));\n                    if (secondCondition) {\n                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {\n                            var res = item[negate];\n                            if (result.toUpperCase() == result) {\n                                res = res.toUpperCase();\n                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {\n                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);\n                            }\n                            return res;\n                        });\n                        this.insert(reg);\n                        reg = \"\";\n                    }\n                }\n            }\n        }\n    };\n    this.removeLines = function() {\n        var rows = this.$getSelectedRows();\n        this.session.removeFullLines(rows.first, rows.last);\n        this.clearSelection();\n    };\n\n    this.duplicateSelection = function() {\n        var sel = this.selection;\n        var doc = this.session;\n        var range = sel.getRange();\n        var reverse = sel.isBackwards();\n        if (range.isEmpty()) {\n            var row = range.start.row;\n            doc.duplicateLines(row, row);\n        } else {\n            var point = reverse ? range.start : range.end;\n            var endPoint = doc.insert(point, doc.getTextRange(range), false);\n            range.start = point;\n            range.end = endPoint;\n\n            sel.setSelectionRange(range, reverse);\n        }\n    };\n    this.moveLinesDown = function() {\n        this.$moveLines(1, false);\n    };\n    this.moveLinesUp = function() {\n        this.$moveLines(-1, false);\n    };\n    this.moveText = function(range, toPosition, copy) {\n        return this.session.moveText(range, toPosition, copy);\n    };\n    this.copyLinesUp = function() {\n        this.$moveLines(-1, true);\n    };\n    this.copyLinesDown = function() {\n        this.$moveLines(1, true);\n    };\n    this.$moveLines = function(dir, copy) {\n        var rows, moved;\n        var selection = this.selection;\n        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n            var range = selection.toOrientedRange();\n            rows = this.$getSelectedRows(range);\n            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);\n            if (copy && dir == -1) moved = 0;\n            range.moveBy(moved, 0);\n            selection.fromOrientedRange(range);\n        } else {\n            var ranges = selection.rangeList.ranges;\n            selection.rangeList.detach(this.session);\n            this.inVirtualSelectionMode = true;\n            \n            var diff = 0;\n            var totalDiff = 0;\n            var l = ranges.length;\n            for (var i = 0; i < l; i++) {\n                var rangeIndex = i;\n                ranges[i].moveBy(diff, 0);\n                rows = this.$getSelectedRows(ranges[i]);\n                var first = rows.first;\n                var last = rows.last;\n                while (++i < l) {\n                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);\n                    var subRows = this.$getSelectedRows(ranges[i]);\n                    if (copy && subRows.first != last)\n                        break;\n                    else if (!copy && subRows.first > last + 1)\n                        break;\n                    last = subRows.last;\n                }\n                i--;\n                diff = this.session.$moveLines(first, last, copy ? 0 : dir);\n                if (copy && dir == -1) rangeIndex = i + 1;\n                while (rangeIndex <= i) {\n                    ranges[rangeIndex].moveBy(diff, 0);\n                    rangeIndex++;\n                }\n                if (!copy) diff = 0;\n                totalDiff += diff;\n            }\n            \n            selection.fromOrientedRange(selection.ranges[0]);\n            selection.rangeList.attach(this.session);\n            this.inVirtualSelectionMode = false;\n        }\n    };\n    this.$getSelectedRows = function(range) {\n        range = (range || this.getSelectionRange()).collapseRows();\n\n        return {\n            first: this.session.getRowFoldStart(range.start.row),\n            last: this.session.getRowFoldEnd(range.end.row)\n        };\n    };\n\n    this.onCompositionStart = function(compositionState) {\n        this.renderer.showComposition(compositionState);\n    };\n\n    this.onCompositionUpdate = function(text) {\n        this.renderer.setCompositionText(text);\n    };\n\n    this.onCompositionEnd = function() {\n        this.renderer.hideComposition();\n    };\n    this.getFirstVisibleRow = function() {\n        return this.renderer.getFirstVisibleRow();\n    };\n    this.getLastVisibleRow = function() {\n        return this.renderer.getLastVisibleRow();\n    };\n    this.isRowVisible = function(row) {\n        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n    };\n    this.isRowFullyVisible = function(row) {\n        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n    };\n    this.$getVisibleRowCount = function() {\n        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n    };\n\n    this.$moveByPage = function(dir, select) {\n        var renderer = this.renderer;\n        var config = this.renderer.layerConfig;\n        var rows = dir * Math.floor(config.height / config.lineHeight);\n\n        if (select === true) {\n            this.selection.$moveSelection(function(){\n                this.moveCursorBy(rows, 0);\n            });\n        } else if (select === false) {\n            this.selection.moveCursorBy(rows, 0);\n            this.selection.clearSelection();\n        }\n\n        var scrollTop = renderer.scrollTop;\n\n        renderer.scrollBy(0, rows * config.lineHeight);\n        if (select != null)\n            renderer.scrollCursorIntoView(null, 0.5);\n\n        renderer.animateScrolling(scrollTop);\n    };\n    this.selectPageDown = function() {\n        this.$moveByPage(1, true);\n    };\n    this.selectPageUp = function() {\n        this.$moveByPage(-1, true);\n    };\n    this.gotoPageDown = function() {\n       this.$moveByPage(1, false);\n    };\n    this.gotoPageUp = function() {\n        this.$moveByPage(-1, false);\n    };\n    this.scrollPageDown = function() {\n        this.$moveByPage(1);\n    };\n    this.scrollPageUp = function() {\n        this.$moveByPage(-1);\n    };\n    this.scrollToRow = function(row) {\n        this.renderer.scrollToRow(row);\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        this.renderer.scrollToLine(line, center, animate, callback);\n    };\n    this.centerSelection = function() {\n        var range = this.getSelectionRange();\n        var pos = {\n            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n        };\n        this.renderer.alignCursor(pos, 0.5);\n    };\n    this.getCursorPosition = function() {\n        return this.selection.getCursor();\n    };\n    this.getCursorPositionScreen = function() {\n        return this.session.documentToScreenPosition(this.getCursorPosition());\n    };\n    this.getSelectionRange = function() {\n        return this.selection.getRange();\n    };\n    this.selectAll = function() {\n        this.selection.selectAll();\n    };\n    this.clearSelection = function() {\n        this.selection.clearSelection();\n    };\n    this.moveCursorTo = function(row, column) {\n        this.selection.moveCursorTo(row, column);\n    };\n    this.moveCursorToPosition = function(pos) {\n        this.selection.moveCursorToPosition(pos);\n    };\n    this.jumpToMatching = function(select, expand) {\n        var cursor = this.getCursorPosition();\n        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n        var prevToken = iterator.getCurrentToken();\n        var token = prevToken || iterator.stepForward();\n\n        if (!token) return;\n        var matchType;\n        var found = false;\n        var depth = {};\n        var i = cursor.column - token.start;\n        var bracketType;\n        var brackets = {\n            \")\": \"(\",\n            \"(\": \"(\",\n            \"]\": \"[\",\n            \"[\": \"[\",\n            \"{\": \"{\",\n            \"}\": \"{\"\n        };\n        \n        do {\n            if (token.value.match(/[{}()\\[\\]]/g)) {\n                for (; i < token.value.length && !found; i++) {\n                    if (!brackets[token.value[i]]) {\n                        continue;\n                    }\n\n                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n\n                    if (isNaN(depth[bracketType])) {\n                        depth[bracketType] = 0;\n                    }\n\n                    switch (token.value[i]) {\n                        case '(':\n                        case '[':\n                        case '{':\n                            depth[bracketType]++;\n                            break;\n                        case ')':\n                        case ']':\n                        case '}':\n                            depth[bracketType]--;\n\n                            if (depth[bracketType] === -1) {\n                                matchType = 'bracket';\n                                found = true;\n                            }\n                        break;\n                    }\n                }\n            }\n            else if (token.type.indexOf('tag-name') !== -1) {\n                if (isNaN(depth[token.value])) {\n                    depth[token.value] = 0;\n                }\n                \n                if (prevToken.value === '<') {\n                    depth[token.value]++;\n                }\n                else if (prevToken.value === '</') {\n                    depth[token.value]--;\n                }\n                \n                if (depth[token.value] === -1) {\n                    matchType = 'tag';\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                prevToken = token;\n                token = iterator.stepForward();\n                i = 0;\n            }\n        } while (token && !found);\n        if (!matchType)\n            return;\n\n        var range, pos;\n        if (matchType === 'bracket') {\n            range = this.session.getBracketRange(cursor);\n            if (!range) {\n                range = new Range(\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1,\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1\n                );\n                pos = range.start;\n                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    range = this.session.getBracketRange(pos);\n            }\n        }\n        else if (matchType === 'tag') {\n            if (token && token.type.indexOf('tag-name') !== -1) \n                var tag = token.value;\n            else\n                return;\n\n            range = new Range(\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2,\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2\n            );\n            if (range.compare(cursor.row, cursor.column) === 0) {\n                found = false;\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (prevToken) {\n                        if (prevToken.type.indexOf('tag-close') !== -1) {\n                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n                        }\n\n                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                            if (prevToken.value === '<') {\n                                depth[tag]++;\n                            }\n                            else if (prevToken.value === '</') {\n                                depth[tag]--;\n                            }\n                            \n                            if (depth[tag] === 0)\n                                found = true;\n                        }\n                    }\n                } while (prevToken && !found);\n            }\n            if (token && token.type.indexOf('tag-name')) {\n                pos = range.start;\n                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    pos = range.end;\n            }\n        }\n\n        pos = range && range.cursor || pos;\n        if (pos) {\n            if (select) {\n                if (range && expand) {\n                    this.selection.setRange(range);\n                } else if (range && range.isEqual(this.getSelectionRange())) {\n                    this.clearSelection();\n                } else {\n                    this.selection.selectTo(pos.row, pos.column);\n                }\n            } else {\n                this.selection.moveTo(pos.row, pos.column);\n            }\n        }\n    };\n    this.gotoLine = function(lineNumber, column, animate) {\n        this.selection.clearSelection();\n        this.session.unfold({row: lineNumber - 1, column: column || 0});\n        this.exitMultiSelectMode && this.exitMultiSelectMode();\n        this.moveCursorTo(lineNumber - 1, column || 0);\n\n        if (!this.isRowFullyVisible(lineNumber - 1))\n            this.scrollToLine(lineNumber - 1, true, animate);\n    };\n    this.navigateTo = function(row, column) {\n        this.selection.moveTo(row, column);\n    };\n    this.navigateUp = function(times) {\n        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n            var selectionStart = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionStart);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(-times || -1, 0);\n    };\n    this.navigateDown = function(times) {\n        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n            var selectionEnd = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionEnd);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(times || 1, 0);\n    };\n    this.navigateLeft = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionStart = this.getSelectionRange().start;\n            this.moveCursorToPosition(selectionStart);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorLeft();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateRight = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionEnd = this.getSelectionRange().end;\n            this.moveCursorToPosition(selectionEnd);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorRight();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateLineStart = function() {\n        this.selection.moveCursorLineStart();\n        this.clearSelection();\n    };\n    this.navigateLineEnd = function() {\n        this.selection.moveCursorLineEnd();\n        this.clearSelection();\n    };\n    this.navigateFileEnd = function() {\n        this.selection.moveCursorFileEnd();\n        this.clearSelection();\n    };\n    this.navigateFileStart = function() {\n        this.selection.moveCursorFileStart();\n        this.clearSelection();\n    };\n    this.navigateWordRight = function() {\n        this.selection.moveCursorWordRight();\n        this.clearSelection();\n    };\n    this.navigateWordLeft = function() {\n        this.selection.moveCursorWordLeft();\n        this.clearSelection();\n    };\n    this.replace = function(replacement, options) {\n        if (options)\n            this.$search.set(options);\n\n        var range = this.$search.find(this.session);\n        var replaced = 0;\n        if (!range)\n            return replaced;\n\n        if (this.$tryReplace(range, replacement)) {\n            replaced = 1;\n        }\n\n        this.selection.setSelectionRange(range);\n        this.renderer.scrollSelectionIntoView(range.start, range.end);\n\n        return replaced;\n    };\n    this.replaceAll = function(replacement, options) {\n        if (options) {\n            this.$search.set(options);\n        }\n\n        var ranges = this.$search.findAll(this.session);\n        var replaced = 0;\n        if (!ranges.length)\n            return replaced;\n\n        var selection = this.getSelectionRange();\n        this.selection.moveTo(0, 0);\n\n        for (var i = ranges.length - 1; i >= 0; --i) {\n            if(this.$tryReplace(ranges[i], replacement)) {\n                replaced++;\n            }\n        }\n\n        this.selection.setSelectionRange(selection);\n\n        return replaced;\n    };\n\n    this.$tryReplace = function(range, replacement) {\n        var input = this.session.getTextRange(range);\n        replacement = this.$search.replace(input, replacement);\n        if (replacement !== null) {\n            range.end = this.session.replace(range, replacement);\n            return range;\n        } else {\n            return null;\n        }\n    };\n    this.getLastSearchOptions = function() {\n        return this.$search.getOptions();\n    };\n    this.find = function(needle, options, animate) {\n        if (!options)\n            options = {};\n\n        if (typeof needle == \"string\" || needle instanceof RegExp)\n            options.needle = needle;\n        else if (typeof needle == \"object\")\n            oop.mixin(options, needle);\n\n        var range = this.selection.getRange();\n        if (options.needle == null) {\n            needle = this.session.getTextRange(range)\n                || this.$search.$options.needle;\n            if (!needle) {\n                range = this.session.getWordRange(range.start.row, range.start.column);\n                needle = this.session.getTextRange(range);\n            }\n            this.$search.set({needle: needle});\n        }\n\n        this.$search.set(options);\n        if (!options.start)\n            this.$search.set({start: range});\n\n        var newRange = this.$search.find(this.session);\n        if (options.preventScroll)\n            return newRange;\n        if (newRange) {\n            this.revealRange(newRange, animate);\n            return newRange;\n        }\n        if (options.backwards)\n            range.start = range.end;\n        else\n            range.end = range.start;\n        this.selection.setRange(range);\n    };\n    this.findNext = function(options, animate) {\n        this.find({skipCurrent: true, backwards: false}, options, animate);\n    };\n    this.findPrevious = function(options, animate) {\n        this.find(options, {skipCurrent: true, backwards: true}, animate);\n    };\n\n    this.revealRange = function(range, animate) {\n        this.session.unfold(range);\n        this.selection.setSelectionRange(range);\n\n        var scrollTop = this.renderer.scrollTop;\n        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n        if (animate !== false)\n            this.renderer.animateScrolling(scrollTop);\n    };\n    this.undo = function() {\n        this.session.getUndoManager().undo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.redo = function() {\n        this.session.getUndoManager().redo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.destroy = function() {\n        this.renderer.destroy();\n        this._signal(\"destroy\", this);\n        if (this.session) {\n            this.session.destroy();\n        }\n    };\n    this.setAutoScrollEditorIntoView = function(enable) {\n        if (!enable)\n            return;\n        var rect;\n        var self = this;\n        var shouldScroll = false;\n        if (!this.$scrollAnchor)\n            this.$scrollAnchor = document.createElement(\"div\");\n        var scrollAnchor = this.$scrollAnchor;\n        scrollAnchor.style.cssText = \"position:absolute\";\n        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n        var onChangeSelection = this.on(\"changeSelection\", function() {\n            shouldScroll = true;\n        });\n        var onBeforeRender = this.renderer.on(\"beforeRender\", function() {\n            if (shouldScroll)\n                rect = self.renderer.container.getBoundingClientRect();\n        });\n        var onAfterRender = this.renderer.on(\"afterRender\", function() {\n            if (shouldScroll && rect && (self.isFocused()\n                || self.searchBox && self.searchBox.isFocused())\n            ) {\n                var renderer = self.renderer;\n                var pos = renderer.$cursorLayer.$pixelPos;\n                var config = renderer.layerConfig;\n                var top = pos.top - config.offset;\n                if (pos.top >= 0 && top + rect.top < 0) {\n                    shouldScroll = true;\n                } else if (pos.top < config.height &&\n                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n                    shouldScroll = false;\n                } else {\n                    shouldScroll = null;\n                }\n                if (shouldScroll != null) {\n                    scrollAnchor.style.top = top + \"px\";\n                    scrollAnchor.style.left = pos.left + \"px\";\n                    scrollAnchor.style.height = config.lineHeight + \"px\";\n                    scrollAnchor.scrollIntoView(shouldScroll);\n                }\n                shouldScroll = rect = null;\n            }\n        });\n        this.setAutoScrollEditorIntoView = function(enable) {\n            if (enable)\n                return;\n            delete this.setAutoScrollEditorIntoView;\n            this.off(\"changeSelection\", onChangeSelection);\n            this.renderer.off(\"afterRender\", onAfterRender);\n            this.renderer.off(\"beforeRender\", onBeforeRender);\n        };\n    };\n\n\n    this.$resetCursorStyle = function() {\n        var style = this.$cursorStyle || \"ace\";\n        var cursorLayer = this.renderer.$cursorLayer;\n        if (!cursorLayer)\n            return;\n        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n    };\n    this.prompt = function(message, options, callback) {\n        var editor = this;\n        config.loadModule(\"./ext/prompt\", function (module) {\n            module.prompt(editor, message, options, callback);\n        });\n    };\n\n}).call(Editor.prototype);\n\n\n\nconfig.defineOptions(Editor.prototype, \"editor\", {\n    selectionStyle: {\n        set: function(style) {\n            this.onSelectionChange();\n            this._signal(\"changeSelectionStyle\", {data: style});\n        },\n        initialValue: \"line\"\n    },\n    highlightActiveLine: {\n        set: function() {this.$updateHighlightActiveLine();},\n        initialValue: true\n    },\n    highlightSelectedWord: {\n        set: function(shouldHighlight) {this.$onSelectionChange();},\n        initialValue: true\n    },\n    readOnly: {\n        set: function(readOnly) {\n            this.textInput.setReadOnly(readOnly);\n            this.$resetCursorStyle(); \n        },\n        initialValue: false\n    },\n    copyWithEmptySelection: {\n        set: function(value) {\n            this.textInput.setCopyWithEmptySelection(value);\n        },\n        initialValue: false\n    },\n    cursorStyle: {\n        set: function(val) { this.$resetCursorStyle(); },\n        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n        initialValue: \"ace\"\n    },\n    mergeUndoDeltas: {\n        values: [false, true, \"always\"],\n        initialValue: true\n    },\n    behavioursEnabled: {initialValue: true},\n    wrapBehavioursEnabled: {initialValue: true},\n    autoScrollEditorIntoView: {\n        set: function(val) {this.setAutoScrollEditorIntoView(val);}\n    },\n    keyboardHandler: {\n        set: function(val) { this.setKeyboardHandler(val); },\n        get: function() { return this.$keybindingId; },\n        handlesSet: true\n    },\n    value: {\n        set: function(val) { this.session.setValue(val); },\n        get: function() { return this.getValue(); },\n        handlesSet: true,\n        hidden: true\n    },\n    session: {\n        set: function(val) { this.setSession(val); },\n        get: function() { return this.session; },\n        handlesSet: true,\n        hidden: true\n    },\n    \n    showLineNumbers: {\n        set: function(show) {\n            this.renderer.$gutterLayer.setShowLineNumbers(show);\n            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);\n            if (show && this.$relativeLineNumbers)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        },\n        initialValue: true\n    },\n    relativeLineNumbers: {\n        set: function(value) {\n            if (this.$showLineNumbers && value)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        }\n    },\n\n    hScrollBarAlwaysVisible: \"renderer\",\n    vScrollBarAlwaysVisible: \"renderer\",\n    highlightGutterLine: \"renderer\",\n    animatedScroll: \"renderer\",\n    showInvisibles: \"renderer\",\n    showPrintMargin: \"renderer\",\n    printMarginColumn: \"renderer\",\n    printMargin: \"renderer\",\n    fadeFoldWidgets: \"renderer\",\n    showFoldWidgets: \"renderer\",\n    displayIndentGuides: \"renderer\",\n    showGutter: \"renderer\",\n    fontSize: \"renderer\",\n    fontFamily: \"renderer\",\n    maxLines: \"renderer\",\n    minLines: \"renderer\",\n    scrollPastEnd: \"renderer\",\n    fixedWidthGutter: \"renderer\",\n    theme: \"renderer\",\n    hasCssTransforms: \"renderer\",\n    maxPixelHeight: \"renderer\",\n    useTextareaForIME: \"renderer\",\n\n    scrollSpeed: \"$mouseHandler\",\n    dragDelay: \"$mouseHandler\",\n    dragEnabled: \"$mouseHandler\",\n    focusTimeout: \"$mouseHandler\",\n    tooltipFollowsMouse: \"$mouseHandler\",\n\n    firstLineNumber: \"session\",\n    overwrite: \"session\",\n    newLineMode: \"session\",\n    useWorker: \"session\",\n    useSoftTabs: \"session\",\n    navigateWithinSoftTabs: \"session\",\n    tabSize: \"session\",\n    wrap: \"session\",\n    indentedSoftWrap: \"session\",\n    foldStyle: \"session\",\n    mode: \"session\"\n});\n\n\nvar relativeNumberRenderer = {\n    getText: function(session, row) {\n        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? \"\\xb7\" : \"\"))) + \"\";\n    },\n    getWidth: function(session, lastLineNumber, config) {\n        return Math.max(\n            lastLineNumber.toString().length,\n            (config.lastRow + 1).toString().length,\n            2\n        ) * config.characterWidth;\n    },\n    update: function(e, editor) {\n        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);\n    },\n    attach: function(editor) {\n        editor.renderer.$gutterLayer.$renderer = this;\n        editor.on(\"changeSelection\", this.update);\n        this.update(null, editor);\n    },\n    detach: function(editor) {\n        if (editor.renderer.$gutterLayer.$renderer == this)\n            editor.renderer.$gutterLayer.$renderer = null;\n        editor.off(\"changeSelection\", this.update);\n        this.update(null, editor);\n    }\n};\n\nexports.Editor = Editor;\n});\n\nace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar UndoManager = function() {\n    this.$maxRev = 0;\n    this.$fromUndo = false;\n    this.reset();\n};\n\n(function() {\n    \n    this.addSession = function(session) {\n        this.$session = session;\n    };\n    this.add = function(delta, allowMerge, session) {\n        if (this.$fromUndo) return;\n        if (delta == this.$lastDelta) return;\n        if (allowMerge === false || !this.lastDeltas) {\n            this.lastDeltas = [];\n            this.$undoStack.push(this.lastDeltas);\n            delta.id = this.$rev = ++this.$maxRev;\n        }\n        if (delta.action == \"remove\" || delta.action == \"insert\")\n            this.$lastDelta = delta;\n        this.lastDeltas.push(delta);\n    };\n    \n    this.addSelection = function(selection, rev) {\n        this.selections.push({\n            value: selection,\n            rev: rev || this.$rev\n        });\n    };\n    \n    this.startNewGroup = function() {\n        this.lastDeltas = null;\n        return this.$rev;\n    };\n    \n    this.markIgnored = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id <= from)\n                break;\n            if (delta.id < to)\n                delta.ignore = true;\n        }\n        this.lastDeltas = null;\n    };\n    \n    this.getSelection = function(rev, after) {\n        var stack = this.selections;\n        for (var i = stack.length; i--;) {\n            var selection = stack[i];\n            if (selection.rev < rev) {\n                if (after)\n                    selection = stack[i + 1];\n                return selection;\n            }\n        }\n    };\n    \n    this.getRevision = function() {\n        return this.$rev;\n    };\n    \n    this.getDeltas = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        var end = null, start = 0;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id < to && !end)\n                end = i+1;\n            if (delta.id <= from) {\n                start = i + 1;\n                break;\n            }\n        }\n        return stack.slice(start, end);\n    };\n    \n    this.getChangedRanges = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n    \n    this.getChangedLines = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n    this.undo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        var stack = this.$undoStack;\n        \n        if (!rearrangeUndoStack(stack, stack.length))\n            return;\n        \n        if (!session)\n            session = this.$session;\n        \n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\n            this.$redoStack = [];\n        \n        this.$fromUndo = true;\n        \n        var deltaSet = stack.pop();\n        var undoSelectionRange = null;\n        if (deltaSet && deltaSet.length) {\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\n            this.$redoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        \n        this.$fromUndo = false;\n\n        return undoSelectionRange;\n    };\n    this.redo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        \n        if (!session)\n            session = this.$session;\n        \n        this.$fromUndo = true;\n        if (this.$redoStackBaseRev != this.$rev) {\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\n            rebaseRedoStack(this.$redoStack, diff);\n            this.$redoStackBaseRev = this.$rev;\n            this.$redoStack.forEach(function(x) {\n                x[0].id = ++this.$maxRev;\n            }, this);\n        }\n        var deltaSet = this.$redoStack.pop();\n        var redoSelectionRange = null;\n        \n        if (deltaSet) {\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\n            this.$undoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        \n        return redoSelectionRange;\n    };\n    \n    this.$syncRev = function() {\n        var stack = this.$undoStack;\n        var nextDelta = stack[stack.length - 1];\n        var id = nextDelta && nextDelta[0].id || 0;\n        this.$redoStackBaseRev = id;\n        this.$rev = id;\n    };\n    this.reset = function() {\n        this.lastDeltas = null;\n        this.$lastDelta = null;\n        this.$undoStack = [];\n        this.$redoStack = [];\n        this.$rev = 0;\n        this.mark = 0;\n        this.$redoStackBaseRev = this.$rev;\n        this.selections = [];\n    };\n    this.canUndo = function() {\n        return this.$undoStack.length > 0;\n    };\n    this.canRedo = function() {\n        return this.$redoStack.length > 0;\n    };\n    this.bookmark = function(rev) {\n        if (rev == undefined)\n            rev = this.$rev;\n        this.mark = rev;\n    };\n    this.isAtBookmark = function() {\n        return this.$rev === this.mark;\n    };\n    \n    this.toJSON = function() {\n        \n    };\n    \n    this.fromJSON = function() {\n        \n    };\n    \n    this.hasUndo = this.canUndo;\n    this.hasRedo = this.canRedo;\n    this.isClean = this.isAtBookmark;\n    this.markClean = this.bookmark;\n    \n    this.$prettyPrint = function(delta) {\n        if (delta) return stringifyDelta(delta);\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\n    };\n}).call(UndoManager.prototype);\n\nfunction rearrangeUndoStack(stack, pos) {\n    for (var i = pos; i--; ) {\n        var deltaSet = stack[i];\n        if (deltaSet && !deltaSet[0].ignore) {\n            while(i < pos - 1) {\n                var swapped = swapGroups(stack[i], stack[i + 1]);\n                stack[i] = swapped[0];\n                stack[i + 1] = swapped[1];\n                i++;\n            }\n            return true;\n        }\n    }\n}\n\nvar Range = require(\"./range\").Range;\nvar cmp = Range.comparePoints;\nvar comparePoints = Range.comparePoints;\n\nfunction $updateMarkers(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert) end = start;\n\n    for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = comparePoints(point, start);\n        if (cmp < 0) {\n            continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n            if (isInsert) {\n                if (point.bias == 1) {\n                    cmp = 1;\n                }\n                else {\n                    point.bias == -1;\n                    continue;\n                }\n            }\n        }\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\n        if (cmp2 > 0) {\n            point.row += rowShift;\n            point.column += point.row == end.row ? colShift : 0;\n            continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n            point.row = start.row;\n            point.column = start.column;\n            if (cmp2 === 0)\n                point.bias = 1;\n        }\n    }\n}\n\n\n\nfunction clonePos(pos) {\n    return {row: pos.row,column: pos.column};\n}\nfunction cloneDelta(d) {\n    return {\n        start: clonePos(d.start),\n        end: clonePos(d.end),\n        action: d.action,\n        lines: d.lines.slice()\n    };\n}\nfunction stringifyDelta(d) {\n    d = d || this;\n    if (Array.isArray(d)) {\n        return d.map(stringifyDelta).join(\"\\n\");\n    }\n    var type = \"\";\n    if (d.action) {\n        type = d.action == \"insert\" ? \"+\" : \"-\";\n        type += \"[\" + d.lines + \"]\";\n    } else if (d.value) {\n        if (Array.isArray(d.value)) {\n            type = d.value.map(stringifyRange).join(\"\\n\");\n        } else {\n            type = stringifyRange(d.value);\n        }\n    }\n    if (d.start) {\n        type += stringifyRange(d);\n    }\n    if (d.id || d.rev) {\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\n    }\n    return type;\n}\nfunction stringifyRange(r) {\n    return r.start.row + \":\" + r.start.column \n        + \"=>\" + r.end.row + \":\" + r.end.column;\n}\n\nfunction swap(d1, d2) {\n    var i1 = d1.action == \"insert\";\n    var i2 = d2.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    }\n    return [d2, d1];\n}\nfunction swapGroups(ds1, ds2) {\n    for (var i = ds1.length; i--; ) {\n        for (var j = 0; j < ds2.length; j++) {\n            if (!swap(ds1[i], ds2[j])) {\n                while (i < ds1.length) {\n                    while (j--) {\n                        swap(ds2[j], ds1[i]);\n                    }\n                    j = ds2.length;\n                    i++;\n                }                \n                return [ds1, ds2];\n            }\n        }\n    }\n    ds1.selectionBefore = ds2.selectionBefore = \n    ds1.selectionAfter = ds2.selectionAfter = null;\n    return [ds2, ds1];\n}\nfunction xform(d1, c1) {\n    var i1 = d1.action == \"insert\";\n    var i2 = c1.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d1.start, c1.start) < 0) {\n            shift(c1, d1, 1);\n        } else {\n            shift(d1, c1, 1);\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d1.start, c1.end) >= 0) {\n            shift(d1, c1, -1);\n        } else if (cmp(d1.start, c1.start) <= 0) {\n            shift(c1, d1, +1);\n        } else {\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\n            shift(c1, d1, +1);\n        }\n    } else if (!i1 && i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.start, d1.start) <= 0) {\n            shift(d1, c1, +1);\n        } else {\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\n            shift(d1, c1, +1);\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.end, d1.start) <= 0) {\n            shift(d1, c1, -1);\n        } else {\n            var before, after;\n            if (cmp(d1.start, c1.start) < 0) {\n                before = d1;\n                d1 = splitDelta(d1, c1.start);\n            }\n            if (cmp(d1.end, c1.end) > 0) {\n                after = splitDelta(d1, c1.end);\n            }\n\n            shiftPos(c1.end, d1.start, d1.end, -1);\n            if (after && !before) {\n                d1.lines = after.lines;\n                d1.start = after.start;\n                d1.end = after.end;\n                after = d1;\n            }\n\n            return [c1, before, after].filter(Boolean);\n        }\n    }\n    return [c1, d1];\n}\n    \nfunction shift(d1, d2, dir) {\n    shiftPos(d1.start, d2.start, d2.end, dir);\n    shiftPos(d1.end, d2.start, d2.end, dir);\n}\nfunction shiftPos(pos, start, end, dir) {\n    if (pos.row == (dir == 1 ? start : end).row) {\n        pos.column += dir * (end.column - start.column);\n    }\n    pos.row += dir * (end.row - start.row);\n}\nfunction splitDelta(c, pos) {\n    var lines = c.lines;\n    var end = c.end;\n    c.end = clonePos(pos);    \n    var rowsBefore = c.end.row - c.start.row;\n    var otherLines = lines.splice(rowsBefore, lines.length);\n    \n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\n    lines.push(otherLines[0].substring(0, col));\n    otherLines[0] = otherLines[0].substr(col)   ; \n    var rest = {\n        start: clonePos(pos),\n        end: end,\n        lines: otherLines,\n        action: c.action\n    };\n    return rest;\n}\n\nfunction moveDeltasByOne(redoStack, d) {\n    d = cloneDelta(d);\n    for (var j = redoStack.length; j--;) {\n        var deltaSet = redoStack[j];\n        for (var i = 0; i < deltaSet.length; i++) {\n            var x = deltaSet[i];\n            var xformed = xform(x, d);\n            d = xformed[0];\n            if (xformed.length != 2) {\n                if (xformed[2]) {\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\n                    i++;\n                } else if (!xformed[1]) {\n                    deltaSet.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (!deltaSet.length) {\n            redoStack.splice(j, 1); \n        }\n    }\n    return redoStack;\n}\nfunction rebaseRedoStack(redoStack, deltaSets) {\n    for (var i = 0; i < deltaSets.length; i++) {\n        var deltas = deltaSets[i];\n        for (var j = 0; j < deltas.length; j++) {\n            moveDeltasByOne(redoStack, deltas[j]);\n        }\n    }\n}\n\nexports.UndoManager = UndoManager;\n\n});\n\nace.define(\"ace/layer/lines\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Lines = function(element, canvasHeight) {\n    this.element = element;\n    this.canvasHeight = canvasHeight || 500000;\n    this.element.style.height = (this.canvasHeight * 2) + \"px\";\n    \n    this.cells = [];\n    this.cellCache = [];\n    this.$offsetCoefficient = 0;\n};\n\n(function() {\n    \n    this.moveContainer = function(config) {\n        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);\n    };    \n    \n    this.pageChanged = function(oldConfig, newConfig) {\n        return (\n            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==\n            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)\n        );\n    };\n    \n    this.computeLineTop = function(row, config, session) {\n        var screenTop = config.firstRowScreen * config.lineHeight;\n        var screenPage = Math.floor(screenTop / this.canvasHeight);\n        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;\n        return lineTop - (screenPage * this.canvasHeight);\n    };\n    \n    this.computeLineHeight = function(row, config, session) {\n        return config.lineHeight * session.getRowLength(row);\n    };\n    \n    this.getLength = function() {\n        return this.cells.length;\n    };\n    \n    this.get = function(index) {\n        return this.cells[index];\n    };\n    \n    this.shift = function() {\n        this.$cacheCell(this.cells.shift());\n    };\n    \n    this.pop = function() {\n        this.$cacheCell(this.cells.pop());\n    };\n    \n    this.push = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.push.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            this.element.appendChild(fragment);\n         } else {\n            this.cells.push(cell);\n            this.element.appendChild(cell.element);\n         }\n    };\n    \n    this.unshift = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.unshift.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            if (this.element.firstChild)\n                this.element.insertBefore(fragment, this.element.firstChild);\n            else\n                this.element.appendChild(fragment);\n         } else {\n            this.cells.unshift(cell);\n            this.element.insertAdjacentElement(\"afterbegin\", cell.element);\n         }\n    };\n    \n    this.last = function() {\n        if (this.cells.length)\n            return this.cells[this.cells.length-1];\n        else\n            return null;\n    };\n    \n    this.$cacheCell = function(cell) {\n        if (!cell)\n            return;\n            \n        cell.element.remove();\n        this.cellCache.push(cell);\n    };\n    \n    this.createCell = function(row, config, session, initElement) {\n        var cell = this.cellCache.pop();\n        if (!cell) {\n            var element = dom.createElement(\"div\");\n            if (initElement)\n                initElement(element);\n            \n            this.element.appendChild(element);\n            \n            cell = {\n                element: element,\n                text: \"\",\n                row: row\n            };\n        }\n        cell.row = row;\n        \n        return cell;\n    };\n    \n}).call(Lines.prototype);\n\nexports.Lines = Lines;\n\n});\n\nace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/layer/lines\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Lines = require(\"./lines\").Lines;\n\nvar Gutter = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_gutter-layer\";\n    parentEl.appendChild(this.element);\n    this.setShowFoldWidgets(this.$showFoldWidgets);\n    \n    this.gutterWidth = 0;\n\n    this.$annotations = [];\n    this.$updateAnnotations = this.$updateAnnotations.bind(this);\n    \n    this.$lines = new Lines(this.element);\n    this.$lines.$offsetCoefficient = 1;\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.removeEventListener(\"change\", this.$updateAnnotations);\n        this.session = session;\n        if (session)\n            session.on(\"change\", this.$updateAnnotations);\n    };\n\n    this.addGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n        this.session.addGutterDecoration(row, className);\n    };\n\n    this.removeGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n        this.session.removeGutterDecoration(row, className);\n    };\n\n    this.setAnnotations = function(annotations) {\n        this.$annotations = [];\n        for (var i = 0; i < annotations.length; i++) {\n            var annotation = annotations[i];\n            var row = annotation.row;\n            var rowInfo = this.$annotations[row];\n            if (!rowInfo)\n                rowInfo = this.$annotations[row] = {text: []};\n           \n            var annoText = annotation.text;\n            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n\n            if (rowInfo.text.indexOf(annoText) === -1)\n                rowInfo.text.push(annoText);\n\n            var type = annotation.type;\n            if (type == \"error\")\n                rowInfo.className = \" ace_error\";\n            else if (type == \"warning\" && rowInfo.className != \" ace_error\")\n                rowInfo.className = \" ace_warning\";\n            else if (type == \"info\" && (!rowInfo.className))\n                rowInfo.className = \" ace_info\";\n        }\n    };\n\n    this.$updateAnnotations = function (delta) {\n        if (!this.$annotations.length)\n            return;\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n        } else if (delta.action == 'remove') {\n            this.$annotations.splice(firstRow, len + 1, null);\n        } else {\n            var args = new Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.$annotations.splice.apply(this.$annotations, args);\n        }\n    };\n\n    this.update = function(config) {\n        this.config = config;\n        \n        var session = this.session;\n        var firstRow = config.firstRow;\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            session.getLength() - 1);\n            \n        this.oldLastRow = lastRow;\n        this.config = config;\n        \n        this.$lines.moveContainer(config);\n        this.$updateCursorRow();\n            \n        var fold = session.getNextFoldLine(firstRow);\n        var foldStart = fold ? fold.start.row : Infinity;\n\n        var cell = null;\n        var index = -1;\n        var row = firstRow;\n        \n        while (true) {\n            if (row > foldStart) {\n                row = fold.end.row + 1;\n                fold = session.getNextFoldLine(row, fold);\n                foldStart = fold ? fold.start.row : Infinity;\n            }\n            if (row > lastRow) {\n                while (this.$lines.getLength() > index + 1)\n                    this.$lines.pop();\n                    \n                break;\n            }\n\n            cell = this.$lines.get(++index);\n            if (cell) {\n                cell.row = row;\n            } else {\n                cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n                this.$lines.push(cell);\n            }\n\n            this.$renderCell(cell, config, fold, row);\n            row++;\n        }\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$updateGutterWidth = function(config) {\n        var session = this.session;\n        \n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        \n        var firstLineNumber = session.$firstLineNumber;\n        var lastLineText = this.$lines.last() ? this.$lines.last().text : \"\";\n        \n        if (this.$fixedWidth || session.$useWrapMode)\n            lastLineText = session.getLength() + firstLineNumber - 1;\n\n        var gutterWidth = gutterRenderer \n            ? gutterRenderer.getWidth(session, lastLineText, config)\n            : lastLineText.toString().length * config.characterWidth;\n        \n        var padding = this.$padding || this.$computePadding();\n        gutterWidth += padding.left + padding.right;\n        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n            this.gutterWidth = gutterWidth;\n            this.element.parentNode.style.width = \n            this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n            this._signal(\"changeGutterWidth\", gutterWidth);\n        }\n    };\n    \n    this.$updateCursorRow = function() {\n        if (!this.$highlightGutterLine)\n            return;\n            \n        var position = this.session.selection.getCursor();\n        if (this.$cursorRow === position.row)\n            return;\n        \n        this.$cursorRow = position.row;\n    };\n    \n    this.updateLineHighlight = function() {\n        if (!this.$highlightGutterLine)\n            return;\n        var row = this.session.selection.cursor.row;\n        this.$cursorRow = row;\n\n        if (this.$cursorCell && this.$cursorCell.row == row)\n            return;\n        if (this.$cursorCell)\n            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n        var cells = this.$lines.cells;\n        this.$cursorCell = null;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            if (cell.row >= this.$cursorRow) {\n                if (cell.row > this.$cursorRow) {\n                    var fold = this.session.getFoldLine(this.$cursorRow);\n                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)\n                        cell = cells[i - 1];\n                    else\n                        break;\n                }\n                cell.element.className = \"ace_gutter-active-line \" + cell.element.className;\n                this.$cursorCell = cell;\n                break;\n            }\n        }\n    };\n    \n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n        \n        this.$updateCursorRow();\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        \n        this.$lines.moveContainer(config);\n\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            this.session.getLength() - 1);\n        var oldLastRow = this.oldLastRow;\n        this.oldLastRow = lastRow;\n        \n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldLastRow > lastRow)\n            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (lastRow > oldLastRow) {\n            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));\n        }\n        \n        this.updateLineHighlight();\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$renderLines = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n            this.$renderCell(cell, config, foldLine, row);\n            fragment.push(cell);\n\n            row++;\n        }\n        return fragment;\n    };\n    \n    this.$renderCell = function(cell, config, fold, row) {\n        var element = cell.element;\n        \n        var session = this.session;\n        \n        var textNode = element.childNodes[0];\n        var foldWidget = element.childNodes[1];\n\n        var firstLineNumber = session.$firstLineNumber;\n        \n        var breakpoints = session.$breakpoints;\n        var decorations = session.$decorations;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;\n        \n        var className = \"ace_gutter-cell \";\n        if (this.$highlightGutterLine) {\n            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {\n                className += \"ace_gutter-active-line \";\n                if (this.$cursorCell != cell) {\n                    if (this.$cursorCell)\n                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n                    this.$cursorCell = cell;\n                }\n            }\n        }\n        \n        if (breakpoints[row])\n            className += breakpoints[row];\n        if (decorations[row])\n            className += decorations[row];\n        if (this.$annotations[row])\n            className += this.$annotations[row].className;\n        if (element.className != className)\n            element.className = className;\n\n        if (foldWidgets) {\n            var c = foldWidgets[row];\n            if (c == null)\n                c = foldWidgets[row] = session.getFoldWidget(row);\n        }\n\n        if (c) {\n            var className = \"ace_fold-widget ace_\" + c;\n            if (c == \"start\" && row == foldStart && row < fold.end.row)\n                className += \" ace_closed\";\n            else\n                className += \" ace_open\";\n            if (foldWidget.className != className)\n                foldWidget.className = className;\n\n            var foldHeight = config.lineHeight + \"px\";\n            dom.setStyle(foldWidget.style, \"height\", foldHeight);\n            dom.setStyle(foldWidget.style, \"display\", \"inline-block\");\n        } else {\n            if (foldWidget) {\n                dom.setStyle(foldWidget.style, \"display\", \"none\");\n            }\n        }\n        \n        var text = (gutterRenderer\n            ? gutterRenderer.getText(session, row)\n            : row + firstLineNumber).toString();\n            \n        if (text !== textNode.data) {\n            textNode.data = text;\n        }\n        \n        dom.setStyle(cell.element.style, \"height\", this.$lines.computeLineHeight(row, config, session) + \"px\");\n        dom.setStyle(cell.element.style, \"top\", this.$lines.computeLineTop(row, config, session) + \"px\");\n        \n        cell.text = text;\n        return cell;\n    };\n\n    this.$fixedWidth = false;\n    \n    this.$highlightGutterLine = true;\n    this.$renderer = \"\";\n    this.setHighlightGutterLine = function(highlightGutterLine) {\n        this.$highlightGutterLine = highlightGutterLine;\n    };\n    \n    this.$showLineNumbers = true;\n    this.$renderer = \"\";\n    this.setShowLineNumbers = function(show) {\n        this.$renderer = !show && {\n            getWidth: function() {return 0;},\n            getText: function() {return \"\";}\n        };\n    };\n    \n    this.getShowLineNumbers = function() {\n        return this.$showLineNumbers;\n    };\n    \n    this.$showFoldWidgets = true;\n    this.setShowFoldWidgets = function(show) {\n        if (show)\n            dom.addCssClass(this.element, \"ace_folding-enabled\");\n        else\n            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n\n        this.$showFoldWidgets = show;\n        this.$padding = null;\n    };\n    \n    this.getShowFoldWidgets = function() {\n        return this.$showFoldWidgets;\n    };\n\n    this.$computePadding = function() {\n        if (!this.element.firstChild)\n            return {left: 0, right: 0};\n        var style = dom.computedStyle(this.element.firstChild);\n        this.$padding = {};\n        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)\n            + (parseInt(style.paddingLeft) || 0) + 1;\n        this.$padding.right = (parseInt(style.borderRightWidth) || 0)\n            + (parseInt(style.paddingRight) || 0);\n        return this.$padding;\n    };\n\n    this.getRegion = function(point) {\n        var padding = this.$padding || this.$computePadding();\n        var rect = this.element.getBoundingClientRect();\n        if (point.x < padding.left + rect.left)\n            return \"markers\";\n        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n            return \"foldWidgets\";\n    };\n\n}).call(Gutter.prototype);\n\nfunction onCreateCell(element) {\n    var textNode = document.createTextNode('');\n    element.appendChild(textNode);\n    \n    var foldWidget = dom.createElement(\"span\");\n    element.appendChild(foldWidget);\n    \n    return element;\n}\n\nexports.Gutter = Gutter;\n\n});\n\nace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar dom = require(\"../lib/dom\");\n\nvar Marker = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_marker-layer\";\n    parentEl.appendChild(this.element);\n};\n\n(function() {\n\n    this.$padding = 0;\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n    this.setSession = function(session) {\n        this.session = session;\n    };\n    \n    this.setMarkers = function(markers) {\n        this.markers = markers;\n    };\n    \n    this.elt = function(className, css) {\n        var x = this.i != -1 && this.element.childNodes[this.i];\n        if (!x) {\n            x = document.createElement(\"div\");\n            this.element.appendChild(x);\n            this.i = -1;\n        } else {\n            this.i++;\n        }\n        x.style.cssText = css;\n        x.className = className;\n    };\n\n    this.update = function(config) {\n        if (!config) return;\n\n        this.config = config;\n\n        this.i = 0;\n        var html;\n        for (var key in this.markers) {\n            var marker = this.markers[key];\n\n            if (!marker.range) {\n                marker.update(html, this, this.session, config);\n                continue;\n            }\n\n            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n            if (range.isEmpty()) continue;\n\n            range = range.toScreenRange(this.session);\n            if (marker.renderer) {\n                var top = this.$getTop(range.start.row, config);\n                var left = this.$padding + range.start.column * config.characterWidth;\n                marker.renderer(html, range, left, top, config);\n            } else if (marker.type == \"fullLine\") {\n                this.drawFullLineMarker(html, range, marker.clazz, config);\n            } else if (marker.type == \"screenLine\") {\n                this.drawScreenLineMarker(html, range, marker.clazz, config);\n            } else if (range.isMultiLine()) {\n                if (marker.type == \"text\")\n                    this.drawTextMarker(html, range, marker.clazz, config);\n                else\n                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n            } else {\n                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\" + \" ace_br15\", config);\n            }\n        }\n        if (this.i !=-1) {\n            while (this.i < this.element.childElementCount)\n                this.element.removeChild(this.element.lastChild);\n        }\n    };\n\n    this.$getTop = function(row, layerConfig) {\n        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n    };\n\n    function getBorderClass(tl, tr, br, bl) {\n        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);\n    }\n    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {\n        var session = this.session;\n        var start = range.start.row;\n        var end = range.end.row;\n        var row = start;\n        var prev = 0; \n        var curr = 0;\n        var next = session.getScreenLastRowColumn(row);\n        var lineRange = new Range(row, range.start.column, row, curr);\n        for (; row <= end; row++) {\n            lineRange.start.row = lineRange.end.row = row;\n            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);\n            lineRange.end.column = next;\n            prev = curr;\n            curr = next;\n            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;\n            this.drawSingleLineMarker(stringBuilder, lineRange, \n                clazz + (row == start  ? \" ace_start\" : \"\") + \" ace_br\"\n                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),\n                layerConfig, row == end ? 0 : 1, extraStyle);\n        }\n    };\n    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var padding = this.$padding;\n        var height = config.lineHeight;\n        var top = this.$getTop(range.start.row, config);\n        var left = padding + range.start.column * config.characterWidth;\n        extraStyle = extraStyle || \"\";\n\n        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {\n           var range1 = range.clone();\n           range1.end.row = range1.start.row;\n           range1.end.column = this.session.getLine(range1.start.row).length;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br1 ace_start\", config, null, extraStyle);\n        } else {\n            this.elt(\n                clazz + \" ace_br1 ace_start\",\n                \"height:\"+ height+ \"px;\"+ \"right:0;\"+ \"top:\"+top+ \"px;left:\"+ left+ \"px;\" + (extraStyle || \"\")\n            );\n        }\n        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {\n           var range1 = range.clone();\n           range1.start.row = range1.end.row;\n           range1.start.column = 0;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br12\", config, null, extraStyle);\n        } else {\n            top = this.$getTop(range.end.row, config);\n            var width = range.end.column * config.characterWidth;\n\n            this.elt(\n                clazz + \" ace_br12\",\n                \"height:\"+ height+ \"px;\"+\n                \"width:\"+ width+ \"px;\"+\n                \"top:\"+ top+ \"px;\"+\n                \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n            );\n        }\n        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n        if (height <= 0)\n            return;\n        top = this.$getTop(range.start.row + 1, config);\n        \n        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);\n\n        this.elt(\n            clazz + (radiusClass ? \" ace_br\" + radiusClass : \"\"),\n            \"height:\"+ height+ \"px;\"+\n            \"right:0;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        if (this.session.$bidiHandler.isBidiRow(range.start.row))\n            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);\n        var height = config.lineHeight;\n        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n\n        var top = this.$getTop(range.start.row, config);\n        var left = this.$padding + range.start.column * config.characterWidth;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"width:\"+ width+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ left+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;\n        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);\n\n        selections.forEach(function(selection) {\n            this.elt(\n                clazz,\n                \"height:\" + height + \"px;\" +\n                \"width:\" + selection.width + (extraLength || 0) + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + (padding + selection.left) + \"px;\" + (extraStyle || \"\")\n            );\n        }, this);\n    };\n\n    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        if (range.start.row != range.end.row)\n            height += this.$getTop(range.end.row, config) - top;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n    \n    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n\n}).call(Marker.prototype);\n\nexports.Marker = Marker;\n\n});\n\nace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/layer/lines\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar Lines = require(\"./lines\").Lines;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar Text = function(parentEl) {\n    this.dom = dom; \n    this.element = this.dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_text-layer\";\n    parentEl.appendChild(this.element);\n    this.$updateEolChar = this.$updateEolChar.bind(this);\n    this.$lines = new Lines(this.element);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.EOF_CHAR = \"\\xB6\";\n    this.EOL_CHAR_LF = \"\\xAC\";\n    this.EOL_CHAR_CRLF = \"\\xa4\";\n    this.EOL_CHAR = this.EOL_CHAR_LF;\n    this.TAB_CHAR = \"\\u2014\"; //\"\\u21E5\";\n    this.SPACE_CHAR = \"\\xB7\";\n    this.$padding = 0;\n    this.MAX_LINE_LENGTH = 10000;\n\n    this.$updateEolChar = function() {\n        var doc = this.session.doc;\n        var unixMode = doc.getNewLineCharacter() == \"\\n\" && doc.getNewLineMode() != \"windows\";\n        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;\n        if (this.EOL_CHAR != EOL_CHAR) {\n            this.EOL_CHAR = EOL_CHAR;\n            return true;\n        }\n    };\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.element.style.margin = \"0 \" + padding + \"px\";\n    };\n\n    this.getLineHeight = function() {\n        return this.$fontMetrics.$characterSize.height || 0;\n    };\n\n    this.getCharacterWidth = function() {\n        return this.$fontMetrics.$characterSize.width || 0;\n    };\n    \n    this.$setFontMetrics = function(measure) {\n        this.$fontMetrics = measure;\n        this.$fontMetrics.on(\"changeCharacterSize\", function(e) {\n            this._signal(\"changeCharacterSize\", e);\n        }.bind(this));\n        this.$pollSizeChanges();\n    };\n\n    this.checkForSizeChanges = function() {\n        this.$fontMetrics.checkForSizeChanges();\n    };\n    this.$pollSizeChanges = function() {\n        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n    };\n    this.setSession = function(session) {\n        this.session = session;\n        if (session)\n            this.$computeTabString();\n    };\n\n    this.showInvisibles = false;\n    this.setShowInvisibles = function(showInvisibles) {\n        if (this.showInvisibles == showInvisibles)\n            return false;\n\n        this.showInvisibles = showInvisibles;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.displayIndentGuides = true;\n    this.setDisplayIndentGuides = function(display) {\n        if (this.displayIndentGuides == display)\n            return false;\n\n        this.displayIndentGuides = display;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.$tabStrings = [];\n    this.onChangeTabSize =\n    this.$computeTabString = function() {\n        var tabSize = this.session.getTabSize();\n        this.tabSize = tabSize;\n        var tabStr = this.$tabStrings = [0];\n        for (var i = 1; i < tabSize + 1; i++) {\n            if (this.showInvisibles) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_tab\";\n                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);\n                tabStr.push(span);\n            } else {\n                tabStr.push(this.dom.createTextNode(lang.stringRepeat(\" \", i), this.element));\n            }\n        }\n        if (this.displayIndentGuides) {\n            this.$indentGuideRe =  /\\s\\S| \\t|\\t |\\s$/;\n            var className = \"ace_indent-guide\";\n            var spaceClass = \"\";\n            var tabClass = \"\";\n            if (this.showInvisibles) {\n                className += \" ace_invisible\";\n                spaceClass = \" ace_invisible_space\";\n                tabClass = \" ace_invisible_tab\";\n                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);\n                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);\n            } else {\n                var spaceContent = lang.stringRepeat(\" \", this.tabSize);\n                var tabContent = spaceContent;\n            }\n\n            var span = this.dom.createElement(\"span\");\n            span.className = className + spaceClass;\n            span.textContent = spaceContent;\n            this.$tabStrings[\" \"] = span;\n            \n            var span = this.dom.createElement(\"span\");\n            span.className = className + tabClass;\n            span.textContent = tabContent;\n            this.$tabStrings[\"\\t\"] = span;\n        }\n    };\n\n    this.updateLines = function(config, firstRow, lastRow) {\n        if (this.config.lastRow != config.lastRow ||\n            this.config.firstRow != config.firstRow) {\n            return this.update(config);\n        }\n        \n        this.config = config;\n\n        var first = Math.max(firstRow, config.firstRow);\n        var last = Math.min(lastRow, config.lastRow);\n\n        var lineElements = this.element.childNodes;\n        var lineElementsIdx = 0;\n\n        for (var row = config.firstRow; row < first; row++) {\n            var foldLine = this.session.getFoldLine(row);\n            if (foldLine) {\n                if (foldLine.containsRow(first)) {\n                    first = foldLine.start.row;\n                    break;\n                } else {\n                    row = foldLine.end.row;\n                }\n            }\n            lineElementsIdx ++;\n        }\n\n        var heightChanged = false;\n        var row = first;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row :Infinity;\n            }\n            if (row > last)\n                break;\n\n            var lineElement = lineElements[lineElementsIdx++];\n            if (lineElement) {\n                this.dom.removeChildren(lineElement);\n                this.$renderLine(\n                    lineElement, row, row == foldStart ? foldLine : false\n                );\n                var height = (config.lineHeight * this.session.getRowLength(row)) + \"px\";\n                if (lineElement.style.height != height) {\n                    heightChanged = true;\n                    lineElement.style.height = height;\n                }\n            }\n            row++;\n        }\n        if (heightChanged) {\n            while (lineElementsIdx < this.$lines.cells.length) {\n                var cell = this.$lines.cells[lineElementsIdx++];\n                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + \"px\";\n            }\n        }\n    };\n\n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n            \n        this.$lines.moveContainer(config);\n        \n        var lastRow = config.lastRow;\n        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;\n\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n            return this.update(config);\n\n        if (config.lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldConfig.lastRow > config.lastRow)\n            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (config.lastRow > oldConfig.lastRow) {\n            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));\n        }\n    };\n\n    this.$renderLinesFragment = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var line = this.$lines.createCell(row, config, this.session);\n            \n            var lineEl = line.element;\n            this.dom.removeChildren(lineEl);\n            dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\");\n            dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\");\n            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);\n\n            if (this.$useLineGroups()) {\n                lineEl.className = \"ace_line_group\";\n            } else {\n                lineEl.className = \"ace_line\";\n            }\n            fragment.push(line);\n\n            row++;\n        }\n        return fragment;\n    };\n\n    this.update = function(config) {\n        this.$lines.moveContainer(config);\n        \n        this.config = config;\n\n        var firstRow = config.firstRow;\n        var lastRow = config.lastRow;\n\n        var lines = this.$lines;\n        while (lines.getLength())\n            lines.pop();\n            \n        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));\n    };\n\n    this.$textToken = {\n        \"text\": true,\n        \"rparen\": true,\n        \"lparen\": true\n    };\n\n    this.$renderToken = function(parent, screenColumn, token, value) {\n        var self = this;\n        var re = /(\\t)|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\uFEFF\\uFFF9-\\uFFFC]+)|(\\u3000)|([\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3001-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n        \n        var valueFragment = this.dom.createFragment(this.element);\n\n        var m;\n        var i = 0;\n        while (m = re.exec(value)) {\n            var tab = m[1];\n            var simpleSpace = m[2];\n            var controlCharacter = m[3];\n            var cjkSpace = m[4];\n            var cjk = m[5];\n            \n            if (!self.showInvisibles && simpleSpace)\n                continue;\n\n            var before = i != m.index ? value.slice(i, m.index) : \"\";\n\n            i = m.index + m[0].length;\n            \n            if (before) {\n                valueFragment.appendChild(this.dom.createTextNode(before, this.element));\n            }\n                \n            if (tab) {\n                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);\n                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));\n                screenColumn += tabSize - 1;\n            } else if (simpleSpace) {\n                if (self.showInvisibles) {\n                    var span = this.dom.createElement(\"span\");\n                    span.className = \"ace_invisible ace_invisible_space\";\n                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);\n                    valueFragment.appendChild(span);\n                } else {\n                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));\n                }\n            } else if (controlCharacter) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_space ace_invalid\";\n                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);\n                valueFragment.appendChild(span);\n            } else if (cjkSpace) {\n                var space = self.showInvisibles ? self.SPACE_CHAR : \"\";\n                screenColumn += 1;\n                \n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = self.showInvisibles ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n                span.textContent = self.showInvisibles ? self.SPACE_CHAR : \"\";\n                valueFragment.appendChild(span);\n            } else if (cjk) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = \"ace_cjk\";\n                span.textContent = cjk;\n                valueFragment.appendChild(span);\n            }\n        }\n        \n        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));\n\n        if (!this.$textToken[token.type]) {\n            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n            var span = this.dom.createElement(\"span\");\n            if (token.type == \"fold\")\n                span.style.width = (token.value.length * this.config.characterWidth) + \"px\";\n                \n            span.className = classes;\n            span.appendChild(valueFragment);\n            \n            parent.appendChild(span);\n        }\n        else {\n            parent.appendChild(valueFragment);\n        }\n        \n        return screenColumn + value.length;\n    };\n\n    this.renderIndentGuide = function(parent, value, max) {\n        var cols = value.search(this.$indentGuideRe);\n        if (cols <= 0 || cols >= max)\n            return value;\n        if (value[0] == \" \") {\n            cols -= cols % this.tabSize;\n            var count = cols/this.tabSize;\n            for (var i=0; i<count; i++) {\n                parent.appendChild(this.$tabStrings[\" \"].cloneNode(true));\n            }\n            return value.substr(cols);\n        } else if (value[0] == \"\\t\") {\n            for (var i=0; i<cols; i++) {\n                parent.appendChild(this.$tabStrings[\"\\t\"].cloneNode(true));\n            }\n            return value.substr(cols);\n        }\n        return value;\n    };\n\n    this.$createLineElement = function(parent) {\n        var lineEl = this.dom.createElement(\"div\");\n        lineEl.className = \"ace_line\";\n        lineEl.style.height = this.config.lineHeight + \"px\";\n        \n        return lineEl;\n    };\n\n    this.$renderWrappedLine = function(parent, tokens, splits) {\n        var chars = 0;\n        var split = 0;\n        var splitChars = splits[0];\n        var screenColumn = 0;\n\n        var lineEl = this.$createLineElement();\n        parent.appendChild(lineEl);\n        \n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                chars = value.length;\n                value = this.renderIndentGuide(lineEl, value, splitChars);\n                if (!value)\n                    continue;\n                chars -= value.length;\n            }\n\n            if (chars + value.length < splitChars) {\n                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                chars += value.length;\n            } else {\n                while (chars + value.length >= splitChars) {\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn,\n                        token, value.substring(0, splitChars - chars)\n                    );\n                    value = value.substring(splitChars - chars);\n                    chars = splitChars;\n\n                    lineEl = this.$createLineElement();\n                    parent.appendChild(lineEl);\n\n                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(\"\\xa0\", splits.indent), this.element));\n\n                    split ++;\n                    screenColumn = 0;\n                    splitChars = splits[split] || Number.MAX_VALUE;\n                }\n                if (value.length != 0) {\n                    chars += value.length;\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn, token, value\n                    );\n                }\n            }\n        }\n    };\n\n    this.$renderSimpleLine = function(parent, tokens) {\n        var screenColumn = 0;\n        var token = tokens[0];\n        var value = token.value;\n        if (this.displayIndentGuides)\n            value = this.renderIndentGuide(parent, value);\n        if (value)\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        for (var i = 1; i < tokens.length; i++) {\n            token = tokens[i];\n            value = token.value;\n            if (screenColumn + value.length > this.MAX_LINE_LENGTH)\n                return this.$renderOverflowMessage(parent, screenColumn, token, value);\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        }\n    };\n    \n    this.$renderOverflowMessage = function(parent, screenColumn, token, value) {\n        this.$renderToken(parent, screenColumn, token,\n            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));\n            \n        var overflowEl = this.dom.createElement(\"span\");\n        overflowEl.className = \"ace_inline_button ace_keyword ace_toggle_wrap\";\n        overflowEl.style.position = \"absolute\";\n        overflowEl.style.right = \"0\";\n        overflowEl.textContent = \"<click to see more...>\";\n        \n        parent.appendChild(overflowEl);        \n    };\n    this.$renderLine = function(parent, row, foldLine) {\n        if (!foldLine && foldLine != false)\n            foldLine = this.session.getFoldLine(row);\n\n        if (foldLine)\n            var tokens = this.$getFoldLineTokens(row, foldLine);\n        else\n            var tokens = this.session.getTokens(row);\n\n        var lastLineEl = parent;\n        if (tokens.length) {\n            var splits = this.session.getRowSplitData(row);\n            if (splits && splits.length) {\n                this.$renderWrappedLine(parent, tokens, splits);\n                var lastLineEl = parent.lastChild;\n            } else {\n                var lastLineEl = parent;\n                if (this.$useLineGroups()) {\n                    lastLineEl = this.$createLineElement();\n                    parent.appendChild(lastLineEl);\n                }\n                this.$renderSimpleLine(lastLineEl, tokens);\n            }\n        } else if (this.$useLineGroups()) {\n            lastLineEl = this.$createLineElement();\n            parent.appendChild(lastLineEl);\n        }\n\n        if (this.showInvisibles && lastLineEl) {\n            if (foldLine)\n                row = foldLine.end.row;\n\n            var invisibleEl = this.dom.createElement(\"span\");\n            invisibleEl.className = \"ace_invisible ace_invisible_eol\";\n            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;\n            \n            lastLineEl.appendChild(invisibleEl);\n        }\n    };\n\n    this.$getFoldLineTokens = function(row, foldLine) {\n        var session = this.session;\n        var renderTokens = [];\n\n        function addTokens(tokens, from, to) {\n            var idx = 0, col = 0;\n            while ((col + tokens[idx].value.length) < from) {\n                col += tokens[idx].value.length;\n                idx++;\n\n                if (idx == tokens.length)\n                    return;\n            }\n            if (col != from) {\n                var value = tokens[idx].value.substring(from - col);\n                if (value.length > (to - from))\n                    value = value.substring(0, to - from);\n\n                renderTokens.push({\n                    type: tokens[idx].type,\n                    value: value\n                });\n\n                col = from + value.length;\n                idx += 1;\n            }\n\n            while (col < to && idx < tokens.length) {\n                var value = tokens[idx].value;\n                if (value.length + col > to) {\n                    renderTokens.push({\n                        type: tokens[idx].type,\n                        value: value.substring(0, to - col)\n                    });\n                } else\n                    renderTokens.push(tokens[idx]);\n                col += value.length;\n                idx += 1;\n            }\n        }\n\n        var tokens = session.getTokens(row);\n        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {\n            if (placeholder != null) {\n                renderTokens.push({\n                    type: \"fold\",\n                    value: placeholder\n                });\n            } else {\n                if (isNewRow)\n                    tokens = session.getTokens(row);\n\n                if (tokens.length)\n                    addTokens(tokens, lastColumn, column);\n            }\n        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n\n        return renderTokens;\n    };\n\n    this.$useLineGroups = function() {\n        return this.session.getUseWrapMode();\n    };\n\n    this.destroy = function() {};\n}).call(Text.prototype);\n\nexports.Text = Text;\n\n});\n\nace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Cursor = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_cursor-layer\";\n    parentEl.appendChild(this.element);\n    \n    this.isVisible = false;\n    this.isBlinking = true;\n    this.blinkInterval = 1000;\n    this.smoothBlinking = false;\n\n    this.cursors = [];\n    this.cursor = this.addCursor();\n    dom.addCssClass(this.element, \"ace_hidden-cursors\");\n    this.$updateCursors = this.$updateOpacity.bind(this);\n};\n\n(function() {\n    \n    this.$updateOpacity = function(val) {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            dom.setStyle(cursors[i].style, \"opacity\", val ? \"\" : \"0\");\n    };\n\n    this.$startCssAnimation = function() {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            cursors[i].style.animationDuration = this.blinkInterval + \"ms\";\n\n        setTimeout(function() {\n            dom.addCssClass(this.element, \"ace_animate-blinking\");\n        }.bind(this));\n    };\n    \n    this.$stopCssAnimation = function() {\n        dom.removeCssClass(this.element, \"ace_animate-blinking\");\n    };\n\n    this.$padding = 0;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n\n    this.setSession = function(session) {\n        this.session = session;\n    };\n\n    this.setBlinking = function(blinking) {\n        if (blinking != this.isBlinking) {\n            this.isBlinking = blinking;\n            this.restartTimer();\n        }\n    };\n\n    this.setBlinkInterval = function(blinkInterval) {\n        if (blinkInterval != this.blinkInterval) {\n            this.blinkInterval = blinkInterval;\n            this.restartTimer();\n        }\n    };\n\n    this.setSmoothBlinking = function(smoothBlinking) {\n        if (smoothBlinking != this.smoothBlinking) {\n            this.smoothBlinking = smoothBlinking;\n            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n            this.$updateCursors(true);\n            this.restartTimer();\n        }\n    };\n\n    this.addCursor = function() {\n        var el = dom.createElement(\"div\");\n        el.className = \"ace_cursor\";\n        this.element.appendChild(el);\n        this.cursors.push(el);\n        return el;\n    };\n\n    this.removeCursor = function() {\n        if (this.cursors.length > 1) {\n            var el = this.cursors.pop();\n            el.parentNode.removeChild(el);\n            return el;\n        }\n    };\n\n    this.hideCursor = function() {\n        this.isVisible = false;\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.showCursor = function() {\n        this.isVisible = true;\n        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.restartTimer = function() {\n        var update = this.$updateCursors;\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n        this.$stopCssAnimation();\n\n        if (this.smoothBlinking) {\n            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n        }\n        \n        update(true);\n\n        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {\n            this.$stopCssAnimation();\n            return;\n        }\n\n        if (this.smoothBlinking) {\n            setTimeout(function(){\n                dom.addCssClass(this.element, \"ace_smooth-blinking\");\n            }.bind(this));\n        }\n        \n        if (dom.HAS_CSS_ANIMATION) {\n            this.$startCssAnimation();\n        } else {\n            var blink = function(){\n                this.timeoutId = setTimeout(function() {\n                    update(false);\n                }, 0.6 * this.blinkInterval);\n            }.bind(this);\n    \n            this.intervalId = setInterval(function() {\n                update(true);\n                blink();\n            }, this.blinkInterval);\n            blink();\n        }\n    };\n\n    this.getPixelPosition = function(position, onScreen) {\n        if (!this.config || !this.session)\n            return {left : 0, top : 0};\n\n        if (!position)\n            position = this.session.selection.getCursor();\n        var pos = this.session.documentToScreenPosition(position);\n        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : pos.column * this.config.characterWidth);\n\n        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n            this.config.lineHeight;\n\n        return {left : cursorLeft, top : cursorTop};\n    };\n\n    this.isCursorInView = function(pixelPos, config) {\n        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;\n    };\n\n    this.update = function(config) {\n        this.config = config;\n\n        var selections = this.session.$selectionMarkers;\n        var i = 0, cursorIndex = 0;\n\n        if (selections === undefined || selections.length === 0){\n            selections = [{cursor: null}];\n        }\n\n        for (var i = 0, n = selections.length; i < n; i++) {\n            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n            if ((pixelPos.top > config.height + config.offset ||\n                 pixelPos.top < 0) && i > 1) {\n                continue;\n            }\n\n            var element = this.cursors[cursorIndex++] || this.addCursor();\n            var style = element.style;\n            \n            if (!this.drawCursor) {\n                if (!this.isCursorInView(pixelPos, config)) {\n                    dom.setStyle(style, \"display\", \"none\");\n                } else {\n                    dom.setStyle(style, \"display\", \"block\");\n                    dom.translate(element, pixelPos.left, pixelPos.top);\n                    dom.setStyle(style, \"width\", Math.round(config.characterWidth) + \"px\");\n                    dom.setStyle(style, \"height\", config.lineHeight + \"px\");\n                }\n            } else {\n                this.drawCursor(element, pixelPos, config, selections[i], this.session);\n            }\n        }\n        while (this.cursors.length > cursorIndex)\n            this.removeCursor();\n\n        var overwrite = this.session.getOverwrite();\n        this.$setOverwrite(overwrite);\n        this.$pixelPos = pixelPos;\n        this.restartTimer();\n    };\n    \n    this.drawCursor = null;\n\n    this.$setOverwrite = function(overwrite) {\n        if (overwrite != this.overwrite) {\n            this.overwrite = overwrite;\n            if (overwrite)\n                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n            else\n                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n        }\n    };\n\n    this.destroy = function() {\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n    };\n\n}).call(Cursor.prototype);\n\nexports.Cursor = Cursor;\n\n});\n\nace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar MAX_SCROLL_H = 0x8000;\nvar ScrollBar = function(parent) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_scrollbar ace_scrollbar\" + this.classSuffix;\n\n    this.inner = dom.createElement(\"div\");\n    this.inner.className = \"ace_scrollbar-inner\";\n    this.element.appendChild(this.inner);\n\n    parent.appendChild(this.element);\n\n    this.setVisible(false);\n    this.skipEvent = false;\n\n    event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n    event.addListener(this.element, \"mousedown\", event.preventDefault);\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n\n    this.setVisible = function(isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n}).call(ScrollBar.prototype);\nvar VScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollTop = 0;\n    this.scrollHeight = 0;\n    renderer.$scrollbarWidth = \n    this.width = dom.scrollbarWidth(parent.ownerDocument);\n    this.inner.style.width =\n    this.element.style.width = (this.width || 15) + 5 + \"px\";\n    this.$minWidth = 0;\n};\n\noop.inherits(VScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-v';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollTop = this.element.scrollTop;\n            if (this.coeff != 1) {\n                var h = this.element.clientHeight / this.scrollHeight;\n                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);\n            }\n            this._emit(\"scroll\", {data: this.scrollTop});\n        }\n        this.skipEvent = false;\n    };\n    this.getWidth = function() {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    this.setHeight = function(height) {\n        this.element.style.height = height + \"px\";\n    };\n    this.setInnerHeight = \n    this.setScrollHeight = function(height) {\n        this.scrollHeight = height;\n        if (height > MAX_SCROLL_H) {\n            this.coeff = MAX_SCROLL_H / height;\n            height = MAX_SCROLL_H;\n        } else if (this.coeff != 1) {\n            this.coeff = 1;\n        }\n        this.inner.style.height = height + \"px\";\n    };\n    this.setScrollTop = function(scrollTop) {\n        if (this.scrollTop != scrollTop) {\n            this.skipEvent = true;\n            this.scrollTop = scrollTop;\n            this.element.scrollTop = scrollTop * this.coeff;\n        }\n    };\n\n}).call(VScrollBar.prototype);\nvar HScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollLeft = 0;\n    this.height = renderer.$scrollbarWidth;\n    this.inner.style.height =\n    this.element.style.height = (this.height || 15) + 5 + \"px\";\n};\n\noop.inherits(HScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-h';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollLeft = this.element.scrollLeft;\n            this._emit(\"scroll\", {data: this.scrollLeft});\n        }\n        this.skipEvent = false;\n    };\n    this.getHeight = function() {\n        return this.isVisible ? this.height : 0;\n    };\n    this.setWidth = function(width) {\n        this.element.style.width = width + \"px\";\n    };\n    this.setInnerWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.scrollLeft != scrollLeft) {\n            this.skipEvent = true;\n            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n        }\n    };\n\n}).call(HScrollBar.prototype);\n\n\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\n\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n});\n\nace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"./lib/event\");\n\n\nvar RenderLoop = function(onRender, win) {\n    this.onRender = onRender;\n    this.pending = false;\n    this.changes = 0;\n    this.$recursionLimit = 2;\n    this.window = win || window;\n    var _self = this;\n    this._flush = function(ts) {\n        _self.pending = false;\n        var changes = _self.changes;\n\n        if (changes) {\n            event.blockIdle(100);\n            _self.changes = 0;\n            _self.onRender(changes);\n        }\n        \n        if (_self.changes) {\n            if (_self.$recursionLimit-- < 0) return;\n            _self.schedule();\n        } else {\n            _self.$recursionLimit = 2;\n        }\n    };\n};\n\n(function() {\n\n    this.schedule = function(change) {\n        this.changes = this.changes | change;\n        if (this.changes && !this.pending) {\n            event.nextFrame(this._flush);\n            this.pending = true;\n        }\n    };\n\n    this.clear = function(change) {\n        var changes = this.changes;\n        this.changes = 0;\n        return changes;\n    };\n\n}).call(RenderLoop.prototype);\n\nexports.RenderLoop = RenderLoop;\n});\n\nace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CHAR_COUNT = 256;\nvar USE_OBSERVER = typeof ResizeObserver == \"function\";\nvar L = 200;\n\nvar FontMetrics = exports.FontMetrics = function(parentEl) {\n    this.el = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.el.style, true);\n    \n    this.$main = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$main.style);\n    \n    this.$measureNode = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$measureNode.style);\n    \n    \n    this.el.appendChild(this.$main);\n    this.el.appendChild(this.$measureNode);\n    parentEl.appendChild(this.el);\n    \n    this.$measureNode.innerHTML = lang.stringRepeat(\"X\", CHAR_COUNT);\n    \n    this.$characterSize = {width: 0, height: 0};\n    \n    \n    if (USE_OBSERVER)\n        this.$addObserver();\n    else\n        this.checkForSizeChanges();\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n        \n    this.$characterSize = {width: 0, height: 0};\n    \n    this.$setMeasureNodeStyles = function(style, isRoot) {\n        style.width = style.height = \"auto\";\n        style.left = style.top = \"0px\";\n        style.visibility = \"hidden\";\n        style.position = \"absolute\";\n        style.whiteSpace = \"pre\";\n\n        if (useragent.isIE < 8) {\n            style[\"font-family\"] = \"inherit\";\n        } else {\n            style.font = \"inherit\";\n        }\n        style.overflow = isRoot ? \"hidden\" : \"visible\";\n    };\n\n    this.checkForSizeChanges = function(size) {\n        if (size === undefined)\n            size = this.$measureSizes();\n        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n            this.$measureNode.style.fontWeight = \"bold\";\n            var boldSize = this.$measureSizes();\n            this.$measureNode.style.fontWeight = \"\";\n            this.$characterSize = size;\n            this.charSizes = Object.create(null);\n            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n            this._emit(\"changeCharacterSize\", {data: size});\n        }\n    };\n    \n    this.$addObserver = function() {\n        var self = this;\n        this.$observer = new window.ResizeObserver(function(e) {\n            var rect = e[0].contentRect;\n            self.checkForSizeChanges({\n                height: rect.height,\n                width: rect.width / CHAR_COUNT\n            });\n        });\n        this.$observer.observe(this.$measureNode);\n    };\n\n    this.$pollSizeChanges = function() {\n        if (this.$pollSizeChangesTimer || this.$observer)\n            return this.$pollSizeChangesTimer;\n        var self = this;\n        \n        return this.$pollSizeChangesTimer = event.onIdle(function cb() {\n            self.checkForSizeChanges();\n            event.onIdle(cb, 500);\n        }, 500);\n    };\n    \n    this.setPolling = function(val) {\n        if (val) {\n            this.$pollSizeChanges();\n        } else if (this.$pollSizeChangesTimer) {\n            clearInterval(this.$pollSizeChangesTimer);\n            this.$pollSizeChangesTimer = 0;\n        }\n    };\n\n    this.$measureSizes = function(node) {\n        var size = {\n            height: (node || this.$measureNode).clientHeight,\n            width: (node || this.$measureNode).clientWidth / CHAR_COUNT\n        };\n        if (size.width === 0 || size.height === 0)\n            return null;\n        return size;\n    };\n\n    this.$measureCharWidth = function(ch) {\n        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);\n        var rect = this.$main.getBoundingClientRect();\n        return rect.width / CHAR_COUNT;\n    };\n    \n    this.getCharacterWidth = function(ch) {\n        var w = this.charSizes[ch];\n        if (w === undefined) {\n            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n        }\n        return w;\n    };\n\n    this.destroy = function() {\n        clearInterval(this.$pollSizeChangesTimer);\n        if (this.$observer)\n            this.$observer.disconnect();\n        if (this.el && this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    };\n\n    \n    this.$getZoom = function getZoom(element) {\n        if (!element) return 1;\n        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);\n    };\n    this.$initTransformMeasureNodes = function() {\n        var t = function(t, l) {\n            return [\"div\", {\n                style: \"position: absolute;top:\" + t + \"px;left:\" + l + \"px;\"\n            }];\n        };\n        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);\n    };\n    this.transformCoordinates = function(clientPos, elPos) {\n        if (clientPos) {\n            var zoom = this.$getZoom(this.el);\n            clientPos = mul(1 / zoom, clientPos);\n        }\n        function solve(l1, l2, r) {\n            var det = l1[1] * l2[0] - l1[0] * l2[1];\n            return [\n                (-l2[1] * r[0] + l2[0] * r[1]) / det,\n                (+l1[1] * r[0] - l1[0] * r[1]) / det\n            ];\n        }\n        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }\n        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }\n        function mul(a, b) { return [a * b[0], a * b[1]]; }\n\n        if (!this.els)\n            this.$initTransformMeasureNodes();\n        \n        function p(el) {\n            var r = el.getBoundingClientRect();\n            return [r.left, r.top];\n        }\n\n        var a = p(this.els[0]);\n        var b = p(this.els[1]);\n        var c = p(this.els[2]);\n        var d = p(this.els[3]);\n\n        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));\n\n        var m1 = mul(1 + h[0], sub(b, a));\n        var m2 = mul(1 + h[1], sub(c, a));\n        \n        if (elPos) {\n            var x = elPos;\n            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;\n            var ut = add(mul(x[0], m1), mul(x[1], m2));\n            return  add(mul(1 / k / L, ut), a);\n        }\n        var u = sub(clientPos, a);\n        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);\n        return mul(L, f);\n    };\n    \n}).call(FontMetrics.prototype);\n\n});\n\nace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/config\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar config = require(\"./config\");\nvar GutterLayer = require(\"./layer/gutter\").Gutter;\nvar MarkerLayer = require(\"./layer/marker\").Marker;\nvar TextLayer = require(\"./layer/text\").Text;\nvar CursorLayer = require(\"./layer/cursor\").Cursor;\nvar HScrollBar = require(\"./scrollbar\").HScrollBar;\nvar VScrollBar = require(\"./scrollbar\").VScrollBar;\nvar RenderLoop = require(\"./renderloop\").RenderLoop;\nvar FontMetrics = require(\"./layer/font_metrics\").FontMetrics;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar editorCss = \"\\\n.ace_br1 {border-top-left-radius    : 3px;}\\\n.ace_br2 {border-top-right-radius   : 3px;}\\\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\\\n.ace_br4 {border-bottom-right-radius: 3px;}\\\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\\\n.ace_br8 {border-bottom-left-radius : 3px;}\\\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\\\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\\\n.ace_editor {\\\nposition: relative;\\\noverflow: hidden;\\\nfont: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\\\ndirection: ltr;\\\ntext-align: left;\\\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\\n}\\\n.ace_scroller {\\\nposition: absolute;\\\noverflow: hidden;\\\ntop: 0;\\\nbottom: 0;\\\nbackground-color: inherit;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncursor: text;\\\n}\\\n.ace_content {\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nmin-width: 100%;\\\ncontain: style size layout;\\\n}\\\n.ace_dragging .ace_scroller:before{\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\nbottom: 0;\\\ncontent: '';\\\nbackground: rgba(250, 250, 250, 0.01);\\\nz-index: 1000;\\\n}\\\n.ace_dragging.ace_dark .ace_scroller:before{\\\nbackground: rgba(0, 0, 0, 0.01);\\\n}\\\n.ace_selecting, .ace_selecting * {\\\ncursor: text !important;\\\n}\\\n.ace_gutter {\\\nposition: absolute;\\\noverflow : hidden;\\\nwidth: auto;\\\ntop: 0;\\\nbottom: 0;\\\nleft: 0;\\\ncursor: default;\\\nz-index: 4;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncontain: style size layout;\\\n}\\\n.ace_gutter-active-line {\\\nposition: absolute;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_scroller.ace_scroll-left {\\\nbox-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\\n}\\\n.ace_gutter-cell {\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\npadding-left: 19px;\\\npadding-right: 6px;\\\nbackground-repeat: no-repeat;\\\n}\\\n.ace_gutter-cell.ace_error {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_warning {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_dark .ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_scrollbar {\\\ncontain: strict;\\\nposition: absolute;\\\nright: 0;\\\nbottom: 0;\\\nz-index: 6;\\\n}\\\n.ace_scrollbar-inner {\\\nposition: absolute;\\\ncursor: text;\\\nleft: 0;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-v{\\\noverflow-x: hidden;\\\noverflow-y: scroll;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-h {\\\noverflow-x: scroll;\\\noverflow-y: hidden;\\\nleft: 0;\\\n}\\\n.ace_print-margin {\\\nposition: absolute;\\\nheight: 100%;\\\n}\\\n.ace_text-input {\\\nposition: absolute;\\\nz-index: 0;\\\nwidth: 0.5em;\\\nheight: 1em;\\\nopacity: 0;\\\nbackground: transparent;\\\n-moz-appearance: none;\\\nappearance: none;\\\nborder: none;\\\nresize: none;\\\noutline: none;\\\noverflow: hidden;\\\nfont: inherit;\\\npadding: 0 1px;\\\nmargin: 0 -1px;\\\ncontain: strict;\\\n-ms-user-select: text;\\\n-moz-user-select: text;\\\n-webkit-user-select: text;\\\nuser-select: text;\\\nwhite-space: pre!important;\\\n}\\\n.ace_text-input.ace_composition {\\\nbackground: transparent;\\\ncolor: inherit;\\\nz-index: 1000;\\\nopacity: 1;\\\n}\\\n.ace_composition_placeholder { color: transparent }\\\n.ace_composition_marker { \\\nborder-bottom: 1px solid;\\\nposition: absolute;\\\nborder-radius: 0;\\\nmargin-top: 1px;\\\n}\\\n[ace_nocontext=true] {\\\ntransform: none!important;\\\nfilter: none!important;\\\nperspective: none!important;\\\nclip-path: none!important;\\\nmask : none!important;\\\ncontain: none!important;\\\nperspective: none!important;\\\nmix-blend-mode: initial!important;\\\nz-index: auto;\\\n}\\\n.ace_layer {\\\nz-index: 1;\\\nposition: absolute;\\\noverflow: hidden;\\\nword-wrap: normal;\\\nwhite-space: pre;\\\nheight: 100%;\\\nwidth: 100%;\\\nbox-sizing: border-box;\\\npointer-events: none;\\\n}\\\n.ace_gutter-layer {\\\nposition: relative;\\\nwidth: auto;\\\ntext-align: right;\\\npointer-events: auto;\\\nheight: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer {\\\nfont: inherit !important;\\\nposition: absolute;\\\nheight: 1000000px;\\\nwidth: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\\\ncontain: style size layout;\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_hidpi .ace_text-layer,\\\n.ace_hidpi .ace_gutter-layer,\\\n.ace_hidpi .ace_content,\\\n.ace_hidpi .ace_gutter {\\\ncontain: strict;\\\nwill-change: transform;\\\n}\\\n.ace_hidpi .ace_text-layer > .ace_line, \\\n.ace_hidpi .ace_text-layer > .ace_line_group {\\\ncontain: strict;\\\n}\\\n.ace_cjk {\\\ndisplay: inline-block;\\\ntext-align: center;\\\n}\\\n.ace_cursor-layer {\\\nz-index: 4;\\\n}\\\n.ace_cursor {\\\nz-index: 4;\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nborder-left: 2px solid;\\\ntransform: translatez(0);\\\n}\\\n.ace_multiselect .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_slim-cursors .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_overwrite-cursors .ace_cursor {\\\nborder-left-width: 0;\\\nborder-bottom: 1px solid;\\\n}\\\n.ace_hidden-cursors .ace_cursor {\\\nopacity: 0.2;\\\n}\\\n.ace_smooth-blinking .ace_cursor {\\\ntransition: opacity 0.18s;\\\n}\\\n.ace_animate-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: step-end;\\\nanimation-name: blink-ace-animate;\\\nanimation-iteration-count: infinite;\\\n}\\\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: ease-in-out;\\\nanimation-name: blink-ace-animate-smooth;\\\n}\\\n@keyframes blink-ace-animate {\\\nfrom, to { opacity: 1; }\\\n60% { opacity: 0; }\\\n}\\\n@keyframes blink-ace-animate-smooth {\\\nfrom, to { opacity: 1; }\\\n45% { opacity: 1; }\\\n60% { opacity: 0; }\\\n85% { opacity: 0; }\\\n}\\\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\\nposition: absolute;\\\nz-index: 3;\\\n}\\\n.ace_marker-layer .ace_selection {\\\nposition: absolute;\\\nz-index: 5;\\\n}\\\n.ace_marker-layer .ace_bracket {\\\nposition: absolute;\\\nz-index: 6;\\\n}\\\n.ace_marker-layer .ace_active-line {\\\nposition: absolute;\\\nz-index: 2;\\\n}\\\n.ace_marker-layer .ace_selected-word {\\\nposition: absolute;\\\nz-index: 4;\\\nbox-sizing: border-box;\\\n}\\\n.ace_line .ace_fold {\\\nbox-sizing: border-box;\\\ndisplay: inline-block;\\\nheight: 11px;\\\nmargin-top: -2px;\\\nvertical-align: middle;\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\\nbackground-repeat: no-repeat, repeat-x;\\\nbackground-position: center center, top left;\\\ncolor: transparent;\\\nborder: 1px solid black;\\\nborder-radius: 2px;\\\ncursor: pointer;\\\npointer-events: auto;\\\n}\\\n.ace_dark .ace_fold {\\\n}\\\n.ace_fold:hover{\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_tooltip {\\\nbackground-color: #FFF;\\\nbackground-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\\\nborder: 1px solid gray;\\\nborder-radius: 1px;\\\nbox-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\\ncolor: black;\\\nmax-width: 100%;\\\npadding: 3px 4px;\\\nposition: fixed;\\\nz-index: 999999;\\\nbox-sizing: border-box;\\\ncursor: default;\\\nwhite-space: pre;\\\nword-wrap: break-word;\\\nline-height: normal;\\\nfont-style: normal;\\\nfont-weight: normal;\\\nletter-spacing: normal;\\\npointer-events: none;\\\n}\\\n.ace_folding-enabled > .ace_gutter-cell {\\\npadding-right: 13px;\\\n}\\\n.ace_fold-widget {\\\nbox-sizing: border-box;\\\nmargin: 0 -12px 0 1px;\\\ndisplay: none;\\\nwidth: 11px;\\\nvertical-align: top;\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: center;\\\nborder-radius: 3px;\\\nborder: 1px solid transparent;\\\ncursor: pointer;\\\n}\\\n.ace_folding-enabled .ace_fold-widget {\\\ndisplay: inline-block;   \\\n}\\\n.ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\\n}\\\n.ace_fold-widget:hover {\\\nborder: 1px solid rgba(0, 0, 0, 0.3);\\\nbackground-color: rgba(255, 255, 255, 0.2);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\\n}\\\n.ace_fold-widget:active {\\\nborder: 1px solid rgba(0, 0, 0, 0.4);\\\nbackground-color: rgba(0, 0, 0, 0.05);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\\n}\\\n.ace_dark .ace_fold-widget {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget:hover {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\nbackground-color: rgba(255, 255, 255, 0.1);\\\n}\\\n.ace_dark .ace_fold-widget:active {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\n}\\\n.ace_inline_button {\\\nborder: 1px solid lightgray;\\\ndisplay: inline-block;\\\nmargin: -1px 8px;\\\npadding: 0 5px;\\\npointer-events: auto;\\\ncursor: pointer;\\\n}\\\n.ace_inline_button:hover {\\\nborder-color: gray;\\\nbackground: rgba(200,200,200,0.2);\\\ndisplay: inline-block;\\\npointer-events: auto;\\\n}\\\n.ace_fold-widget.ace_invalid {\\\nbackground-color: #FFB4B4;\\\nborder-color: #DE5555;\\\n}\\\n.ace_fade-fold-widgets .ace_fold-widget {\\\ntransition: opacity 0.4s ease 0.05s;\\\nopacity: 0;\\\n}\\\n.ace_fade-fold-widgets:hover .ace_fold-widget {\\\ntransition: opacity 0.05s ease 0.05s;\\\nopacity:1;\\\n}\\\n.ace_underline {\\\ntext-decoration: underline;\\\n}\\\n.ace_bold {\\\nfont-weight: bold;\\\n}\\\n.ace_nobold .ace_bold {\\\nfont-weight: normal;\\\n}\\\n.ace_italic {\\\nfont-style: italic;\\\n}\\\n.ace_error-marker {\\\nbackground-color: rgba(255, 0, 0,0.2);\\\nposition: absolute;\\\nz-index: 9;\\\n}\\\n.ace_highlight-marker {\\\nbackground-color: rgba(255, 255, 0,0.2);\\\nposition: absolute;\\\nz-index: 8;\\\n}\\\n\";\n\nvar useragent = require(\"./lib/useragent\");\nvar HIDE_TEXTAREA = useragent.isIE;\n\ndom.importCssString(editorCss, \"ace_editor.css\");\n\nvar VirtualRenderer = function(container, theme) {\n    var _self = this;\n\n    this.container = container || dom.createElement(\"div\");\n\n    dom.addCssClass(this.container, \"ace_editor\");\n    if (dom.HI_DPI) dom.addCssClass(this.container, \"ace_hidpi\");\n\n    this.setTheme(theme);\n\n    this.$gutter = dom.createElement(\"div\");\n    this.$gutter.className = \"ace_gutter\";\n    this.container.appendChild(this.$gutter);\n    this.$gutter.setAttribute(\"aria-hidden\", true);\n\n    this.scroller = dom.createElement(\"div\");\n    this.scroller.className = \"ace_scroller\";\n    \n    this.container.appendChild(this.scroller);\n\n    this.content = dom.createElement(\"div\");\n    this.content.className = \"ace_content\";\n    this.scroller.appendChild(this.content);\n\n    this.$gutterLayer = new GutterLayer(this.$gutter);\n    this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n\n    this.$markerBack = new MarkerLayer(this.content);\n\n    var textLayer = this.$textLayer = new TextLayer(this.content);\n    this.canvas = textLayer.element;\n\n    this.$markerFront = new MarkerLayer(this.content);\n\n    this.$cursorLayer = new CursorLayer(this.content);\n    this.$horizScroll = false;\n    this.$vScroll = false;\n\n    this.scrollBar = \n    this.scrollBarV = new VScrollBar(this.container, this);\n    this.scrollBarH = new HScrollBar(this.container, this);\n    this.scrollBarV.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n    });\n    this.scrollBarH.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n    });\n\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this.cursorPos = {\n        row : 0,\n        column : 0\n    };\n\n    this.$fontMetrics = new FontMetrics(this.container);\n    this.$textLayer.$setFontMetrics(this.$fontMetrics);\n    this.$textLayer.addEventListener(\"changeCharacterSize\", function(e) {\n        _self.updateCharacterSize();\n        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n        _self._signal(\"changeCharacterSize\", e);\n    });\n\n    this.$size = {\n        width: 0,\n        height: 0,\n        scrollerHeight: 0,\n        scrollerWidth: 0,\n        $dirty: true\n    };\n\n    this.layerConfig = {\n        width : 1,\n        padding : 0,\n        firstRow : 0,\n        firstRowScreen: 0,\n        lastRow : 0,\n        lineHeight : 0,\n        characterWidth : 0,\n        minHeight : 1,\n        maxHeight : 1,\n        offset : 0,\n        height : 1,\n        gutterOffset: 1\n    };\n    \n    this.scrollMargin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.margin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.$keepTextAreaAtCursor = !useragent.isIOS;\n\n    this.$loop = new RenderLoop(\n        this.$renderChanges.bind(this),\n        this.container.ownerDocument.defaultView\n    );\n    this.$loop.schedule(this.CHANGE_FULL);\n\n    this.updateCharacterSize();\n    this.setPadding(4);\n    config.resetOptions(this);\n    config._emit(\"renderer\", this);\n};\n\n(function() {\n\n    this.CHANGE_CURSOR = 1;\n    this.CHANGE_MARKER = 2;\n    this.CHANGE_GUTTER = 4;\n    this.CHANGE_SCROLL = 8;\n    this.CHANGE_LINES = 16;\n    this.CHANGE_TEXT = 32;\n    this.CHANGE_SIZE = 64;\n    this.CHANGE_MARKER_BACK = 128;\n    this.CHANGE_MARKER_FRONT = 256;\n    this.CHANGE_FULL = 512;\n    this.CHANGE_H_SCROLL = 1024;\n\n    oop.implement(this, EventEmitter);\n\n    this.updateCharacterSize = function() {\n        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n        }\n\n        this.layerConfig.characterWidth =\n        this.characterWidth = this.$textLayer.getCharacterWidth();\n        this.layerConfig.lineHeight =\n        this.lineHeight = this.$textLayer.getLineHeight();\n        this.$updatePrintMargin();\n    };\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n            \n        this.session = session;\n        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n            session.setScrollTop(-this.scrollMargin.top);\n\n        this.$cursorLayer.setSession(session);\n        this.$markerBack.setSession(session);\n        this.$markerFront.setSession(session);\n        this.$gutterLayer.setSession(session);\n        this.$textLayer.setSession(session);\n        if (!session)\n            return;\n        \n        this.$loop.schedule(this.CHANGE_FULL);\n        this.session.$setFontMetrics(this.$fontMetrics);\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        \n        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n        this.onChangeNewLineMode();\n        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n    };\n    this.updateLines = function(firstRow, lastRow, force) {\n        if (lastRow === undefined)\n            lastRow = Infinity;\n\n        if (!this.$changedLines) {\n            this.$changedLines = {\n                firstRow: firstRow,\n                lastRow: lastRow\n            };\n        }\n        else {\n            if (this.$changedLines.firstRow > firstRow)\n                this.$changedLines.firstRow = firstRow;\n\n            if (this.$changedLines.lastRow < lastRow)\n                this.$changedLines.lastRow = lastRow;\n        }\n        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n            if (force)\n                this.$changedLines.lastRow = this.layerConfig.lastRow;\n            else\n                return;\n        }\n        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n            return;\n        this.$loop.schedule(this.CHANGE_LINES);\n    };\n\n    this.onChangeNewLineMode = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n        this.$textLayer.$updateEolChar();\n        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);\n    };\n    \n    this.onChangeTabSize = function() {\n        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n        this.$textLayer.onChangeTabSize();\n    };\n    this.updateText = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n    };\n    this.updateFull = function(force) {\n        if (force)\n            this.$renderChanges(this.CHANGE_FULL, true);\n        else\n            this.$loop.schedule(this.CHANGE_FULL);\n    };\n    this.updateFontSize = function() {\n        this.$textLayer.checkForSizeChanges();\n    };\n\n    this.$changes = 0;\n    this.$updateSizeAsync = function() {\n        if (this.$loop.pending)\n            this.$size.$dirty = true;\n        else\n            this.onResize();\n    };\n    this.onResize = function(force, gutterWidth, width, height) {\n        if (this.resizing > 2)\n            return;\n        else if (this.resizing > 0)\n            this.resizing++;\n        else\n            this.resizing = force ? 1 : 0;\n        var el = this.container;\n        if (!height)\n            height = el.clientHeight || el.scrollHeight;\n        if (!width)\n            width = el.clientWidth || el.scrollWidth;\n        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n\n        \n        if (!this.$size.scrollerHeight || (!width && !height))\n            return this.resizing = 0;\n\n        if (force)\n            this.$gutterLayer.$padding = null;\n\n        if (force)\n            this.$renderChanges(changes | this.$changes, true);\n        else\n            this.$loop.schedule(changes | this.$changes);\n\n        if (this.resizing)\n            this.resizing = 0;\n        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;\n    };\n    \n    this.$updateCachedSize = function(force, gutterWidth, width, height) {\n        height -= (this.$extraHeight || 0);\n        var changes = 0;\n        var size = this.$size;\n        var oldSize = {\n            width: size.width,\n            height: size.height,\n            scrollerHeight: size.scrollerHeight,\n            scrollerWidth: size.scrollerWidth\n        };\n        if (height && (force || size.height != height)) {\n            size.height = height;\n            changes |= this.CHANGE_SIZE;\n\n            size.scrollerHeight = size.height;\n            if (this.$horizScroll)\n                size.scrollerHeight -= this.scrollBarH.getHeight();\n            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n\n            changes = changes | this.CHANGE_SCROLL;\n        }\n\n        if (width && (force || size.width != width)) {\n            changes |= this.CHANGE_SIZE;\n            size.width = width;\n            \n            if (gutterWidth == null)\n                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n            \n            this.gutterWidth = gutterWidth;\n            \n            dom.setStyle(this.scrollBarH.element.style, \"left\", gutterWidth + \"px\");\n            dom.setStyle(this.scroller.style, \"left\", gutterWidth + this.margin.left + \"px\");\n            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);\n            dom.setStyle(this.$gutter.style, \"left\", this.margin.left + \"px\");\n            \n            var right = this.scrollBarV.getWidth() + \"px\";\n            dom.setStyle(this.scrollBarH.element.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"bottom\", this.scrollBarH.getHeight());\n\n            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {\n                changes |= this.CHANGE_FULL;\n            }\n        }\n        \n        size.$dirty = !width || !height;\n\n        if (changes)\n            this._signal(\"resize\", oldSize);\n\n        return changes;\n    };\n\n    this.onGutterResize = function(width) {\n        var gutterWidth = this.$showGutter ? width : 0;\n        if (gutterWidth != this.gutterWidth)\n            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n\n        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else if (this.$size.$dirty) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else {\n            this.$computeLayerConfig();\n        }\n    };\n    this.adjustWrapLimit = function() {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth);\n        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n    };\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.setOption(\"animatedScroll\", shouldAnimate);\n    };\n    this.getAnimatedScroll = function() {\n        return this.$animatedScroll;\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.setOption(\"showInvisibles\", showInvisibles);\n        this.session.$bidiHandler.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.getOption(\"showInvisibles\");\n    };\n    this.getDisplayIndentGuides = function() {\n        return this.getOption(\"displayIndentGuides\");\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.setOption(\"displayIndentGuides\", display);\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.setOption(\"showPrintMargin\", showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.getOption(\"showPrintMargin\");\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.setOption(\"printMarginColumn\", showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.getOption(\"printMarginColumn\");\n    };\n    this.getShowGutter = function(){\n        return this.getOption(\"showGutter\");\n    };\n    this.setShowGutter = function(show){\n        return this.setOption(\"showGutter\", show);\n    };\n\n    this.getFadeFoldWidgets = function(){\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(show) {\n        this.setOption(\"fadeFoldWidgets\", show);\n    };\n\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n\n    this.$updatePrintMargin = function() {\n        if (!this.$showPrintMargin && !this.$printMarginEl)\n            return;\n\n        if (!this.$printMarginEl) {\n            var containerEl = dom.createElement(\"div\");\n            containerEl.className = \"ace_layer ace_print-margin-layer\";\n            this.$printMarginEl = dom.createElement(\"div\");\n            this.$printMarginEl.className = \"ace_print-margin\";\n            containerEl.appendChild(this.$printMarginEl);\n            this.content.insertBefore(containerEl, this.content.firstChild);\n        }\n\n        var style = this.$printMarginEl.style;\n        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + \"px\";\n        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n        \n        if (this.session && this.session.$wrap == -1)\n            this.adjustWrapLimit();\n    };\n    this.getContainerElement = function() {\n        return this.container;\n    };\n    this.getMouseEventTarget = function() {\n        return this.scroller;\n    };\n    this.getTextAreaContainer = function() {\n        return this.container;\n    };\n    this.$moveTextAreaToCursor = function() {\n        var style = this.textarea.style;\n        if (!this.$keepTextAreaAtCursor) {\n            dom.translate(this.textarea, -100, 0);\n            return;\n        }\n        var pixelPos = this.$cursorLayer.$pixelPos;\n        if (!pixelPos)\n            return;\n        var composition = this.$composition;\n        if (composition && composition.markerRange)\n            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);\n        \n        var config = this.layerConfig;\n        var posTop = pixelPos.top;\n        var posLeft = pixelPos.left;\n        posTop -= config.offset;\n\n        var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;\n        if (posTop < 0 || posTop > config.height - h) {\n            dom.translate(this.textarea, 0, 0);\n            return;\n        }\n\n        var w = 1;\n        if (!composition) {\n            posTop += this.lineHeight;\n        }\n        else {\n            if (composition.useTextareaForIME) {\n                var val = this.textarea.value;\n                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);\n                h += 2;\n            }\n            else {\n                posTop += this.lineHeight + 2;\n            }\n        }\n        \n        posLeft -= this.scrollLeft;\n        if (posLeft > this.$size.scrollerWidth - w)\n            posLeft = this.$size.scrollerWidth - w;\n\n        posLeft += this.gutterWidth + this.margin.left;\n\n        dom.setStyle(style, \"height\", h + \"px\");\n        dom.setStyle(style, \"width\", w + \"px\");\n        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, this.$size.height - h));\n    };\n    this.getFirstVisibleRow = function() {\n        return this.layerConfig.firstRow;\n    };\n    this.getFirstFullyVisibleRow = function() {\n        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n    };\n    this.getLastFullyVisibleRow = function() {\n        var config = this.layerConfig;\n        var lastRow = config.lastRow;\n        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;\n        if (top - this.session.getScrollTop() > config.height - config.lineHeight)\n            return lastRow - 1;\n        return lastRow;\n    };\n    this.getLastVisibleRow = function() {\n        return this.layerConfig.lastRow;\n    };\n\n    this.$padding = null;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.$textLayer.setPadding(padding);\n        this.$cursorLayer.setPadding(padding);\n        this.$markerFront.setPadding(padding);\n        this.$markerBack.setPadding(padding);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.$updatePrintMargin();\n    };\n    \n    this.setScrollMargin = function(top, bottom, left, right) {\n        var sm = this.scrollMargin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        if (sm.top && this.scrollTop <= 0 && this.session)\n            this.session.setScrollTop(-sm.top);\n        this.updateFull();\n    };\n    \n    this.setMargin = function(top, bottom, left, right) {\n        var sm = this.margin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);\n        this.updateFull();\n    };\n    this.getHScrollBarAlwaysVisible = function() {\n        return this.$hScrollBarAlwaysVisible;\n    };\n    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    this.getVScrollBarAlwaysVisible = function() {\n        return this.$vScrollBarAlwaysVisible;\n    };\n    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n    };\n\n    this.$updateScrollBarV = function() {\n        var scrollHeight = this.layerConfig.maxHeight;\n        var scrollerHeight = this.$size.scrollerHeight;\n        if (!this.$maxLines && this.$scrollPastEnd) {\n            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n            if (this.scrollTop > scrollHeight - scrollerHeight) {\n                scrollHeight = this.scrollTop + scrollerHeight;\n                this.scrollBarV.scrollTop = null;\n            }\n        }\n        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n    };\n    this.$updateScrollBarH = function() {\n        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n    };\n    \n    this.$frozen = false;\n    this.freeze = function() {\n        this.$frozen = true;\n    };\n    \n    this.unfreeze = function() {\n        this.$frozen = false;\n    };\n\n    this.$renderChanges = function(changes, force) {\n        if (this.$changes) {\n            changes |= this.$changes;\n            this.$changes = 0;\n        }\n        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n            this.$changes |= changes;\n            return; \n        } \n        if (this.$size.$dirty) {\n            this.$changes |= changes;\n            return this.onResize(true);\n        }\n        if (!this.lineHeight) {\n            this.$textLayer.checkForSizeChanges();\n        }\n        \n        this._signal(\"beforeRender\");\n        \n        if (this.session && this.session.$bidiHandler)\n            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);\n\n        var config = this.layerConfig;\n        if (changes & this.CHANGE_FULL ||\n            changes & this.CHANGE_SIZE ||\n            changes & this.CHANGE_TEXT ||\n            changes & this.CHANGE_LINES ||\n            changes & this.CHANGE_SCROLL ||\n            changes & this.CHANGE_H_SCROLL\n        ) {\n            changes |= this.$computeLayerConfig() | this.$loop.clear();\n            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;\n                if (st > 0) {\n                    this.scrollTop = st;\n                    changes = changes | this.CHANGE_SCROLL;\n                    changes |= this.$computeLayerConfig() | this.$loop.clear();\n                }\n            }\n            config = this.layerConfig;\n            this.$updateScrollBarV();\n            if (changes & this.CHANGE_H_SCROLL)\n                this.$updateScrollBarH();\n            \n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            \n            var width = config.width + 2 * this.$padding + \"px\";\n            var height = config.minHeight + \"px\";\n            \n            dom.setStyle(this.content.style, \"width\", width);\n            dom.setStyle(this.content.style, \"height\", height);\n        }\n        if (changes & this.CHANGE_H_SCROLL) {\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller\" : \"ace_scroller ace_scroll-left\";\n        }\n        if (changes & this.CHANGE_FULL) {\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\");\n            return;\n        }\n        if (changes & this.CHANGE_SCROLL) {\n            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n                this.$textLayer.update(config);\n            else\n                this.$textLayer.scrollLines(config);\n\n            if (this.$showGutter) {\n                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)\n                    this.$gutterLayer.update(config);\n                else\n                    this.$gutterLayer.scrollLines(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\");\n            return;\n        }\n\n        if (changes & this.CHANGE_TEXT) {\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_LINES) {\n            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_CURSOR) {\n            if (this.$highlightGutterLine)\n                this.$gutterLayer.updateLineHighlight(config);\n        }\n\n        if (changes & this.CHANGE_CURSOR) {\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n            this.$markerFront.update(config);\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n            this.$markerBack.update(config);\n        }\n\n        this._signal(\"afterRender\");\n    };\n\n    \n    this.$autosize = function() {\n        var height = this.session.getScreenLength() * this.lineHeight;\n        var maxHeight = this.$maxLines * this.lineHeight;\n        var desiredHeight = Math.min(maxHeight, \n            Math.max((this.$minLines || 1) * this.lineHeight, height)\n        ) + this.scrollMargin.v + (this.$extraHeight || 0);\n        if (this.$horizScroll)\n            desiredHeight += this.scrollBarH.getHeight();\n        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)\n            desiredHeight = this.$maxPixelHeight;\n        \n        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;\n        var vScroll = !hideScrollbars && height > maxHeight;\n        \n        if (desiredHeight != this.desiredHeight ||\n            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n            if (vScroll != this.$vScroll) {\n                this.$vScroll = vScroll;\n                this.scrollBarV.setVisible(vScroll);\n            }\n            \n            var w = this.container.clientWidth;\n            this.container.style.height = desiredHeight + \"px\";\n            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n            this.desiredHeight = desiredHeight;\n            \n            this._signal(\"autosize\");\n        }\n    };\n    \n    this.$computeLayerConfig = function() {\n        var session = this.session;\n        var size = this.$size;\n        \n        var hideScrollbars = size.height <= 2 * this.lineHeight;\n        var screenLines = this.session.getScreenLength();\n        var maxHeight = screenLines * this.lineHeight;\n\n        var longestLine = this.$getLongestLine();\n        \n        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n\n        var hScrollChanged = this.$horizScroll !== horizScroll;\n        if (hScrollChanged) {\n            this.$horizScroll = horizScroll;\n            this.scrollBarH.setVisible(horizScroll);\n        }\n        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine\n        if (this.$maxLines && this.lineHeight > 1)\n            this.$autosize();\n\n        var minHeight = size.scrollerHeight + this.lineHeight;\n        \n        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n            : 0;\n        maxHeight += scrollPastEnd;\n        \n        var sm = this.scrollMargin;\n        this.session.setScrollTop(Math.max(-sm.top,\n            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));\n\n        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, \n            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));\n        \n        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);\n        var vScrollChanged = vScrollBefore !== vScroll;\n        if (vScrollChanged) {\n            this.$vScroll = vScroll;\n            this.scrollBarV.setVisible(vScroll);\n        }\n\n        var offset = this.scrollTop % this.lineHeight;\n        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n        var lastRow = firstRow + lineCount;\n        var firstRowScreen, firstRowHeight;\n        var lineHeight = this.lineHeight;\n        firstRow = session.screenToDocumentRow(firstRow, 0);\n        var foldLine = session.getFoldLine(firstRow);\n        if (foldLine) {\n            firstRow = foldLine.start.row;\n        }\n\n        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n\n        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n                                                firstRowHeight;\n\n        offset = this.scrollTop - firstRowScreen * lineHeight;\n\n        var changes = 0;\n        if (this.layerConfig.width != longestLine || hScrollChanged) \n            changes = this.CHANGE_H_SCROLL;\n        if (hScrollChanged || vScrollChanged) {\n            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n            this._signal(\"scrollbarVisibilityChanged\");\n            if (vScrollChanged)\n                longestLine = this.$getLongestLine();\n        }\n        \n        this.layerConfig = {\n            width : longestLine,\n            padding : this.$padding,\n            firstRow : firstRow,\n            firstRowScreen: firstRowScreen,\n            lastRow : lastRow,\n            lineHeight : lineHeight,\n            characterWidth : this.characterWidth,\n            minHeight : minHeight,\n            maxHeight : maxHeight,\n            offset : offset,\n            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,\n            height : this.$size.scrollerHeight\n        };\n\n        if (this.session.$bidiHandler)\n            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);\n\n        return changes;\n    };\n\n    this.$updateLines = function() {\n        if (!this.$changedLines) return;\n        var firstRow = this.$changedLines.firstRow;\n        var lastRow = this.$changedLines.lastRow;\n        this.$changedLines = null;\n\n        var layerConfig = this.layerConfig;\n\n        if (firstRow > layerConfig.lastRow + 1) { return; }\n        if (lastRow < layerConfig.firstRow) { return; }\n        if (lastRow === Infinity) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(layerConfig);\n            this.$textLayer.update(layerConfig);\n            return;\n        }\n        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n        return true;\n    };\n\n    this.$getLongestLine = function() {\n        var charCount = this.session.getScreenWidth();\n        if (this.showInvisibles && !this.session.$useWrapMode)\n            charCount += 1;\n            \n        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)\n            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;\n\n        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n    };\n    this.updateFrontMarkers = function() {\n        this.$markerFront.setMarkers(this.session.getMarkers(true));\n        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n    };\n    this.updateBackMarkers = function() {\n        this.$markerBack.setMarkers(this.session.getMarkers());\n        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n    };\n    this.addGutterDecoration = function(row, className){\n        this.$gutterLayer.addGutterDecoration(row, className);\n    };\n    this.removeGutterDecoration = function(row, className){\n        this.$gutterLayer.removeGutterDecoration(row, className);\n    };\n    this.updateBreakpoints = function(rows) {\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.setAnnotations = function(annotations) {\n        this.$gutterLayer.setAnnotations(annotations);\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.updateCursor = function() {\n        this.$loop.schedule(this.CHANGE_CURSOR);\n    };\n    this.hideCursor = function() {\n        this.$cursorLayer.hideCursor();\n    };\n    this.showCursor = function() {\n        this.$cursorLayer.showCursor();\n    };\n\n    this.scrollSelectionIntoView = function(anchor, lead, offset) {\n        this.scrollCursorIntoView(anchor, offset);\n        this.scrollCursorIntoView(lead, offset);\n    };\n    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {\n        if (this.$size.scrollerHeight === 0)\n            return;\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n\n        var left = pos.left;\n        var top = pos.top;\n        \n        var topMargin = $viewMargin && $viewMargin.top || 0;\n        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n        \n        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n        \n        if (scrollTop + topMargin > top) {\n            if (offset && scrollTop + topMargin > top + this.lineHeight)\n                top -= offset * this.$size.scrollerHeight;\n            if (top === 0)\n                top = -this.scrollMargin.top;\n            this.session.setScrollTop(top);\n        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {\n            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)\n                top += offset * this.$size.scrollerHeight;\n            this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);\n        }\n\n        var scrollLeft = this.scrollLeft;\n\n        if (scrollLeft > left) {\n            if (left < this.$padding + 2 * this.layerConfig.characterWidth)\n                left = -this.scrollMargin.left;\n            this.session.setScrollLeft(left);\n        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {\n            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));\n        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {\n            this.session.setScrollLeft(0);\n        }\n    };\n    this.getScrollTop = function() {\n        return this.session.getScrollTop();\n    };\n    this.getScrollLeft = function() {\n        return this.session.getScrollLeft();\n    };\n    this.getScrollTopRow = function() {\n        return this.scrollTop / this.lineHeight;\n    };\n    this.getScrollBottomRow = function() {\n        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n    };\n    this.scrollToRow = function(row) {\n        this.session.setScrollTop(row * this.lineHeight);\n    };\n\n    this.alignCursor = function(cursor, alignment) {\n        if (typeof cursor == \"number\")\n            cursor = {row: cursor, column: 0};\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var h = this.$size.scrollerHeight - this.lineHeight;\n        var offset = pos.top - h * (alignment || 0);\n\n        this.session.setScrollTop(offset);\n        return offset;\n    };\n\n    this.STEPS = 8;\n    this.$calcSteps = function(fromValue, toValue){\n        var i = 0;\n        var l = this.STEPS;\n        var steps = [];\n\n        var func  = function(t, x_min, dx) {\n            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n        };\n\n        for (i = 0; i < l; ++i)\n            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n\n        return steps;\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});\n        var offset = pos.top;\n        if (center)\n            offset -= this.$size.scrollerHeight / 2;\n\n        var initialScroll = this.scrollTop;\n        this.session.setScrollTop(offset);\n        if (animate !== false)\n            this.animateScrolling(initialScroll, callback);\n    };\n\n    this.animateScrolling = function(fromValue, callback) {\n        var toValue = this.scrollTop;\n        if (!this.$animatedScroll)\n            return;\n        var _self = this;\n        \n        if (fromValue == toValue)\n            return;\n        \n        if (this.$scrollAnimation) {\n            var oldSteps = this.$scrollAnimation.steps;\n            if (oldSteps.length) {\n                fromValue = oldSteps[0];\n                if (fromValue == toValue)\n                    return;\n            }\n        }\n        \n        var steps = _self.$calcSteps(fromValue, toValue);\n        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};\n\n        clearInterval(this.$timer);\n\n        _self.session.setScrollTop(steps.shift());\n        _self.session.$scrollTop = toValue;\n        this.$timer = setInterval(function() {\n            if (steps.length) {\n                _self.session.setScrollTop(steps.shift());\n                _self.session.$scrollTop = toValue;\n            } else if (toValue != null) {\n                _self.session.$scrollTop = -1;\n                _self.session.setScrollTop(toValue);\n                toValue = null;\n            } else {\n                _self.$timer = clearInterval(_self.$timer);\n                _self.$scrollAnimation = null;\n                callback && callback();\n            }\n        }, 10);\n    };\n    this.scrollToY = function(scrollTop) {\n        if (this.scrollTop !== scrollTop) {\n            this.$loop.schedule(this.CHANGE_SCROLL);\n            this.scrollTop = scrollTop;\n        }\n    };\n    this.scrollToX = function(scrollLeft) {\n        if (this.scrollLeft !== scrollLeft)\n            this.scrollLeft = scrollLeft;\n        this.$loop.schedule(this.CHANGE_H_SCROLL);\n    };\n    this.scrollTo = function(x, y) {\n        this.session.setScrollTop(y);\n        this.session.setScrollLeft(y);\n    };\n    this.scrollBy = function(deltaX, deltaY) {\n        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n    };\n    this.isScrollableBy = function(deltaX, deltaY) {\n        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n           return true;\n        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n           return true;\n        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n            return true;\n        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n            - this.layerConfig.width < -1 + this.scrollMargin.right)\n           return true;\n    };\n\n    this.pixelToScreenCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        \n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};\n    };\n\n    this.screenToTextCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n\n        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);\n    };\n    this.textToScreenCoordinates = function(row, column) {\n        var canvasPos = this.scroller.getBoundingClientRect();\n        var pos = this.session.documentToScreenPosition(row, column);\n\n        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)\n             ? this.session.$bidiHandler.getPosLeft(pos.column)\n             : Math.round(pos.column * this.characterWidth));\n        \n        var y = pos.row * this.lineHeight;\n\n        return {\n            pageX: canvasPos.left + x - this.scrollLeft,\n            pageY: canvasPos.top + y - this.scrollTop\n        };\n    };\n    this.visualizeFocus = function() {\n        dom.addCssClass(this.container, \"ace_focus\");\n    };\n    this.visualizeBlur = function() {\n        dom.removeCssClass(this.container, \"ace_focus\");\n    };\n    this.showComposition = function(composition) {\n        this.$composition = composition;\n        if (!composition.cssText) {\n            composition.cssText = this.textarea.style.cssText;\n            composition.keepTextAreaAtCursor = this.$keepTextAreaAtCursor;\n        }\n        composition.useTextareaForIME = this.$useTextareaForIME;\n        \n        if (this.$useTextareaForIME) {\n            this.$keepTextAreaAtCursor = true;\n            dom.addCssClass(this.textarea, \"ace_composition\");\n            this.textarea.style.cssText = \"\";\n            this.$moveTextAreaToCursor();\n            this.$cursorLayer.element.style.display = \"none\";\n        }\n        else {            \n            composition.markerId = this.session.addMarker(composition.markerRange, \"ace_composition_marker\", \"text\");\n        }\n    };\n    this.setCompositionText = function(text) {\n        var cursor = this.session.selection.cursor;\n        this.addToken(text, \"composition_placeholder\", cursor.row, cursor.column);\n        this.$moveTextAreaToCursor();\n    };\n    this.hideComposition = function() {\n        if (!this.$composition)\n            return;\n        \n        if (this.$composition.markerId)\n            this.session.removeMarker(this.$composition.markerId);\n\n        dom.removeCssClass(this.textarea, \"ace_composition\");\n        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;\n        this.textarea.style.cssText = this.$composition.cssText;\n        this.$composition = null;\n        this.$cursorLayer.element.style.display = \"\";\n    };\n    \n    this.addToken = function(text, type, row, column) {\n        var session = this.session;\n        session.bgTokenizer.lines[row] = null;\n        var newToken = {type: type, value: text};\n        var tokens = session.getTokens(row);\n        if (column == null) {\n            tokens.push(newToken);\n        } else {\n            var l = 0;\n            for (var i =0; i < tokens.length; i++) {\n                var token = tokens[i];\n                l += token.value.length;\n                if (column <= l) {\n                    var diff = token.value.length - (l - column);\n                    var before = token.value.slice(0, diff);\n                    var after = token.value.slice(diff);\n    \n                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});\n                    break;\n                }\n            }\n        }\n        this.updateLines(row, row);\n    };\n    this.setTheme = function(theme, cb) {\n        var _self = this;\n        this.$themeId = theme;\n        _self._dispatchEvent('themeChange',{theme:theme});\n\n        if (!theme || typeof theme == \"string\") {\n            var moduleName = theme || this.$options.theme.initialValue;\n            config.loadModule([\"theme\", moduleName], afterLoad);\n        } else {\n            afterLoad(theme);\n        }\n\n        function afterLoad(module) {\n            if (_self.$themeId != theme)\n                return cb && cb();\n            if (!module || !module.cssClass)\n                throw new Error(\"couldn't load module \" + theme + \" or it didn't call define\");\n            if (module.$id)\n                _self.$themeId = module.$id;\n            dom.importCssString(\n                module.cssText,\n                module.cssClass,\n                _self.container\n            );\n\n            if (_self.theme)\n                dom.removeCssClass(_self.container, _self.theme.cssClass);\n\n            var padding = \"padding\" in module ? module.padding \n                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n            if (_self.$padding && padding != _self.$padding)\n                _self.setPadding(padding);\n            _self.$theme = module.cssClass;\n\n            _self.theme = module;\n            dom.addCssClass(_self.container, module.cssClass);\n            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n            if (_self.$size) {\n                _self.$size.width = 0;\n                _self.$updateSizeAsync();\n            }\n\n            _self._dispatchEvent('themeLoaded', {theme:module});\n            cb && cb();\n        }\n    };\n    this.getTheme = function() {\n        return this.$themeId;\n    };\n    this.setStyle = function(style, include) {\n        dom.setCssClass(this.container, style, include !== false);\n    };\n    this.unsetStyle = function(style) {\n        dom.removeCssClass(this.container, style);\n    };\n    \n    this.setCursorStyle = function(style) {\n        dom.setStyle(this.scroller.style, \"cursor\", style);\n    };\n    this.setMouseCursor = function(cursorStyle) {\n        dom.setStyle(this.scroller.style, \"cursor\", cursorStyle);\n    };\n    \n    this.attachToShadowRoot = function() {\n        dom.importCssString(editorCss, \"ace_editor.css\", this.container);\n    };\n    this.destroy = function() {\n        this.$fontMetrics.destroy();\n        this.$cursorLayer.destroy();\n    };\n\n}).call(VirtualRenderer.prototype);\n\n\nconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n    animatedScroll: {initialValue: false},\n    showInvisibles: {\n        set: function(value) {\n            if (this.$textLayer.setShowInvisibles(value))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: false\n    },\n    showPrintMargin: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: true\n    },\n    printMarginColumn: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: 80\n    },\n    printMargin: {\n        set: function(val) {\n            if (typeof val == \"number\")\n                this.$printMarginColumn = val;\n            this.$showPrintMargin = !!val;\n            this.$updatePrintMargin();\n        },\n        get: function() {\n            return this.$showPrintMargin && this.$printMarginColumn; \n        }\n    },\n    showGutter: {\n        set: function(show){\n            this.$gutter.style.display = show ? \"block\" : \"none\";\n            this.$loop.schedule(this.CHANGE_FULL);\n            this.onGutterResize();\n        },\n        initialValue: true\n    },\n    fadeFoldWidgets: {\n        set: function(show) {\n            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n        },\n        initialValue: false\n    },\n    showFoldWidgets: {\n        set: function(show) {\n            this.$gutterLayer.setShowFoldWidgets(show);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    displayIndentGuides: {\n        set: function(show) {\n            if (this.$textLayer.setDisplayIndentGuides(show))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: true\n    },\n    highlightGutterLine: {\n        set: function(shouldHighlight) {\n            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    hScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    vScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    fontSize: {\n        set: function(size) {\n            if (typeof size == \"number\")\n                size = size + \"px\";\n            this.container.style.fontSize = size;\n            this.updateFontSize();\n        },\n        initialValue: 12\n    },\n    fontFamily: {\n        set: function(name) {\n            this.container.style.fontFamily = name;\n            this.updateFontSize();\n        }\n    },\n    maxLines: {\n        set: function(val) {\n            this.updateFull();\n        }\n    },\n    minLines: {\n        set: function(val) {\n            if (!(this.$minLines < 0x1ffffffffffff))\n                this.$minLines = 0;\n            this.updateFull();\n        }\n    },\n    maxPixelHeight: {\n        set: function(val) {\n            this.updateFull();\n        },\n        initialValue: 0\n    },\n    scrollPastEnd: {\n        set: function(val) {\n            val = +val || 0;\n            if (this.$scrollPastEnd == val)\n                return;\n            this.$scrollPastEnd = val;\n            this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: 0,\n        handlesSet: true\n    },\n    fixedWidthGutter: {\n        set: function(val) {\n            this.$gutterLayer.$fixedWidth = !!val;\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        }\n    },\n    theme: {\n        set: function(val) { this.setTheme(val); },\n        get: function() { return this.$themeId || this.theme; },\n        initialValue: \"./theme/textmate\",\n        handlesSet: true\n    },\n    hasCssTransforms: {\n    },\n    useTextareaForIME: {\n        initialValue: !useragent.isMobile && !useragent.isIE\n    }\n});\n\nexports.VirtualRenderer = VirtualRenderer;\n});\n\nace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar net = require(\"../lib/net\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar config = require(\"../config\");\n\nfunction $workerBlob(workerUrl) {\n    var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n    try {\n        return new Blob([script], {\"type\": \"application/javascript\"});\n    } catch (e) { // Backwards-compatibility\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n        var blobBuilder = new BlobBuilder();\n        blobBuilder.append(script);\n        return blobBuilder.getBlob(\"application/javascript\");\n    }\n}\n\nfunction createWorker(workerUrl) {\n    if (typeof Worker == \"undefined\")\n        return { postMessage: function() {}, terminate: function() {} };\n    if (config.get(\"loadWorkerFromBlob\")) {\n        var blob = $workerBlob(workerUrl);\n        var URL = window.URL || window.webkitURL;\n        var blobURL = URL.createObjectURL(blob);\n        return new Worker(blobURL);\n    }\n    return new Worker(workerUrl);\n}\n\nvar WorkerClient = function(worker) {\n    if (!worker.postMessage)\n        worker = this.$createWorkerFromOldConfig.apply(this, arguments);\n\n    this.$worker = worker;\n    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n\n    this.callbackId = 1;\n    this.callbacks = {};\n\n    this.$worker.onmessage = this.onMessage;\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {\n        if (require.nameToUrl && !require.toUrl)\n            require.toUrl = require.nameToUrl;\n\n        if (config.get(\"packaged\") || !require.toUrl) {\n            workerUrl = workerUrl || config.moduleUrl(mod, \"worker\");\n        } else {\n            var normalizePath = this.$normalizePath;\n            workerUrl = workerUrl || normalizePath(require.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n            var tlns = {};\n            topLevelNamespaces.forEach(function(ns) {\n                tlns[ns] = normalizePath(require.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n            });\n        }\n\n        this.$worker = createWorker(workerUrl);\n        if (importScripts) {\n            this.send(\"importScripts\", importScripts);\n        }\n        this.$worker.postMessage({\n            init : true,\n            tlns : tlns,\n            module : mod,\n            classname : classname\n        });\n        return this.$worker;\n    };\n\n    this.onMessage = function(e) {\n        var msg = e.data;\n        switch (msg.type) {\n            case \"event\":\n                this._signal(msg.name, {data: msg.data});\n                break;\n            case \"call\":\n                var callback = this.callbacks[msg.id];\n                if (callback) {\n                    callback(msg.data);\n                    delete this.callbacks[msg.id];\n                }\n                break;\n            case \"error\":\n                this.reportError(msg.data);\n                break;\n            case \"log\":\n                window.console && console.log && console.log.apply(console, msg.data);\n                break;\n        }\n    };\n    \n    this.reportError = function(err) {\n        window.console && console.error && console.error(err);\n    };\n\n    this.$normalizePath = function(path) {\n        return net.qualifyURL(path);\n    };\n\n    this.terminate = function() {\n        this._signal(\"terminate\", {});\n        this.deltaQueue = null;\n        this.$worker.terminate();\n        this.$worker = null;\n        if (this.$doc)\n            this.$doc.off(\"change\", this.changeListener);\n        this.$doc = null;\n    };\n\n    this.send = function(cmd, args) {\n        this.$worker.postMessage({command: cmd, args: args});\n    };\n\n    this.call = function(cmd, args, callback) {\n        if (callback) {\n            var id = this.callbackId++;\n            this.callbacks[id] = callback;\n            args.push(id);\n        }\n        this.send(cmd, args);\n    };\n\n    this.emit = function(event, data) {\n        try {\n            if (data.data && data.data.err)\n                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};\n            this.$worker.postMessage({event: event, data: {data: data.data}});\n        }\n        catch(ex) {\n            console.error(ex.stack);\n        }\n    };\n\n    this.attachToDocument = function(doc) {\n        if (this.$doc)\n            this.terminate();\n\n        this.$doc = doc;\n        this.call(\"setValue\", [doc.getValue()]);\n        doc.on(\"change\", this.changeListener);\n    };\n\n    this.changeListener = function(delta) {\n        if (!this.deltaQueue) {\n            this.deltaQueue = [];\n            setTimeout(this.$sendDeltaQueue, 0);\n        }\n        if (delta.action == \"insert\")\n            this.deltaQueue.push(delta.start, delta.lines);\n        else\n            this.deltaQueue.push(delta.start, delta.end);\n    };\n\n    this.$sendDeltaQueue = function() {\n        var q = this.deltaQueue;\n        if (!q) return;\n        this.deltaQueue = null;\n        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {\n            this.call(\"setValue\", [this.$doc.getValue()]);\n        } else\n            this.emit(\"change\", {data: q});\n    };\n\n}).call(WorkerClient.prototype);\n\n\nvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n    var main = null;\n    var emitSync = false;\n    var sender = Object.create(EventEmitter);\n\n    var messageBuffer = [];\n    var workerClient = new WorkerClient({\n        messageBuffer: messageBuffer,\n        terminate: function() {},\n        postMessage: function(e) {\n            messageBuffer.push(e);\n            if (!main) return;\n            if (emitSync)\n                setTimeout(processNext);\n            else\n                processNext();\n        }\n    });\n\n    workerClient.setEmitSync = function(val) { emitSync = val; };\n\n    var processNext = function() {\n        var msg = messageBuffer.shift();\n        if (msg.command)\n            main[msg.command].apply(main, msg.args);\n        else if (msg.event)\n            sender._signal(msg.event, msg.data);\n    };\n\n    sender.postMessage = function(msg) {\n        workerClient.onMessage({data: msg});\n    };\n    sender.callback = function(data, callbackId) {\n        this.postMessage({type: \"call\", id: callbackId, data: data});\n    };\n    sender.emit = function(name, data) {\n        this.postMessage({type: \"event\", name: name, data: data});\n    };\n\n    config.loadModule([\"worker\", mod], function(Main) {\n        main = new Main[classname](sender);\n        while (messageBuffer.length)\n            processNext();\n    });\n\n    return workerClient;\n};\n\nexports.UIWorkerClient = UIWorkerClient;\nexports.WorkerClient = WorkerClient;\nexports.createWorker = createWorker;\n\n\n});\n\nace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar oop = require(\"./lib/oop\");\n\nvar PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {\n    var _self = this;\n    this.length = length;\n    this.session = session;\n    this.doc = session.getDocument();\n    this.mainClass = mainClass;\n    this.othersClass = othersClass;\n    this.$onUpdate = this.onUpdate.bind(this);\n    this.doc.on(\"change\", this.$onUpdate);\n    this.$others = others;\n    \n    this.$onCursorChange = function() {\n        setTimeout(function() {\n            _self.onCursorChange();\n        });\n    };\n    \n    this.$pos = pos;\n    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};\n    this.$undoStackDepth = undoStack.length;\n    this.setup();\n\n    session.selection.on(\"changeCursor\", this.$onCursorChange);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setup = function() {\n        var _self = this;\n        var doc = this.doc;\n        var session = this.session;\n        \n        this.selectionBefore = session.selection.toJSON();\n        if (session.selection.inMultiSelectMode)\n            session.selection.toSingleRange();\n\n        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);\n        var pos = this.pos;\n        pos.$insertRight = true;\n        pos.detach();\n        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n        this.others = [];\n        this.$others.forEach(function(other) {\n            var anchor = doc.createAnchor(other.row, other.column);\n            anchor.$insertRight = true;\n            anchor.detach();\n            _self.others.push(anchor);\n        });\n        session.setUndoSelect(false);\n    };\n    this.showOtherMarkers = function() {\n        if (this.othersActive) return;\n        var session = this.session;\n        var _self = this;\n        this.othersActive = true;\n        this.others.forEach(function(anchor) {\n            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);\n        });\n    };\n    this.hideOtherMarkers = function() {\n        if (!this.othersActive) return;\n        this.othersActive = false;\n        for (var i = 0; i < this.others.length; i++) {\n            this.session.removeMarker(this.others[i].markerId);\n        }\n    };\n    this.onUpdate = function(delta) {\n        if (this.$updating)\n            return this.updateAnchors(delta);\n            \n        var range = delta;\n        if (range.start.row !== range.end.row) return;\n        if (range.start.row !== this.pos.row) return;\n        this.$updating = true;\n        var lengthDiff = delta.action === \"insert\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;\n        var distanceFromStart = range.start.column - this.pos.column;\n        \n        this.updateAnchors(delta);\n        \n        if (inMainRange)\n            this.length += lengthDiff;\n\n        if (inMainRange && !this.session.$fromUndo) {\n            if (delta.action === 'insert') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.insertMergedLines(newPos, delta.lines);\n                }\n            } else if (delta.action === 'remove') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n                }\n            }\n        }\n        \n        this.$updating = false;\n        this.updateMarkers();\n    };\n    \n    this.updateAnchors = function(delta) {\n        this.pos.onChange(delta);\n        for (var i = this.others.length; i--;)\n            this.others[i].onChange(delta);\n        this.updateMarkers();\n    };\n    \n    this.updateMarkers = function() {\n        if (this.$updating)\n            return;\n        var _self = this;\n        var session = this.session;\n        var updateMarker = function(pos, className) {\n            session.removeMarker(pos.markerId);\n            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);\n        };\n        updateMarker(this.pos, this.mainClass);\n        for (var i = this.others.length; i--;)\n            updateMarker(this.others[i], this.othersClass);\n    };\n\n    this.onCursorChange = function(event) {\n        if (this.$updating || !this.session) return;\n        var pos = this.session.selection.getCursor();\n        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n            this.showOtherMarkers();\n            this._emit(\"cursorEnter\", event);\n        } else {\n            this.hideOtherMarkers();\n            this._emit(\"cursorLeave\", event);\n        }\n    };    \n    this.detach = function() {\n        this.session.removeMarker(this.pos && this.pos.markerId);\n        this.hideOtherMarkers();\n        this.doc.removeEventListener(\"change\", this.$onUpdate);\n        this.session.selection.removeEventListener(\"changeCursor\", this.$onCursorChange);\n        this.session.setUndoSelect(true);\n        this.session = null;\n    };\n    this.cancel = function() {\n        if (this.$undoStackDepth === -1)\n            return;\n        var undoManager = this.session.getUndoManager();\n        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;\n        for (var i = 0; i < undosRequired; i++) {\n            undoManager.undo(this.session, true);\n        }\n        if (this.selectionBefore)\n            this.session.selection.fromJSON(this.selectionBefore);\n    };\n}).call(PlaceHolder.prototype);\n\n\nexports.PlaceHolder = PlaceHolder;\n});\n\nace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\n\nfunction onMouseDown(e) {\n    var ev = e.domEvent;\n    var alt = ev.altKey;\n    var shift = ev.shiftKey;\n    var ctrl = ev.ctrlKey;\n    var accel = e.getAccelKey();\n    var button = e.getButton();\n    \n    if (ctrl && useragent.isMac)\n        button = ev.button;\n\n    if (e.editor.inMultiSelectMode && button == 2) {\n        e.editor.textInput.onContextMenu(e.domEvent);\n        return;\n    }\n    \n    if (!ctrl && !alt && !accel) {\n        if (button === 0 && e.editor.inMultiSelectMode)\n            e.editor.exitMultiSelectMode();\n        return;\n    }\n    \n    if (button !== 0)\n        return;\n\n    var editor = e.editor;\n    var selection = editor.selection;\n    var isMultiSelect = editor.inMultiSelectMode;\n    var pos = e.getDocumentPosition();\n    var cursor = selection.getCursor();\n    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n\n    var mouseX = e.x, mouseY = e.y;\n    var onMouseSelection = function(e) {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    \n    var session = editor.session;\n    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n    var screenCursor = screenAnchor;\n    \n    var selectionMode;\n    if (editor.$mouseHandler.$enableJumpToDef) {\n        if (ctrl && alt || accel && alt)\n            selectionMode = shift ? \"block\" : \"add\";\n        else if (alt && editor.$blockSelectEnabled)\n            selectionMode = \"block\";\n    } else {\n        if (accel && !alt) {\n            selectionMode = \"add\";\n            if (!isMultiSelect && shift)\n                return;\n        } else if (alt && editor.$blockSelectEnabled) {\n            selectionMode = \"block\";\n        }\n    }\n    \n    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n        editor.$mouseHandler.cancelContextMenu();\n    }\n\n    if (selectionMode == \"add\") {\n        if (!isMultiSelect && inSelection)\n            return; // dragging\n\n        if (!isMultiSelect) {\n            var range = selection.toOrientedRange();\n            editor.addSelectionMarker(range);\n        }\n\n        var oldRange = selection.rangeList.rangeAtPoint(pos);\n        \n        editor.inVirtualSelectionMode = true;\n        \n        if (shift) {\n            oldRange = null;\n            range = selection.ranges[0] || range;\n            editor.removeSelectionMarker(range);\n        }\n        editor.once(\"mouseup\", function() {\n            var tmpSel = selection.toOrientedRange();\n\n            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n                selection.substractPoint(tmpSel.cursor);\n            else {\n                if (shift) {\n                    selection.substractPoint(range.cursor);\n                } else if (range) {\n                    editor.removeSelectionMarker(range);\n                    selection.addRange(range);\n                }\n                selection.addRange(tmpSel);\n            }\n            editor.inVirtualSelectionMode = false;\n        });\n\n    } else if (selectionMode == \"block\") {\n        e.stop();\n        editor.inVirtualSelectionMode = true;        \n        var initialRange;\n        var rectSel = [];\n        var blockSelect = function() {\n            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);\n\n            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n                return;\n            screenCursor = newCursor;\n            \n            editor.selection.moveToPosition(cursor);\n            editor.renderer.scrollCursorIntoView();\n\n            editor.removeSelectionMarkers(rectSel);\n            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n            rectSel.forEach(editor.addSelectionMarker, editor);\n            editor.updateSelectionMarkers();\n        };\n        if (isMultiSelect && !accel) {\n            selection.toSingleRange();\n        } else if (!isMultiSelect && accel) {\n            initialRange = selection.toOrientedRange();\n            editor.addSelectionMarker(initialRange);\n        }\n        \n        if (shift)\n            screenAnchor = session.documentToScreenPosition(selection.lead);            \n        else\n            selection.moveToPosition(pos);\n        \n        screenCursor = {row: -1, column: -1};\n\n        var onMouseSelectionEnd = function(e) {\n            blockSelect();\n            clearInterval(timerId);\n            editor.removeSelectionMarkers(rectSel);\n            if (!rectSel.length)\n                rectSel = [selection.toOrientedRange()];\n            if (initialRange) {\n                editor.removeSelectionMarker(initialRange);\n                selection.toSingleRange(initialRange);\n            }\n            for (var i = 0; i < rectSel.length; i++)\n                selection.addRange(rectSel[i]);\n            editor.inVirtualSelectionMode = false;\n            editor.$mouseHandler.$clickSelection = null;\n        };\n\n        var onSelectionInterval = blockSelect;\n\n        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n        var timerId = setInterval(function() {onSelectionInterval();}, 20);\n\n        return e.preventDefault();\n    }\n}\n\n\nexports.onMouseDown = onMouseDown;\n\n});\n\nace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(require, exports, module) {\nexports.defaultCommands = [{\n    name: \"addCursorAbove\",\n    description: \"Add cursor above\",\n    exec: function(editor) { editor.selectMoreLines(-1); },\n    bindKey: {win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelow\",\n    description: \"Add cursor below\",\n    exec: function(editor) { editor.selectMoreLines(1); },\n    bindKey: {win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorAboveSkipCurrent\",\n    description: \"Add cursor above (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelowSkipCurrent\",\n    description: \"Add cursor below (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreBefore\",\n    description: \"Select more before\",\n    exec: function(editor) { editor.selectMore(-1); },\n    bindKey: {win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreAfter\",\n    description: \"Select more after\",\n    exec: function(editor) { editor.selectMore(1); },\n    bindKey: {win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextBefore\",\n    description: \"Select next before\",\n    exec: function(editor) { editor.selectMore(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextAfter\",\n    description: \"Select next after\",\n    exec: function(editor) { editor.selectMore(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"splitIntoLines\",\n    description: \"Split into lines\",\n    exec: function(editor) { editor.multiSelect.splitIntoLines(); },\n    bindKey: {win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\"},\n    readOnly: true\n}, {\n    name: \"alignCursors\",\n    description: \"Align cursors\",\n    exec: function(editor) { editor.alignCursors(); },\n    bindKey: {win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\"},\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"findAll\",\n    description: \"Find all\",\n    exec: function(editor) { editor.findAll(); },\n    bindKey: {win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}];\nexports.multiSelectCommands = [{\n    name: \"singleSelection\",\n    description: \"Single selection\",\n    bindKey: \"esc\",\n    exec: function(editor) { editor.exitMultiSelectMode(); },\n    scrollIntoView: \"cursor\",\n    readOnly: true,\n    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}\n}];\n\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nexports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n});\n\nace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(require, exports, module) {\n\nvar RangeList = require(\"./range_list\").RangeList;\nvar Range = require(\"./range\").Range;\nvar Selection = require(\"./selection\").Selection;\nvar onMouseDown = require(\"./mouse/multi_select_handler\").onMouseDown;\nvar event = require(\"./lib/event\");\nvar lang = require(\"./lib/lang\");\nvar commands = require(\"./commands/multi_select_commands\");\nexports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\nvar Search = require(\"./search\").Search;\nvar search = new Search();\n\nfunction find(session, needle, dir) {\n    search.$options.wrap = true;\n    search.$options.needle = needle;\n    search.$options.backwards = dir == -1;\n    return search.find(session);\n}\nvar EditSession = require(\"./edit_session\").EditSession;\n(function() {\n    this.getSelectionMarkers = function() {\n        return this.$selectionMarkers;\n    };\n}).call(EditSession.prototype);\n(function() {\n    this.ranges = null;\n    this.rangeList = null;\n    this.addRange = function(range, $blockChangeEvents) {\n        if (!range)\n            return;\n\n        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n            var oldRange = this.toOrientedRange();\n            this.rangeList.add(oldRange);\n            this.rangeList.add(range);\n            if (this.rangeList.ranges.length != 2) {\n                this.rangeList.removeAll();\n                return $blockChangeEvents || this.fromOrientedRange(range);\n            }\n            this.rangeList.removeAll();\n            this.rangeList.add(oldRange);\n            this.$onAddRange(oldRange);\n        }\n\n        if (!range.cursor)\n            range.cursor = range.end;\n\n        var removed = this.rangeList.add(range);\n\n        this.$onAddRange(range);\n\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n            this._signal(\"multiSelect\");\n            this.inMultiSelectMode = true;\n            this.session.$undoSelect = false;\n            this.rangeList.attach(this.session);\n        }\n\n        return $blockChangeEvents || this.fromOrientedRange(range);\n    };\n\n    this.toSingleRange = function(range) {\n        range = range || this.ranges[0];\n        var removed = this.rangeList.removeAll();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        range && this.fromOrientedRange(range);\n    };\n    this.substractPoint = function(pos) {\n        var removed = this.rangeList.substractPoint(pos);\n        if (removed) {\n            this.$onRemoveRange(removed);\n            return removed[0];\n        }\n    };\n    this.mergeOverlappingRanges = function() {\n        var removed = this.rangeList.merge();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n    };\n\n    this.$onAddRange = function(range) {\n        this.rangeCount = this.rangeList.ranges.length;\n        this.ranges.unshift(range);\n        this._signal(\"addRange\", {range: range});\n    };\n\n    this.$onRemoveRange = function(removed) {\n        this.rangeCount = this.rangeList.ranges.length;\n        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n            var lastRange = this.rangeList.ranges.pop();\n            removed.push(lastRange);\n            this.rangeCount = 0;\n        }\n\n        for (var i = removed.length; i--; ) {\n            var index = this.ranges.indexOf(removed[i]);\n            this.ranges.splice(index, 1);\n        }\n\n        this._signal(\"removeRange\", {ranges: removed});\n\n        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n            this.inMultiSelectMode = false;\n            this._signal(\"singleSelect\");\n            this.session.$undoSelect = true;\n            this.rangeList.detach(this.session);\n        }\n\n        lastRange = lastRange || this.ranges[0];\n        if (lastRange && !lastRange.isEqual(this.getRange()))\n            this.fromOrientedRange(lastRange);\n    };\n    this.$initRangeList = function() {\n        if (this.rangeList)\n            return;\n\n        this.rangeList = new RangeList();\n        this.ranges = [];\n        this.rangeCount = 0;\n    };\n    this.getAllRanges = function() {\n        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n    };\n\n    this.splitIntoLines = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        } else {\n            var range = this.getRange();\n            var isBackwards = this.isBackwards();\n            var startRow = range.start.row;\n            var endRow = range.end.row;\n            if (startRow == endRow) {\n                if (isBackwards)\n                    var start = range.end, end = range.start;\n                else\n                    var start = range.start, end = range.end;\n                \n                this.addRange(Range.fromPoints(end, end));\n                this.addRange(Range.fromPoints(start, start));\n                return;\n            }\n\n            var rectSel = [];\n            var r = this.getLineRange(startRow, true);\n            r.start.column = range.start.column;\n            rectSel.push(r);\n\n            for (var i = startRow + 1; i < endRow; i++)\n                rectSel.push(this.getLineRange(i, true));\n\n            r = this.getLineRange(endRow, true);\n            r.end.column = range.end.column;\n            rectSel.push(r);\n\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.toggleBlockSelection = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        } else {\n            var cursor = this.session.documentToScreenPosition(this.cursor);\n            var anchor = this.session.documentToScreenPosition(this.anchor);\n\n            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {\n        var rectSel = [];\n\n        var xBackwards = screenCursor.column < screenAnchor.column;\n        if (xBackwards) {\n            var startColumn = screenCursor.column;\n            var endColumn = screenAnchor.column;\n            var startOffsetX = screenCursor.offsetX;\n            var endOffsetX = screenAnchor.offsetX;\n        } else {\n            var startColumn = screenAnchor.column;\n            var endColumn = screenCursor.column;\n            var startOffsetX = screenAnchor.offsetX;\n            var endOffsetX = screenCursor.offsetX;\n        }\n\n        var yBackwards = screenCursor.row < screenAnchor.row;\n        if (yBackwards) {\n            var startRow = screenCursor.row;\n            var endRow = screenAnchor.row;\n        } else {\n            var startRow = screenAnchor.row;\n            var endRow = screenCursor.row;\n        }\n\n        if (startColumn < 0)\n            startColumn = 0;\n        if (startRow < 0)\n            startRow = 0;\n\n        if (startRow == endRow)\n            includeEmptyLines = true;\n\n        var docEnd;\n        for (var row = startRow; row <= endRow; row++) {\n            var range = Range.fromPoints(\n                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),\n                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)\n            );\n            if (range.isEmpty()) {\n                if (docEnd && isSamePoint(range.end, docEnd))\n                    break;\n                docEnd = range.end;\n            }\n            range.cursor = xBackwards ? range.start : range.end;\n            rectSel.push(range);\n        }\n\n        if (yBackwards)\n            rectSel.reverse();\n\n        if (!includeEmptyLines) {\n            var end = rectSel.length - 1;\n            while (rectSel[end].isEmpty() && end > 0)\n                end--;\n            if (end > 0) {\n                var start = 0;\n                while (rectSel[start].isEmpty())\n                    start++;\n            }\n            for (var i = end; i >= start; i--) {\n                if (rectSel[i].isEmpty())\n                    rectSel.splice(i, 1);\n            }\n        }\n\n        return rectSel;\n    };\n}).call(Selection.prototype);\nvar Editor = require(\"./editor\").Editor;\n(function() {\n    this.updateSelectionMarkers = function() {\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.addSelectionMarker = function(orientedRange) {\n        if (!orientedRange.cursor)\n            orientedRange.cursor = orientedRange.end;\n\n        var style = this.getSelectionStyle();\n        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n\n        this.session.$selectionMarkers.push(orientedRange);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n        return orientedRange;\n    };\n    this.removeSelectionMarker = function(range) {\n        if (!range.marker)\n            return;\n        this.session.removeMarker(range.marker);\n        var index = this.session.$selectionMarkers.indexOf(range);\n        if (index != -1)\n            this.session.$selectionMarkers.splice(index, 1);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n    };\n\n    this.removeSelectionMarkers = function(ranges) {\n        var markerList = this.session.$selectionMarkers;\n        for (var i = ranges.length; i--; ) {\n            var range = ranges[i];\n            if (!range.marker)\n                continue;\n            this.session.removeMarker(range.marker);\n            var index = markerList.indexOf(range);\n            if (index != -1)\n                markerList.splice(index, 1);\n        }\n        this.session.selectionMarkerCount = markerList.length;\n    };\n\n    this.$onAddRange = function(e) {\n        this.addSelectionMarker(e.range);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onRemoveRange = function(e) {\n        this.removeSelectionMarkers(e.ranges);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onMultiSelect = function(e) {\n        if (this.inMultiSelectMode)\n            return;\n        this.inMultiSelectMode = true;\n\n        this.setStyle(\"ace_multiselect\");\n        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onSingleSelect = function(e) {\n        if (this.session.multiSelect.inVirtualMode)\n            return;\n        this.inMultiSelectMode = false;\n\n        this.unsetStyle(\"ace_multiselect\");\n        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n\n        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n        this._emit(\"changeSelection\");\n    };\n\n    this.$onMultiSelectExec = function(e) {\n        var command = e.command;\n        var editor = e.editor;\n        if (!editor.multiSelect)\n            return;\n        if (!command.multiSelectAction) {\n            var result = command.exec(editor, e.args || {});\n            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n            editor.multiSelect.mergeOverlappingRanges();\n        } else if (command.multiSelectAction == \"forEach\") {\n            result = editor.forEachSelection(command, e.args);\n        } else if (command.multiSelectAction == \"forEachLine\") {\n            result = editor.forEachSelection(command, e.args, true);\n        } else if (command.multiSelectAction == \"single\") {\n            editor.exitMultiSelectMode();\n            result = command.exec(editor, e.args || {});\n        } else {\n            result = command.multiSelectAction(editor, e.args || {});\n        }\n        return result;\n    }; \n    this.forEachSelection = function(cmd, args, options) {\n        if (this.inVirtualSelectionMode)\n            return;\n        var keepOrder = options && options.keepOrder;\n        var $byLines = options == true || options && options.$byLines;\n        var session = this.session;\n        var selection = this.selection;\n        var rangeList = selection.rangeList;\n        var ranges = (keepOrder ? selection : rangeList).ranges;\n        var result;\n        \n        if (!ranges.length)\n            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n        \n        var reg = selection._eventRegistry;\n        selection._eventRegistry = {};\n\n        var tmpSel = new Selection(session);\n        this.inVirtualSelectionMode = true;\n        for (var i = ranges.length; i--;) {\n            if ($byLines) {\n                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n                    i--;\n            }\n            tmpSel.fromOrientedRange(ranges[i]);\n            tmpSel.index = i;\n            this.selection = session.selection = tmpSel;\n            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n            if (!result && cmdResult !== undefined)\n                result = cmdResult;\n            tmpSel.toOrientedRange(ranges[i]);\n        }\n        tmpSel.detach();\n\n        this.selection = session.selection = selection;\n        this.inVirtualSelectionMode = false;\n        selection._eventRegistry = reg;\n        selection.mergeOverlappingRanges();\n        if (selection.ranges[0])\n            selection.fromOrientedRange(selection.ranges[0]);\n        \n        var anim = this.renderer.$scrollAnimation;\n        this.onCursorChange();\n        this.onSelectionChange();\n        if (anim && anim.from == anim.to)\n            this.renderer.animateScrolling(anim.from);\n        \n        return result;\n    };\n    this.exitMultiSelectMode = function() {\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n            return;\n        this.multiSelect.toSingleRange();\n    };\n\n    this.getSelectedText = function() {\n        var text = \"\";\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var ranges = this.multiSelect.rangeList.ranges;\n            var buf = [];\n            for (var i = 0; i < ranges.length; i++) {\n                buf.push(this.session.getTextRange(ranges[i]));\n            }\n            var nl = this.session.getDocument().getNewLineCharacter();\n            text = buf.join(nl);\n            if (text.length == (buf.length - 1) * nl.length)\n                text = \"\";\n        } else if (!this.selection.isEmpty()) {\n            text = this.session.getTextRange(this.getSelectionRange());\n        }\n        return text;\n    };\n    \n    this.$checkMultiselectChange = function(e, anchor) {\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var range = this.multiSelect.ranges[0];\n            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n                return;\n            var pos = anchor == this.multiSelect.anchor\n                ? range.cursor == range.start ? range.end : range.start\n                : range.cursor;\n            if (pos.row != anchor.row \n                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)\n                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n            else\n                this.multiSelect.mergeOverlappingRanges();\n        }\n    };\n    this.findAll = function(needle, options, additive) {\n        options = options || {};\n        options.needle = needle || options.needle;\n        if (options.needle == undefined) {\n            var range = this.selection.isEmpty()\n                ? this.selection.getWordRange()\n                : this.selection.getRange();\n            options.needle = this.session.getTextRange(range);\n        }    \n        this.$search.set(options);\n        \n        var ranges = this.$search.findAll(this.session);\n        if (!ranges.length)\n            return 0;\n\n        var selection = this.multiSelect;\n\n        if (!additive)\n            selection.toSingleRange(ranges[0]);\n\n        for (var i = ranges.length; i--; )\n            selection.addRange(ranges[i], true);\n        if (range && selection.rangeList.rangeAtPoint(range.start))\n            selection.addRange(range, true);\n        \n        return ranges.length;\n    };\n    this.selectMoreLines = function(dir, skip) {\n        var range = this.selection.toOrientedRange();\n        var isBackwards = range.cursor == range.end;\n\n        var screenLead = this.session.documentToScreenPosition(range.cursor);\n        if (this.selection.$desiredColumn)\n            screenLead.column = this.selection.$desiredColumn;\n\n        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n\n        if (!range.isEmpty()) {\n            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n        } else {\n            var anchor = lead;\n        }\n\n        if (isBackwards) {\n            var newRange = Range.fromPoints(lead, anchor);\n            newRange.cursor = newRange.start;\n        } else {\n            var newRange = Range.fromPoints(anchor, lead);\n            newRange.cursor = newRange.end;\n        }\n\n        newRange.desiredColumn = screenLead.column;\n        if (!this.selection.inMultiSelectMode) {\n            this.selection.addRange(range);\n        } else {\n            if (skip)\n                var toRemove = range.cursor;\n        }\n\n        this.selection.addRange(newRange);\n        if (toRemove)\n            this.selection.substractPoint(toRemove);\n    };\n    this.transposeSelections = function(dir) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var all = sel.ranges;\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            if (range.isEmpty()) {\n                var tmp = session.getWordRange(range.start.row, range.start.column);\n                range.start.row = tmp.start.row;\n                range.start.column = tmp.start.column;\n                range.end.row = tmp.end.row;\n                range.end.column = tmp.end.column;\n            }\n        }\n        sel.mergeOverlappingRanges();\n\n        var words = [];\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            words.unshift(session.getTextRange(range));\n        }\n\n        if (dir < 0)\n            words.unshift(words.pop());\n        else\n            words.push(words.shift());\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            var tmp = range.clone();\n            session.replace(range, words[i]);\n            range.start.row = tmp.start.row;\n            range.start.column = tmp.start.column;\n        }\n        sel.fromOrientedRange(sel.ranges[0]);\n    };\n    this.selectMore = function(dir, skip, stopAtFirst) {\n        var session = this.session;\n        var sel = session.multiSelect;\n\n        var range = sel.toOrientedRange();\n        if (range.isEmpty()) {\n            range = session.getWordRange(range.start.row, range.start.column);\n            range.cursor = dir == -1 ? range.start : range.end;\n            this.multiSelect.addRange(range);\n            if (stopAtFirst)\n                return;\n        }\n        var needle = session.getTextRange(range);\n\n        var newRange = find(session, needle, dir);\n        if (newRange) {\n            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n            this.session.unfold(newRange);\n            this.multiSelect.addRange(newRange);\n            this.renderer.scrollCursorIntoView(null, 0.5);\n        }\n        if (skip)\n            this.multiSelect.substractPoint(range.cursor);\n    };\n    this.alignCursors = function() {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var ranges = sel.ranges;\n        var row = -1;\n        var sameRowRanges = ranges.filter(function(r) {\n            if (r.cursor.row == row)\n                return true;\n            row = r.cursor.row;\n        });\n        \n        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n            var range = this.selection.getRange();\n            var fr = range.start.row, lr = range.end.row;\n            var guessRange = fr == lr;\n            if (guessRange) {\n                var max = this.session.getLength();\n                var line;\n                do {\n                    line = this.session.getLine(lr);\n                } while (/[=:]/.test(line) && ++lr < max);\n                do {\n                    line = this.session.getLine(fr);\n                } while (/[=:]/.test(line) && --fr > 0);\n                \n                if (fr < 0) fr = 0;\n                if (lr >= max) lr = max - 1;\n            }\n            var lines = this.session.removeFullLines(fr, lr);\n            lines = this.$reAlignText(lines, guessRange);\n            this.session.insert({row: fr, column: 0}, lines.join(\"\\n\") + \"\\n\");\n            if (!guessRange) {\n                range.start.column = 0;\n                range.end.column = lines[lines.length - 1].length;\n            }\n            this.selection.setRange(range);\n        } else {\n            sameRowRanges.forEach(function(r) {\n                sel.substractPoint(r.cursor);\n            });\n\n            var maxCol = 0;\n            var minSpace = Infinity;\n            var spaceOffsets = ranges.map(function(r) {\n                var p = r.cursor;\n                var line = session.getLine(p.row);\n                var spaceOffset = line.substr(p.column).search(/\\S/g);\n                if (spaceOffset == -1)\n                    spaceOffset = 0;\n\n                if (p.column > maxCol)\n                    maxCol = p.column;\n                if (spaceOffset < minSpace)\n                    minSpace = spaceOffset;\n                return spaceOffset;\n            });\n            ranges.forEach(function(r, i) {\n                var p = r.cursor;\n                var l = maxCol - p.column;\n                var d = spaceOffsets[i] - minSpace;\n                if (l > d)\n                    session.insert(p, lang.stringRepeat(\" \", l - d));\n                else\n                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n\n                r.start.column = r.end.column = maxCol;\n                r.start.row = r.end.row = p.row;\n                r.cursor = r.end;\n            });\n            sel.fromOrientedRange(ranges[0]);\n            this.renderer.updateCursor();\n            this.renderer.updateBackMarkers();\n        }\n    };\n\n    this.$reAlignText = function(lines, forceLeft) {\n        var isLeftAligned = true, isRightAligned = true;\n        var startW, textW, endW;\n\n        return lines.map(function(line) {\n            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n            if (!m)\n                return [line];\n\n            if (startW == null) {\n                startW = m[1].length;\n                textW = m[2].length;\n                endW = m[3].length;\n                return m;\n            }\n\n            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n                isRightAligned = false;\n            if (startW != m[1].length)\n                isLeftAligned = false;\n\n            if (startW > m[1].length)\n                startW = m[1].length;\n            if (textW < m[2].length)\n                textW = m[2].length;\n            if (endW > m[3].length)\n                endW = m[3].length;\n\n            return m;\n        }).map(forceLeft ? alignLeft :\n            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n\n        function spaces(n) {\n            return lang.stringRepeat(\" \", n);\n        }\n\n        function alignLeft(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(textW - m[2].length + endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function alignRight(m) {\n            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function unAlign(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n    };\n}).call(Editor.prototype);\n\n\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nexports.onSessionChange = function(e) {\n    var session = e.session;\n    if (session && !session.multiSelect) {\n        session.$selectionMarkers = [];\n        session.selection.$initRangeList();\n        session.multiSelect = session.selection;\n    }\n    this.multiSelect = session && session.multiSelect;\n\n    var oldSession = e.oldSession;\n    if (oldSession) {\n        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n        oldSession.multiSelect.lead.off(\"change\", this.$checkMultiselectChange);\n        oldSession.multiSelect.anchor.off(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session) {\n        session.multiSelect.on(\"addRange\", this.$onAddRange);\n        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n        session.multiSelect.lead.on(\"change\", this.$checkMultiselectChange);\n        session.multiSelect.anchor.on(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n        if (session.selection.inMultiSelectMode)\n            this.$onMultiSelect();\n        else\n            this.$onSingleSelect();\n    }\n};\nfunction MultiSelect(editor) {\n    if (editor.$multiselectOnSessionChange)\n        return;\n    editor.$onAddRange = editor.$onAddRange.bind(editor);\n    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n\n    editor.$multiselectOnSessionChange(editor);\n    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n\n    editor.on(\"mousedown\", onMouseDown);\n    editor.commands.addCommands(commands.defaultCommands);\n\n    addAltCursorListeners(editor);\n}\n\nfunction addAltCursorListeners(editor){\n    var el = editor.textInput.getElement();\n    var altCursor = false;\n    event.addListener(el, \"keydown\", function(e) {\n        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);\n        if (editor.$blockSelectEnabled && altDown) {\n            if (!altCursor) {\n                editor.renderer.setMouseCursor(\"crosshair\");\n                altCursor = true;\n            }\n        } else if (altCursor) {\n            reset();\n        }\n    });\n\n    event.addListener(el, \"keyup\", reset);\n    event.addListener(el, \"blur\", reset);\n    function reset(e) {\n        if (altCursor) {\n            editor.renderer.setMouseCursor(\"\");\n            altCursor = false;\n        }\n    }\n}\n\nexports.MultiSelect = MultiSelect;\n\n\nrequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    enableMultiselect: {\n        set: function(val) {\n            MultiSelect(this);\n            if (val) {\n                this.on(\"changeSession\", this.$multiselectOnSessionChange);\n                this.on(\"mousedown\", onMouseDown);\n            } else {\n                this.off(\"changeSession\", this.$multiselectOnSessionChange);\n                this.off(\"mousedown\", onMouseDown);\n            }\n        },\n        value: true\n    },\n    enableBlockSelect: {\n        set: function(val) {\n            this.$blockSelectEnabled = val;\n        },\n        value: true\n    }\n});\n\n\n\n});\n\nace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\n\n(function() {\n\n    this.foldingStartMarker = null;\n    this.foldingStopMarker = null;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (this.foldingStartMarker.test(line))\n            return \"start\";\n        if (foldStyle == \"markbeginend\"\n                && this.foldingStopMarker\n                && this.foldingStopMarker.test(line))\n            return \"end\";\n        return \"\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        return null;\n    };\n\n    this.indentationBlock = function(session, row, column) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1)\n            return;\n\n        var startColumn = column || line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            var level = session.getLine(row).search(re);\n\n            if (level == -1)\n                continue;\n\n            if (level <= startLevel)\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var start = {row: row, column: column + 1};\n        var end = session.$findClosingBracket(bracket, start, typeRe);\n        if (!end)\n            return;\n\n        var fw = session.foldWidgets[end.row];\n        if (fw == null)\n            fw = session.getFoldWidget(end.row);\n\n        if (fw == \"start\" && end.row > start.row) {\n            end.row --;\n            end.column = session.getLine(end.row).length;\n        }\n        return Range.fromPoints(start, end);\n    };\n\n    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var end = {row: row, column: column};\n        var start = session.$findOpeningBracket(bracket, end);\n\n        if (!start)\n            return;\n\n        start.column++;\n        end.column--;\n\n        return  Range.fromPoints(start, end);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nexports.isDark = false;\nexports.cssClass = \"ace-tm\";\nexports.cssText = \".ace-tm .ace_gutter {\\\nbackground: #f0f0f0;\\\ncolor: #333;\\\n}\\\n.ace-tm .ace_print-margin {\\\nwidth: 1px;\\\nbackground: #e8e8e8;\\\n}\\\n.ace-tm .ace_fold {\\\nbackground-color: #6B72E6;\\\n}\\\n.ace-tm {\\\nbackground-color: #FFFFFF;\\\ncolor: black;\\\n}\\\n.ace-tm .ace_cursor {\\\ncolor: black;\\\n}\\\n.ace-tm .ace_invisible {\\\ncolor: rgb(191, 191, 191);\\\n}\\\n.ace-tm .ace_storage,\\\n.ace-tm .ace_keyword {\\\ncolor: blue;\\\n}\\\n.ace-tm .ace_constant {\\\ncolor: rgb(197, 6, 11);\\\n}\\\n.ace-tm .ace_constant.ace_buildin {\\\ncolor: rgb(88, 72, 246);\\\n}\\\n.ace-tm .ace_constant.ace_language {\\\ncolor: rgb(88, 92, 246);\\\n}\\\n.ace-tm .ace_constant.ace_library {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_invalid {\\\nbackground-color: rgba(255, 0, 0, 0.1);\\\ncolor: red;\\\n}\\\n.ace-tm .ace_support.ace_function {\\\ncolor: rgb(60, 76, 114);\\\n}\\\n.ace-tm .ace_support.ace_constant {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_support.ace_type,\\\n.ace-tm .ace_support.ace_class {\\\ncolor: rgb(109, 121, 222);\\\n}\\\n.ace-tm .ace_keyword.ace_operator {\\\ncolor: rgb(104, 118, 135);\\\n}\\\n.ace-tm .ace_string {\\\ncolor: rgb(3, 106, 7);\\\n}\\\n.ace-tm .ace_comment {\\\ncolor: rgb(76, 136, 107);\\\n}\\\n.ace-tm .ace_comment.ace_doc {\\\ncolor: rgb(0, 102, 255);\\\n}\\\n.ace-tm .ace_comment.ace_doc.ace_tag {\\\ncolor: rgb(128, 159, 191);\\\n}\\\n.ace-tm .ace_constant.ace_numeric {\\\ncolor: rgb(0, 0, 205);\\\n}\\\n.ace-tm .ace_variable {\\\ncolor: rgb(49, 132, 149);\\\n}\\\n.ace-tm .ace_xml-pe {\\\ncolor: rgb(104, 104, 91);\\\n}\\\n.ace-tm .ace_entity.ace_name.ace_function {\\\ncolor: #0000A2;\\\n}\\\n.ace-tm .ace_heading {\\\ncolor: rgb(12, 7, 255);\\\n}\\\n.ace-tm .ace_list {\\\ncolor:rgb(185, 6, 144);\\\n}\\\n.ace-tm .ace_meta.ace_tag {\\\ncolor:rgb(0, 22, 142);\\\n}\\\n.ace-tm .ace_string.ace_regex {\\\ncolor: rgb(255, 0, 0)\\\n}\\\n.ace-tm .ace_marker-layer .ace_selection {\\\nbackground: rgb(181, 213, 255);\\\n}\\\n.ace-tm.ace_multiselect .ace_selection.ace_start {\\\nbox-shadow: 0 0 3px 0px white;\\\n}\\\n.ace-tm .ace_marker-layer .ace_step {\\\nbackground: rgb(252, 255, 0);\\\n}\\\n.ace-tm .ace_marker-layer .ace_stack {\\\nbackground: rgb(164, 229, 101);\\\n}\\\n.ace-tm .ace_marker-layer .ace_bracket {\\\nmargin: -1px 0 0 -1px;\\\nborder: 1px solid rgb(192, 192, 192);\\\n}\\\n.ace-tm .ace_marker-layer .ace_active-line {\\\nbackground: rgba(0, 0, 0, 0.07);\\\n}\\\n.ace-tm .ace_gutter-active-line {\\\nbackground-color : #dcdcdc;\\\n}\\\n.ace-tm .ace_marker-layer .ace_selected-word {\\\nbackground: rgb(250, 250, 255);\\\nborder: 1px solid rgb(200, 200, 250);\\\n}\\\n.ace-tm .ace_indent-guide {\\\nbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\\n}\\\n\";\nexports.$id = \"ace/theme/textmate\";\n\nvar dom = require(\"../lib/dom\");\ndom.importCssString(exports.cssText, exports.cssClass);\n});\n\nace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar Range = require(\"./range\").Range;\n\n\nfunction LineWidgets(session) {\n    this.session = session;\n    this.session.widgetManager = this;\n    this.session.getRowLength = this.getRowLength;\n    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n    this.updateOnChange = this.updateOnChange.bind(this);\n    this.renderWidgets = this.renderWidgets.bind(this);\n    this.measureWidgets = this.measureWidgets.bind(this);\n    this.session._changedWidgets = [];\n    this.$onChangeEditor = this.$onChangeEditor.bind(this);\n    \n    this.session.on(\"change\", this.updateOnChange);\n    this.session.on(\"changeFold\", this.updateOnFold);\n    this.session.on(\"changeEditor\", this.$onChangeEditor);\n}\n\n(function() {\n    this.getRowLength = function(row) {\n        var h;\n        if (this.lineWidgets)\n            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else \n            h = 0;\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1 + h;\n        } else {\n            return this.$wrapData[row].length + 1 + h;\n        }\n    };\n\n    this.$getWidgetScreenLength = function() {\n        var screenRows = 0;\n        this.lineWidgets.forEach(function(w){\n            if (w && w.rowCount && !w.hidden)\n                screenRows += w.rowCount;\n        });\n        return screenRows;\n    };    \n    \n    this.$onChangeEditor = function(e) {\n        this.attach(e.editor);\n    };\n    \n    this.attach = function(editor) {\n        if (editor  && editor.widgetManager && editor.widgetManager != this)\n            editor.widgetManager.detach();\n\n        if (this.editor == editor)\n            return;\n\n        this.detach();\n        this.editor = editor;\n        \n        if (editor) {\n            editor.widgetManager = this;\n            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n            editor.renderer.on(\"afterRender\", this.renderWidgets);\n        }\n    };\n    this.detach = function(e) {\n        var editor = this.editor;\n        if (!editor)\n            return;\n        \n        this.editor = null;\n        editor.widgetManager = null;\n        \n        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n        editor.renderer.off(\"afterRender\", this.renderWidgets);\n        var lineWidgets = this.session.lineWidgets;\n        lineWidgets && lineWidgets.forEach(function(w) {\n            if (w && w.el && w.el.parentNode) {\n                w._inDocument = false;\n                w.el.parentNode.removeChild(w.el);\n            }\n        });\n    };\n\n    this.updateOnFold = function(e, session) {\n        var lineWidgets = session.lineWidgets;\n        if (!lineWidgets || !e.action)\n            return;\n        var fold = e.data;\n        var start = fold.start.row;\n        var end = fold.end.row;\n        var hide = e.action == \"add\";\n        for (var i = start + 1; i < end; i++) {\n            if (lineWidgets[i])\n                lineWidgets[i].hidden = hide;\n        }\n        if (lineWidgets[end]) {\n            if (hide) {\n                if (!lineWidgets[start])\n                    lineWidgets[start] = lineWidgets[end];\n                else\n                    lineWidgets[end].hidden = hide;\n            } else {\n                if (lineWidgets[start] == lineWidgets[end])\n                    lineWidgets[start] = undefined;\n                lineWidgets[end].hidden = hide;\n            }\n        }\n    };\n    \n    this.updateOnChange = function(delta) {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        \n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n        } else if (delta.action == 'remove') {\n            var removed = lineWidgets.splice(startRow + 1, len);\n            removed.forEach(function(w) {\n                w && this.removeLineWidget(w);\n            }, this);\n            this.$updateRows();\n        } else {\n            var args = new Array(len);\n            args.unshift(startRow, 0);\n            lineWidgets.splice.apply(lineWidgets, args);\n            this.$updateRows();\n        }\n    };\n    \n    this.$updateRows = function() {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        var noWidgets = true;\n        lineWidgets.forEach(function(w, i) {\n            if (w) {\n                noWidgets = false;\n                w.row = i;\n                while (w.$oldWidget) {\n                    w.$oldWidget.row = i;\n                    w = w.$oldWidget;\n                }\n            }\n        });\n        if (noWidgets)\n            this.session.lineWidgets = null;\n    };\n\n    this.addLineWidget = function(w) {\n        if (!this.session.lineWidgets)\n            this.session.lineWidgets = new Array(this.session.getLength());\n        \n        var old = this.session.lineWidgets[w.row];\n        if (old) {\n            w.$oldWidget = old;\n            if (old.el && old.el.parentNode) {\n                old.el.parentNode.removeChild(old.el);\n                old._inDocument = false;\n            }\n        }\n            \n        this.session.lineWidgets[w.row] = w;\n        \n        w.session = this.session;\n        \n        var renderer = this.editor.renderer;\n        if (w.html && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.innerHTML = w.html;\n        }\n        if (w.el) {\n            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n            w.el.style.position = \"absolute\";\n            w.el.style.zIndex = 5;\n            renderer.container.appendChild(w.el);\n            w._inDocument = true;\n        }\n        \n        if (!w.coverGutter) {\n            w.el.style.zIndex = 3;\n        }\n        if (w.pixelHeight == null) {\n            w.pixelHeight = w.el.offsetHeight;\n        }\n        if (w.rowCount == null) {\n            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n        }\n        \n        var fold = this.session.getFoldAt(w.row, 0);\n        w.$fold = fold;\n        if (fold) {\n            var lineWidgets = this.session.lineWidgets;\n            if (w.row == fold.end.row && !lineWidgets[fold.start.row])\n                lineWidgets[fold.start.row] = w;\n            else\n                w.hidden = true;\n        }\n            \n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        \n        this.$updateRows();\n        this.renderWidgets(null, renderer);\n        this.onWidgetChanged(w);\n        return w;\n    };\n    \n    this.removeLineWidget = function(w) {\n        w._inDocument = false;\n        w.session = null;\n        if (w.el && w.el.parentNode)\n            w.el.parentNode.removeChild(w.el);\n        if (w.editor && w.editor.destroy) try {\n            w.editor.destroy();\n        } catch(e){}\n        if (this.session.lineWidgets) {\n            var w1 = this.session.lineWidgets[w.row];\n            if (w1 == w) {\n                this.session.lineWidgets[w.row] = w.$oldWidget;\n                if (w.$oldWidget)\n                    this.onWidgetChanged(w.$oldWidget);\n            } else {\n                while (w1) {\n                    if (w1.$oldWidget == w) {\n                        w1.$oldWidget = w.$oldWidget;\n                        break;\n                    }\n                    w1 = w1.$oldWidget;\n                }\n            }\n        }\n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        this.$updateRows();\n    };\n    \n    this.getWidgetsAtRow = function(row) {\n        var lineWidgets = this.session.lineWidgets;\n        var w = lineWidgets && lineWidgets[row];\n        var list = [];\n        while (w) {\n            list.push(w);\n            w = w.$oldWidget;\n        }\n        return list;\n    };\n    \n    this.onWidgetChanged = function(w) {\n        this.session._changedWidgets.push(w);\n        this.editor && this.editor.renderer.updateFull();\n    };\n    \n    this.measureWidgets = function(e, renderer) {\n        var changedWidgets = this.session._changedWidgets;\n        var config = renderer.layerConfig;\n        \n        if (!changedWidgets || !changedWidgets.length) return;\n        var min = Infinity;\n        for (var i = 0; i < changedWidgets.length; i++) {\n            var w = changedWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.session != this.session) continue;\n            if (!w._inDocument) {\n                if (this.session.lineWidgets[w.row] != w)\n                    continue;\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            \n            w.h = w.el.offsetHeight;\n            \n            if (!w.fixedWidth) {\n                w.w = w.el.offsetWidth;\n                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n            }\n            \n            var rowCount = w.h / config.lineHeight;\n            if (w.coverLine) {\n                rowCount -= this.session.getRowLineCount(w.row);\n                if (rowCount < 0)\n                    rowCount = 0;\n            }\n            if (w.rowCount != rowCount) {\n                w.rowCount = rowCount;\n                if (w.row < min)\n                    min = w.row;\n            }\n        }\n        if (min != Infinity) {\n            this.session._emit(\"changeFold\", {data:{start:{row: min}}});\n            this.session.lineWidgetWidth = null;\n        }\n        this.session._changedWidgets = [];\n    };\n    \n    this.renderWidgets = function(e, renderer) {\n        var config = renderer.layerConfig;\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var first = Math.min(this.firstRow, config.firstRow);\n        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n        \n        while (first > 0 && !lineWidgets[first])\n            first--;\n        \n        this.firstRow = config.firstRow;\n        this.lastRow = config.lastRow;\n\n        renderer.$cursorLayer.config = config;\n        for (var i = first; i <= last; i++) {\n            var w = lineWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.hidden) {\n                w.el.style.top = -100 - (w.pixelHeight || 0) + \"px\";\n                continue;\n            }\n            if (!w._inDocument) {\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;\n            if (!w.coverLine)\n                top += config.lineHeight * this.session.getRowLineCount(w.row);\n            w.el.style.top = top - config.offset + \"px\";\n            \n            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n            if (!w.fixedWidth)\n                left -= renderer.scrollLeft;\n            w.el.style.left = left + \"px\";\n            \n            if (w.fullWidth && w.screenWidth) {\n                w.el.style.minWidth = config.width + 2 * config.padding + \"px\";\n            }\n            \n            if (w.fixedWidth) {\n                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n            } else {\n                w.el.style.right = \"\";\n            }\n        }\n    };\n    \n}).call(LineWidgets.prototype);\n\n\nexports.LineWidgets = LineWidgets;\n\n});\n\nace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/line_widgets\",\"ace/lib/dom\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar LineWidgets = require(\"../line_widgets\").LineWidgets;\nvar dom = require(\"../lib/dom\");\nvar Range = require(\"../range\").Range;\n\nfunction binarySearch(array, needle, comparator) {\n    var first = 0;\n    var last = array.length - 1;\n\n    while (first <= last) {\n        var mid = (first + last) >> 1;\n        var c = comparator(needle, array[mid]);\n        if (c > 0)\n            first = mid + 1;\n        else if (c < 0)\n            last = mid - 1;\n        else\n            return mid;\n    }\n    return -(first + 1);\n}\n\nfunction findAnnotations(session, row, dir) {\n    var annotations = session.getAnnotations().sort(Range.comparePoints);\n    if (!annotations.length)\n        return;\n    \n    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);\n    if (i < 0)\n        i = -i - 1;\n    \n    if (i >= annotations.length)\n        i = dir > 0 ? 0 : annotations.length - 1;\n    else if (i === 0 && dir < 0)\n        i = annotations.length - 1;\n    \n    var annotation = annotations[i];\n    if (!annotation || !dir)\n        return;\n\n    if (annotation.row === row) {\n        do {\n            annotation = annotations[i += dir];\n        } while (annotation && annotation.row === row);\n        if (!annotation)\n            return annotations.slice();\n    }\n    \n    \n    var matched = [];\n    row = annotation.row;\n    do {\n        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n        annotation = annotations[i += dir];\n    } while (annotation && annotation.row == row);\n    return matched.length && matched;\n}\n\nexports.showErrorMarker = function(editor, dir) {\n    var session = editor.session;\n    if (!session.widgetManager) {\n        session.widgetManager = new LineWidgets(session);\n        session.widgetManager.attach(editor);\n    }\n    \n    var pos = editor.getCursorPosition();\n    var row = pos.row;\n    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {\n        return w.type == \"errorMarker\";\n    })[0];\n    if (oldWidget) {\n        oldWidget.destroy();\n    } else {\n        row -= dir;\n    }\n    var annotations = findAnnotations(session, row, dir);\n    var gutterAnno;\n    if (annotations) {\n        var annotation = annotations[0];\n        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n            ? annotation.pos.sc\n            : annotation.column) || 0;\n        pos.row = annotation.row;\n        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n    } else if (oldWidget) {\n        return;\n    } else {\n        gutterAnno = {\n            text: [\"Looks good!\"],\n            className: \"ace_ok\"\n        };\n    }\n    editor.session.unfold(pos.row);\n    editor.selection.moveToPosition(pos);\n    \n    var w = {\n        row: pos.row, \n        fixedWidth: true,\n        coverGutter: true,\n        el: dom.createElement(\"div\"),\n        type: \"errorMarker\"\n    };\n    var el = w.el.appendChild(dom.createElement(\"div\"));\n    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n    \n    var left = editor.renderer.$cursorLayer\n        .getPixelPosition(pos).left;\n    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n    \n    w.el.className = \"error_widget_wrapper\";\n    el.className = \"error_widget \" + gutterAnno.className;\n    el.innerHTML = gutterAnno.text.join(\"<br>\");\n    \n    el.appendChild(dom.createElement(\"div\"));\n    \n    var kb = function(_, hashId, keyString) {\n        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n            w.destroy();\n            return {command: \"null\"};\n        }\n    };\n    \n    w.destroy = function() {\n        if (editor.$mouseHandler.isMousePressed)\n            return;\n        editor.keyBinding.removeKeyboardHandler(kb);\n        session.widgetManager.removeLineWidget(w);\n        editor.off(\"changeSelection\", w.destroy);\n        editor.off(\"changeSession\", w.destroy);\n        editor.off(\"mouseup\", w.destroy);\n        editor.off(\"change\", w.destroy);\n    };\n    \n    editor.keyBinding.addKeyboardHandler(kb);\n    editor.on(\"changeSelection\", w.destroy);\n    editor.on(\"changeSession\", w.destroy);\n    editor.on(\"mouseup\", w.destroy);\n    editor.on(\"change\", w.destroy);\n    \n    editor.session.widgetManager.addLineWidget(w);\n    \n    w.el.onmousedown = editor.focus.bind(editor);\n    \n    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});\n};\n\n\ndom.importCssString(\"\\\n    .error_widget_wrapper {\\\n        background: inherit;\\\n        color: inherit;\\\n        border:none\\\n    }\\\n    .error_widget {\\\n        border-top: solid 2px;\\\n        border-bottom: solid 2px;\\\n        margin: 5px 0;\\\n        padding: 10px 40px;\\\n        white-space: pre-wrap;\\\n    }\\\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\\\n        border-color: #ff5a5a\\\n    }\\\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\\n        border-color: #F1D817\\\n    }\\\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\\\n        border-color: #5a5a5a\\\n    }\\\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\\n        border-color: #5aaa5a\\\n    }\\\n    .error_widget_arrow {\\\n        position: absolute;\\\n        border: solid 5px;\\\n        border-top-color: transparent!important;\\\n        border-right-color: transparent!important;\\\n        border-left-color: transparent!important;\\\n        top: -5px;\\\n    }\\\n\", \"\");\n\n});\n\nace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/range\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\n\nvar Range = require(\"./range\").Range;\nvar Editor = require(\"./editor\").Editor;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nrequire(\"./worker/worker_client\");\nrequire(\"./keyboard/hash_handler\");\nrequire(\"./placeholder\");\nrequire(\"./multi_select\");\nrequire(\"./mode/folding/fold_mode\");\nrequire(\"./theme/textmate\");\nrequire(\"./ext/error_marker\");\n\nexports.config = require(\"./config\");\nexports.require = require;\n\nif (true)\n    exports.define = __webpack_require__(3);\nexports.edit = function(el, options) {\n    if (typeof el == \"string\") {\n        var _id = el;\n        el = document.getElementById(_id);\n        if (!el)\n            throw new Error(\"ace.edit can't find div #\" + _id);\n    }\n\n    if (el && el.env && el.env.editor instanceof Editor)\n        return el.env.editor;\n\n    var value = \"\";\n    if (el && /input|textarea/i.test(el.tagName)) {\n        var oldNode = el;\n        value = oldNode.value;\n        el = dom.createElement(\"pre\");\n        oldNode.parentNode.replaceChild(el, oldNode);\n    } else if (el) {\n        value = el.textContent;\n        el.innerHTML = \"\";\n    }\n\n    var doc = exports.createEditSession(value);\n\n    var editor = new Editor(new Renderer(el), doc, options);\n\n    var env = {\n        document: doc,\n        editor: editor,\n        onResize: editor.resize.bind(editor, null)\n    };\n    if (oldNode) env.textarea = oldNode;\n    event.addListener(window, \"resize\", env.onResize);\n    editor.on(\"destroy\", function() {\n        event.removeListener(window, \"resize\", env.onResize);\n        env.editor.container.env = null; // prevent memory leak on old ie\n    });\n    editor.container.env = editor.env = env;\n    return editor;\n};\nexports.createEditSession = function(text, mode) {\n    var doc = new EditSession(text, mode);\n    doc.setUndoManager(new UndoManager());\n    return doc;\n};\nexports.Range = Range;\nexports.Editor = Editor;\nexports.EditSession = EditSession;\nexports.UndoManager = UndoManager;\nexports.VirtualRenderer = Renderer;\nexports.version = \"1.4.4\";\n});            (function() {\n                ace.require([\"ace/ace\"], function(a) {\n                    if (a) {\n                        a.config.init(true);\n                        a.define = ace.define;\n                    }\n                    if (!window.ace)\n                        window.ace = a;\n                    for (var key in a) if (a.hasOwnProperty(key))\n                        window.ace[key] = a[key];\n                    window.ace[\"default\"] = window.ace;\n                    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                        module.exports = window.ace;\n                    }\n                });\n            })();\n        \n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)(module)))\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AceHandler; });\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Imports\nvar vm = __webpack_require__(18);\nvar util = __webpack_require__(19);\n\n/*\n*   Handles code from Ace Editor\n*/\nvar AceHandler = function () {\n    function AceHandler() {\n        _classCallCheck(this, AceHandler);\n    }\n\n    _createClass(AceHandler, [{\n        key: 'runCode',\n        value: function runCode(code, variables) {\n\n            var script = new vm.Script(code);\n\n            var sandbox = {};\n            script.runInNewContext(sandbox);\n\n            var results = [];\n\n            variables.forEach(function (variable) {\n                results.push(variable + ': ' + util.inspect(sandbox[variable]));\n            });\n\n            return results;\n        }\n    }, {\n        key: 'runFunction',\n        value: function runFunction(code, functionName, variables) {\n            var _console;\n\n            var script = new vm.Script(code);\n\n            var sandbox = {};\n            script.runInNewContext(sandbox);\n            (_console = console).log.apply(_console, _toConsumableArray(variables));\n            console.log(variables);\n            return util.inspect(sandbox[functionName].apply(sandbox, _toConsumableArray(variables)));\n        }\n    }]);\n\n    return AceHandler;\n}();\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\nvar indexOf = function (xs, item) {\n    if (xs.indexOf) return xs.indexOf(item);\n    else for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === item) return i;\n    }\n    return -1;\n};\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    if (context) {\n        forEach(Object_keys(ctx), function (key) {\n            context[key] = ctx[key];\n        });\n    }\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.isContext = function (context) {\n    return context instanceof Context;\n};\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = Object({\"NODE_ENV\":\"production\"}).NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(20);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(21);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('div',{attrs:{\"id\":\"editor\"}}),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"shell\"}},[_vm._m(0),_vm._v(\" \"),_c('div',{staticClass:\"input-line\"},[_c('span',{staticStyle:{\"font-size\":\"10px\"}},[_vm._v(\">\")]),_vm._v(\" \"),_c('form',{on:{\"submit\":function($event){$event.preventDefault();return _vm.runCommand()}}},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.shellInput),expression:\"shellInput\"}],attrs:{\"type\":\"text\"},domProps:{\"value\":(_vm.shellInput)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.shellInput=$event.target.value}}})])])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"shell-content\"},[_c('p',[_vm._v(\"Interactive JavaScript Shell\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// build.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f60e1f6e61bc63669b1a","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 1\n// module chunks = 0","<template>\n  <div id=\"app\">\n    <div id=\"editor\"></div>\n    <div id=\"shell\">\n      <div class=\"shell-content\">\n        <p>Interactive JavaScript Shell</p>\n      </div>\n      <div class=\"input-line\"><span style=\"font-size: 10px;\">></span>\n        <form v-on:submit.prevent=\"runCommand()\">\n          <input v-model=\"shellInput\" type=\"text\" >\n        </form>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as ace from '../node_modules/ace-builds/src-noconflict/ace';\nimport { AceHandler } from './aceHandler';\n\nexport default {\n  name: 'app',\n  data () {\n    return {\n      editor: null,\n      shellInput: '',\n      aceHandler: null,\n      commands: ['help - see a list of commands', \n        'random - returns a random float between 0 and 1', \n        'clear - clears shell',\n        \"run VARIABLES - runs all code in the editor and prints the value of the variable names past\"]\n    }\n  },\n  mounted() {\n    ace.config.set('basePath','../node_modules/ace-builds/src-noconflict');\n    this.editor = ace.edit('editor');\n    this.editor.setTheme('ace/theme/monokai');\n    this.editor.session.setMode('ace/mode/javascript');\n\n    this.aceHandler = new AceHandler();\n  },\n  methods: {\n    runCommand() {\n      var command = this.shellInput.split(\" \")[0];\n\n      var par = document.createElement('p')\n      par.appendChild(document.createTextNode('> ' + this.shellInput));\n      par.style = 'input';\n      document.getElementsByClassName('shell-content')[0].appendChild(par);\n\n      if( command.toLowerCase() === 'help') {\n        this.commands.forEach((command) => {\n          this.printOutput(command);\n        });\n      } else if( command.toLowerCase() === 'clear') {\n        document.getElementsByClassName('shell-content')[0].innerHTML = '<p>Shell content cleared</p>'\n      } else if( command.toLowerCase() === 'random') {\n        this.printOutput(Math.random())\n      } else if( command.toLowerCase() === 'run') {\n        var args = this.shellInput.split(\" \").splice(1);\n        this.aceHandler.runCode(this.editor.getValue(), args).forEach((result) => {\n          this.printOutput(result);     \n        });\n      } else if( this.shellInput.includes('(') && this.shellInput.includes(')')) {\n        var functionName = this.shellInput.split('(')[0];\n        var functionArgs = this.shellInput.split('(')[1];\n        functionArgs = functionArgs.substring(0,functionArgs.length-1).split(\",\");\n        // Convert to correct variable type\n        functionArgs = functionArgs.map((arg) => {\n          arg = arg.trim();\n          \n          // If string remove quotes\n          if(arg.charAt(0) == '\"' || arg.charAt(arg.length-1) == \"'\") {\n            return arg.substring(1,arg.length-1);\n          \n          // If number param convert\n          } else if (arg.charAt(0) != \"{\" ) {\n            return parseInt(arg);\n          } \n        })\n\n        var result = this.aceHandler.runFunction(this.editor.getValue(), functionName, functionArgs);\n        this.printOutput(result);\n      } \n      else {\n        this.printOutput(\"Error: Command Not Found. Type 'help' for a list of commands.\");\n      }\n\n      // Clear shellInput\n      this.shellInput = '';\n\n      // Scroll shell with data\n      document.getElementById('shell').scrollTop = document.getElementById('shell').scrollHeight;\n    },\n    printOutput(str) {\n      var par = document.createElement('p')\n      par.appendChild(document.createTextNode(str));\n      par.className = 'output';\n      document.getElementsByClassName('shell-content')[0].appendChild(par); \n    }\n  }\n}\n</script>\n\n<style>\nhtml,body {\n  margin: 0;\n  padding: 0;\n}\n\n#app {\n  display: flex;\n  width: 100vw;\n  height: 100vh;\n}\n\n#editor {\n  width: 60%;\n  height: 100%;\n  font-size: 25px;\n}\n\n#shell {\n  font-family: 'sans-serif';\n  background: rgb(50,50,50);\n  color: white;\n  padding: 25px;\n  height: calc(100% - 50px);\n  width: calc(60% - 50px);\n  overflow-y: auto;\n}\n\n.shell-content {\n\n}\n\n.input-line {\n\n}\n\nform {\n  display:inline;\n\n}\n\ninput {\n  background: rgba(0,0,0,0);\n  border: 0;\n  color: white;\n  margin: 0;\n  width: 80%;\n  padding: 5px;\n}\n\n.output {\n  padding-left: 10px;\n  color: rgb(200,200,200);\n  margin: 5px;\n}\n\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/App.vue","module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-define.js\n// module id = 3\n// module chunks = 0","import Vue from 'vue'\nimport App from './App.vue'\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (process.env.NODE_ENV !== 'production' && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false)\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (process.env.NODE_ENV !== 'production') {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        process.env.NODE_ENV !== 'test'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (process.env.NODE_ENV !== 'production') {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (process.env.NODE_ENV !== 'production') {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          process.env.NODE_ENV !== 'production' &&\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\nexport default Vue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue/dist/vue.esm.js\n// module id = 5\n// module chunks = 0","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/timers-browserify/main.js\n// module id = 6\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/setimmediate/setImmediate.js\n// module id = 7\n// module chunks = 0","function injectStyle (ssrContext) {\n  require(\"!!vue-style-loader!css-loader?minimize!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-13a01a4a\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./App.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-13a01a4a\\\",\\\"hasScoped\\\":false,\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./App.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.vue\n// module id = 8\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?minimize!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-13a01a4a\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"0b5cd5a4\", content, true, {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader!./node_modules/css-loader?minimize!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-13a01a4a\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/App.vue\n// module id = 9\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"body,html{margin:0;padding:0}#app{display:flex;width:100vw;height:100vh}#editor{width:60%;height:100%;font-size:25px}#shell{font-family:\\\"sans-serif\\\";background:#323232;color:#fff;padding:25px;height:calc(100% - 50px);width:calc(60% - 50px);overflow-y:auto}form{display:inline}input{background:transparent;border:0;color:#fff;margin:0;width:80%;padding:5px}.output{padding-left:10px;color:#c8c8c8;margin:5px}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?minimize!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-13a01a4a\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/App.vue\n// module id = 10\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 11\n// module chunks = 0","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader/lib/addStylesClient.js\n// module id = 12\n// module chunks = 0","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader/lib/listToStyles.js\n// module id = 13\n// module chunks = 0","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/component-normalizer.js\n// module id = 14\n// module chunks = 0","/* ***** BEGIN LICENSE BLOCK *****\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**\n * Define a module along with a payload\n * @param module a name for the payload\n * @param payload a function to call with (require, exports, module) params\n */\n\n(function() {\n\nvar ACE_NAMESPACE = \"ace\";\n\nvar global = (function() { return this; })();\nif (!global && typeof window != \"undefined\") global = window; // strict mode\n\n\nif (!ACE_NAMESPACE && typeof requirejs !== \"undefined\")\n    return;\n\n\nvar define = function(module, deps, payload) {\n    if (typeof module !== \"string\") {\n        if (define.original)\n            define.original.apply(this, arguments);\n        else {\n            console.error(\"dropping module because define wasn\\'t a string.\");\n            console.trace();\n        }\n        return;\n    }\n    if (arguments.length == 2)\n        payload = deps;\n    if (!define.modules[module]) {\n        define.payloads[module] = payload;\n        define.modules[module] = null;\n    }\n};\n\ndefine.modules = {};\ndefine.payloads = {};\n\n/**\n * Get at functionality define()ed using the function above\n */\nvar _require = function(parentId, module, callback) {\n    if (typeof module === \"string\") {\n        var payload = lookup(parentId, module);\n        if (payload != undefined) {\n            callback && callback();\n            return payload;\n        }\n    } else if (Object.prototype.toString.call(module) === \"[object Array]\") {\n        var params = [];\n        for (var i = 0, l = module.length; i < l; ++i) {\n            var dep = lookup(parentId, module[i]);\n            if (dep == undefined && require.original)\n                return;\n            params.push(dep);\n        }\n        return callback && callback.apply(null, params) || true;\n    }\n};\n\nvar require = function(module, callback) {\n    var packagedModule = _require(\"\", module, callback);\n    if (packagedModule == undefined && require.original)\n        return require.original.apply(this, arguments);\n    return packagedModule;\n};\n\nvar normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = base + \"/\" + moduleName;\n\n        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    return moduleName;\n};\n\n/**\n * Internal function to lookup moduleNames and resolve them by calling the\n * definition function if needed.\n */\nvar lookup = function(parentId, moduleName) {\n    moduleName = normalizeModule(parentId, moduleName);\n\n    var module = define.modules[moduleName];\n    if (!module) {\n        module = define.payloads[moduleName];\n        if (typeof module === 'function') {\n            var exports = {};\n            var mod = {\n                id: moduleName,\n                uri: '',\n                exports: exports,\n                packaged: true\n            };\n\n            var req = function(module, callback) {\n                return _require(moduleName, module, callback);\n            };\n\n            var returnValue = module(req, exports, mod);\n            exports = returnValue || mod.exports;\n            define.modules[moduleName] = exports;\n            delete define.payloads[moduleName];\n        }\n        module = define.modules[moduleName] = exports || module;\n    }\n    return module;\n};\n\nfunction exportAce(ns) {\n    var root = global;\n    if (ns) {\n        if (!global[ns])\n            global[ns] = {};\n        root = global[ns];\n    }\n\n    if (!root.define || !root.define.packaged) {\n        define.original = root.define;\n        root.define = define;\n        root.define.packaged = true;\n    }\n\n    if (!root.require || !root.require.packaged) {\n        require.original = root.require;\n        root.require = require;\n        root.require.packaged = true;\n    }\n}\n\nexportAce(ACE_NAMESPACE);\n\n})();\n\nace.define(\"ace/lib/regexp\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\n    var real = {\n            exec: RegExp.prototype.exec,\n            test: RegExp.prototype.test,\n            match: String.prototype.match,\n            replace: String.prototype.replace,\n            split: String.prototype.split\n        },\n        compliantExecNpcg = real.exec.call(/()??/, \"\")[1] === undefined, // check `exec` handling of nonparticipating capturing groups\n        compliantLastIndexIncrement = function () {\n            var x = /^/g;\n            real.test.call(x, \"\");\n            return !x.lastIndex;\n        }();\n\n    if (compliantLastIndexIncrement && compliantExecNpcg)\n        return;\n    RegExp.prototype.exec = function (str) {\n        var match = real.exec.apply(this, arguments),\n            name, r2;\n        if ( typeof(str) == 'string' && match) {\n            if (!compliantExecNpcg && match.length > 1 && indexOf(match, \"\") > -1) {\n                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), \"g\", \"\"));\n                real.replace.call(str.slice(match.index), r2, function () {\n                    for (var i = 1; i < arguments.length - 2; i++) {\n                        if (arguments[i] === undefined)\n                            match[i] = undefined;\n                    }\n                });\n            }\n            if (this._xregexp && this._xregexp.captureNames) {\n                for (var i = 1; i < match.length; i++) {\n                    name = this._xregexp.captureNames[i - 1];\n                    if (name)\n                       match[name] = match[i];\n                }\n            }\n            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n        }\n        return match;\n    };\n    if (!compliantLastIndexIncrement) {\n        RegExp.prototype.test = function (str) {\n            var match = real.exec.call(this, str);\n            if (match && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n            return !!match;\n        };\n    }\n\n    function getNativeFlags (regex) {\n        return (regex.global     ? \"g\" : \"\") +\n               (regex.ignoreCase ? \"i\" : \"\") +\n               (regex.multiline  ? \"m\" : \"\") +\n               (regex.extended   ? \"x\" : \"\") + // Proposed for ES4; included in AS3\n               (regex.sticky     ? \"y\" : \"\");\n    }\n\n    function indexOf (array, item, from) {\n        if (Array.prototype.indexOf) // Use the native array method if available\n            return array.indexOf(item, from);\n        for (var i = from || 0; i < array.length; i++) {\n            if (array[i] === item)\n                return i;\n        }\n        return -1;\n    }\n\n});\n\nace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\nfunction Empty() {}\n\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function bind(that) { // .length is 1\n        var target = this;\n        if (typeof target != \"function\") {\n            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n        }\n        var args = slice.call(arguments, 1); // for normal call\n        var bound = function () {\n\n            if (this instanceof bound) {\n\n                var result = target.apply(\n                    this,\n                    args.concat(slice.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return this;\n\n            } else {\n                return target.apply(\n                    that,\n                    args.concat(slice.call(arguments))\n                );\n\n            }\n\n        };\n        if(target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            Empty.prototype = null;\n        }\n        return bound;\n    };\n}\nvar call = Function.prototype.call;\nvar prototypeOfArray = Array.prototype;\nvar prototypeOfObject = Object.prototype;\nvar slice = prototypeOfArray.slice;\nvar _toString = call.bind(prototypeOfObject.toString);\nvar owns = call.bind(prototypeOfObject.hasOwnProperty);\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors;\nif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n}\nif ([1,2].splice(0).length != 2) {\n    if(function() { // test IE < 9 to splice bug - see issue #138\n        function makeArray(l) {\n            var a = new Array(l+2);\n            a[0] = a[1] = 0;\n            return a;\n        }\n        var array = [], lengthBefore;\n        \n        array.splice.apply(array, makeArray(20));\n        array.splice.apply(array, makeArray(26));\n\n        lengthBefore = array.length; //46\n        array.splice(5, 0, \"XXX\"); // add one element\n\n        lengthBefore + 1 == array.length\n\n        if (lengthBefore + 1 == array.length) {\n            return true;// has right splice implementation without bugs\n        }\n    }()) {//IE 6/7\n        var array_splice = Array.prototype.splice;\n        Array.prototype.splice = function(start, deleteCount) {\n            if (!arguments.length) {\n                return [];\n            } else {\n                return array_splice.apply(this, [\n                    start === void 0 ? 0 : start,\n                    deleteCount === void 0 ? (this.length - start) : deleteCount\n                ].concat(slice.call(arguments, 2)))\n            }\n        };\n    } else {//IE8\n        Array.prototype.splice = function(pos, removeCount){\n            var length = this.length;\n            if (pos > 0) {\n                if (pos > length)\n                    pos = length;\n            } else if (pos == void 0) {\n                pos = 0;\n            } else if (pos < 0) {\n                pos = Math.max(length + pos, 0);\n            }\n\n            if (!(pos+removeCount < length))\n                removeCount = length - pos;\n\n            var removed = this.slice(pos, pos+removeCount);\n            var insert = slice.call(arguments, 2);\n            var add = insert.length;            \n            if (pos === length) {\n                if (add) {\n                    this.push.apply(this, insert);\n                }\n            } else {\n                var remove = Math.min(removeCount, length - pos);\n                var tailOldPos = pos + remove;\n                var tailNewPos = tailOldPos + add - remove;\n                var tailCount = length - tailOldPos;\n                var lengthAfterRemove = length - remove;\n\n                if (tailNewPos < tailOldPos) { // case A\n                    for (var i = 0; i < tailCount; ++i) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } else if (tailNewPos > tailOldPos) { // case B\n                    for (i = tailCount; i--; ) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } // else, add == remove (nothing to do)\n\n                if (add && pos === lengthAfterRemove) {\n                    this.length = lengthAfterRemove; // truncate array\n                    this.push.apply(this, insert);\n                } else {\n                    this.length = lengthAfterRemove + add; // reserves space\n                    for (i = 0; i < add; ++i) {\n                        this[pos+i] = insert[i];\n                    }\n                }\n            }\n            return removed;\n        };\n    }\n}\nif (!Array.isArray) {\n    Array.isArray = function isArray(obj) {\n        return _toString(obj) == \"[object Array]\";\n    };\n}\nvar boxedString = Object(\"a\"),\n    splitString = boxedString[0] != \"a\" || !(0 in boxedString);\n\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                fun.call(thisp, self[i], i, object);\n            }\n        }\n    };\n}\nif (!Array.prototype.map) {\n    Array.prototype.map = function map(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self)\n                result[i] = fun.call(thisp, self[i], i, object);\n        }\n        return result;\n    };\n}\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function filter(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                    object,\n            length = self.length >>> 0,\n            result = [],\n            value,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                value = self[i];\n                if (fun.call(thisp, value, i, object)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    };\n}\nif (!Array.prototype.every) {\n    Array.prototype.every = function every(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && !fun.call(thisp, self[i], i, object)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nif (!Array.prototype.some) {\n    Array.prototype.some = function some(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && fun.call(thisp, self[i], i, object)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nif (!Array.prototype.reduce) {\n    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduce of empty array with no initial value\");\n        }\n\n        var i = 0;\n        var result;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i++];\n                    break;\n                }\n                if (++i >= length) {\n                    throw new TypeError(\"reduce of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        for (; i < length; i++) {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        }\n\n        return result;\n    };\n}\nif (!Array.prototype.reduceRight) {\n    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduceRight of empty array with no initial value\");\n        }\n\n        var result, i = length - 1;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i--];\n                    break;\n                }\n                if (--i < 0) {\n                    throw new TypeError(\"reduceRight of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        do {\n            if (i in this) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        } while (i--);\n\n        return result;\n    };\n}\nif (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {\n    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {\n    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n        var i = length - 1;\n        if (arguments.length > 1) {\n            i = Math.min(i, toInteger(arguments[1]));\n        }\n        i = i >= 0 ? i : length - Math.abs(i);\n        for (; i >= 0; i--) {\n            if (i in self && sought === self[i]) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function getPrototypeOf(object) {\n        return object.__proto__ || (\n            object.constructor ?\n            object.constructor.prototype :\n            prototypeOfObject\n        );\n    };\n}\nif (!Object.getOwnPropertyDescriptor) {\n    var ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a \" +\n                         \"non-object: \";\n    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT + object);\n        if (!owns(object, property))\n            return;\n\n        var descriptor, getter, setter;\n        descriptor =  { enumerable: true, configurable: true };\n        if (supportsAccessors) {\n            var prototype = object.__proto__;\n            object.__proto__ = prototypeOfObject;\n\n            var getter = lookupGetter(object, property);\n            var setter = lookupSetter(object, property);\n            object.__proto__ = prototype;\n\n            if (getter || setter) {\n                if (getter) descriptor.get = getter;\n                if (setter) descriptor.set = setter;\n                return descriptor;\n            }\n        }\n        descriptor.value = object[property];\n        return descriptor;\n    };\n}\nif (!Object.getOwnPropertyNames) {\n    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n        return Object.keys(object);\n    };\n}\nif (!Object.create) {\n    var createEmpty;\n    if (Object.prototype.__proto__ === null) {\n        createEmpty = function () {\n            return { \"__proto__\": null };\n        };\n    } else {\n        createEmpty = function () {\n            var empty = {};\n            for (var i in empty)\n                empty[i] = null;\n            empty.constructor =\n            empty.hasOwnProperty =\n            empty.propertyIsEnumerable =\n            empty.isPrototypeOf =\n            empty.toLocaleString =\n            empty.toString =\n            empty.valueOf =\n            empty.__proto__ = null;\n            return empty;\n        }\n    }\n\n    Object.create = function create(prototype, properties) {\n        var object;\n        if (prototype === null) {\n            object = createEmpty();\n        } else {\n            if (typeof prototype != \"object\")\n                throw new TypeError(\"typeof prototype[\"+(typeof prototype)+\"] != 'object'\");\n            var Type = function () {};\n            Type.prototype = prototype;\n            object = new Type();\n            object.__proto__ = prototype;\n        }\n        if (properties !== void 0)\n            Object.defineProperties(object, properties);\n        return object;\n    };\n}\n\nfunction doesDefinePropertyWork(object) {\n    try {\n        Object.defineProperty(object, \"sentinel\", {});\n        return \"sentinel\" in object;\n    } catch (exception) {\n    }\n}\nif (Object.defineProperty) {\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n    var definePropertyWorksOnDom = typeof document == \"undefined\" ||\n        doesDefinePropertyWork(document.createElement(\"div\"));\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n        var definePropertyFallback = Object.defineProperty;\n    }\n}\n\nif (!Object.defineProperty || definePropertyFallback) {\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \"\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined \" +\n                                      \"on this javascript engine\";\n\n    Object.defineProperty = function defineProperty(object, property, descriptor) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        if ((typeof descriptor != \"object\" && typeof descriptor != \"function\") || descriptor === null)\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        if (definePropertyFallback) {\n            try {\n                return definePropertyFallback.call(Object, object, property, descriptor);\n            } catch (exception) {\n            }\n        }\n        if (owns(descriptor, \"value\")) {\n\n            if (supportsAccessors && (lookupGetter(object, property) ||\n                                      lookupSetter(object, property)))\n            {\n                var prototype = object.__proto__;\n                object.__proto__ = prototypeOfObject;\n                delete object[property];\n                object[property] = descriptor.value;\n                object.__proto__ = prototype;\n            } else {\n                object[property] = descriptor.value;\n            }\n        } else {\n            if (!supportsAccessors)\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n            if (owns(descriptor, \"get\"))\n                defineGetter(object, property, descriptor.get);\n            if (owns(descriptor, \"set\"))\n                defineSetter(object, property, descriptor.set);\n        }\n\n        return object;\n    };\n}\nif (!Object.defineProperties) {\n    Object.defineProperties = function defineProperties(object, properties) {\n        for (var property in properties) {\n            if (owns(properties, property))\n                Object.defineProperty(object, property, properties[property]);\n        }\n        return object;\n    };\n}\nif (!Object.seal) {\n    Object.seal = function seal(object) {\n        return object;\n    };\n}\nif (!Object.freeze) {\n    Object.freeze = function freeze(object) {\n        return object;\n    };\n}\ntry {\n    Object.freeze(function () {});\n} catch (exception) {\n    Object.freeze = (function freeze(freezeObject) {\n        return function freeze(object) {\n            if (typeof object == \"function\") {\n                return object;\n            } else {\n                return freezeObject(object);\n            }\n        };\n    })(Object.freeze);\n}\nif (!Object.preventExtensions) {\n    Object.preventExtensions = function preventExtensions(object) {\n        return object;\n    };\n}\nif (!Object.isSealed) {\n    Object.isSealed = function isSealed(object) {\n        return false;\n    };\n}\nif (!Object.isFrozen) {\n    Object.isFrozen = function isFrozen(object) {\n        return false;\n    };\n}\nif (!Object.isExtensible) {\n    Object.isExtensible = function isExtensible(object) {\n        if (Object(object) === object) {\n            throw new TypeError(); // TODO message\n        }\n        var name = '';\n        while (owns(object, name)) {\n            name += '?';\n        }\n        object[name] = true;\n        var returnValue = owns(object, name);\n        delete object[name];\n        return returnValue;\n    };\n}\nif (!Object.keys) {\n    var hasDontEnumBug = true,\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    for (var key in {\"toString\": null}) {\n        hasDontEnumBug = false;\n    }\n\n    Object.keys = function keys(object) {\n\n        if (\n            (typeof object != \"object\" && typeof object != \"function\") ||\n            object === null\n        ) {\n            throw new TypeError(\"Object.keys called on a non-object\");\n        }\n\n        var keys = [];\n        for (var name in object) {\n            if (owns(object, name)) {\n                keys.push(name);\n            }\n        }\n\n        if (hasDontEnumBug) {\n            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n                var dontEnum = dontEnums[i];\n                if (owns(object, dontEnum)) {\n                    keys.push(dontEnum);\n                }\n            }\n        }\n        return keys;\n    };\n\n}\nif (!Date.now) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\nvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\" +\n    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n    \"\\u2029\\uFEFF\";\nif (!String.prototype.trim || ws.trim()) {\n    ws = \"[\" + ws + \"]\";\n    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n    String.prototype.trim = function trim() {\n        return String(this).replace(trimBeginRegexp, \"\").replace(trimEndRegexp, \"\");\n    };\n}\n\nfunction toInteger(n) {\n    n = +n;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n}\n\nfunction isPrimitive(input) {\n    var type = typeof input;\n    return (\n        input === null ||\n        type === \"undefined\" ||\n        type === \"boolean\" ||\n        type === \"number\" ||\n        type === \"string\"\n    );\n}\n\nfunction toPrimitive(input) {\n    var val, valueOf, toString;\n    if (isPrimitive(input)) {\n        return input;\n    }\n    valueOf = input.valueOf;\n    if (typeof valueOf === \"function\") {\n        val = valueOf.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    toString = input.toString;\n    if (typeof toString === \"function\") {\n        val = toString.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    throw new TypeError();\n}\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \"+o+\" to object\");\n    }\n    return Object(o);\n};\n\n});\n\nace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/regexp\",\"ace/lib/es5-shim\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./regexp\");\nrequire(\"./es5-shim\");\nif (typeof Element != \"undefined\" && !Element.prototype.remove) {\n    Object.defineProperty(Element.prototype, \"remove\", {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: function() { this.parentNode && this.parentNode.removeChild(this); }\n    });\n}\n\n\n});\n\nace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nexports.OS = {\n    LINUX: \"LINUX\",\n    MAC: \"MAC\",\n    WINDOWS: \"WINDOWS\"\n};\nexports.getOS = function() {\n    if (exports.isMac) {\n        return exports.OS.MAC;\n    } else if (exports.isLinux) {\n        return exports.OS.LINUX;\n    } else {\n        return exports.OS.WINDOWS;\n    }\n};\nif (typeof navigator != \"object\")\n    return;\n\nvar os = (navigator.platform.match(/mac|win|linux/i) || [\"other\"])[0].toLowerCase();\nvar ua = navigator.userAgent;\nexports.isWin = (os == \"win\");\nexports.isMac = (os == \"mac\");\nexports.isLinux = (os == \"linux\");\nexports.isIE = \n    (navigator.appName == \"Microsoft Internet Explorer\" || navigator.appName.indexOf(\"MSAppHost\") >= 0)\n    ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1])\n    : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1]); // for ie\n    \nexports.isOldIE = exports.isIE && exports.isIE < 9;\nexports.isGecko = exports.isMozilla = ua.match(/ Gecko\\/\\d+/);\nexports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == \"[object Opera]\";\nexports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\n\nexports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\n\nexports.isEdge = parseFloat(ua.split(\" Edge/\")[1]) || undefined;\n\nexports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\n\nexports.isIPad = ua.indexOf(\"iPad\") >= 0;\n\nexports.isAndroid = ua.indexOf(\"Android\") >= 0;\n\nexports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\n\nexports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;\n\nif (exports.isIOS) exports.isMac = true;\n\nexports.isMobile = exports.isIPad || exports.isAndroid;\n\n});\n\nace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"./useragent\"); \nvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\nexports.buildDom = function buildDom(arr, parent, refs) {\n    if (typeof arr == \"string\" && arr) {\n        var txt = document.createTextNode(arr);\n        if (parent)\n            parent.appendChild(txt);\n        return txt;\n    }\n    \n    if (!Array.isArray(arr))\n        return arr;\n    if (typeof arr[0] != \"string\" || !arr[0]) {\n        var els = [];\n        for (var i = 0; i < arr.length; i++) {\n            var ch = buildDom(arr[i], parent, refs);\n            ch && els.push(ch);\n        }\n        return els;\n    }\n    \n    var el = document.createElement(arr[0]);\n    var options = arr[1];\n    var childIndex = 1;\n    if (options && typeof options == \"object\" && !Array.isArray(options))\n        childIndex = 2;\n    for (var i = childIndex; i < arr.length; i++)\n        buildDom(arr[i], el, refs);\n    if (childIndex == 2) {\n        Object.keys(options).forEach(function(n) {\n            var val = options[n];\n            if (n === \"class\") {\n                el.className = Array.isArray(val) ? val.join(\" \") : val;\n            } else if (typeof val == \"function\" || n == \"value\") {\n                el[n] = val;\n            } else if (n === \"ref\") {\n                if (refs) refs[val] = el;\n            } else if (val != null) {\n                el.setAttribute(n, val);\n            }\n        });\n    }\n    if (parent)\n        parent.appendChild(el);\n    return el;\n};\n\nexports.getDocumentHead = function(doc) {\n    if (!doc)\n        doc = document;\n    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n};\n\nexports.createElement = function(tag, ns) {\n    return document.createElementNS ?\n           document.createElementNS(ns || XHTML_NS, tag) :\n           document.createElement(tag);\n};\n\nexports.removeChildren = function(element) {\n    element.innerHTML = \"\";\n};\n\nexports.createTextNode = function(textContent, element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createTextNode(textContent);\n};\n\nexports.createFragment = function(element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createDocumentFragment();\n};\n\nexports.hasCssClass = function(el, name) {\n    var classes = (el.className + \"\").split(/\\s+/g);\n    return classes.indexOf(name) !== -1;\n};\nexports.addCssClass = function(el, name) {\n    if (!exports.hasCssClass(el, name)) {\n        el.className += \" \" + name;\n    }\n};\nexports.removeCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g);\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        classes.splice(index, 1);\n    }\n    el.className = classes.join(\" \");\n};\n\nexports.toggleCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g), add = true;\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        add = false;\n        classes.splice(index, 1);\n    }\n    if (add)\n        classes.push(name);\n\n    el.className = classes.join(\" \");\n    return add;\n};\nexports.setCssClass = function(node, className, include) {\n    if (include) {\n        exports.addCssClass(node, className);\n    } else {\n        exports.removeCssClass(node, className);\n    }\n};\n\nexports.hasCssString = function(id, doc) {\n    var index = 0, sheets;\n    doc = doc || document;\n    if ((sheets = doc.querySelectorAll(\"style\"))) {\n        while (index < sheets.length)\n            if (sheets[index++].id === id)\n                return true;\n    }\n};\n\nexports.importCssString = function importCssString(cssText, id, target) {\n    var container = target;\n    if (!target || !target.getRootNode) {\n        container = document;\n    } else {\n        container = target.getRootNode();\n        if (!container || container == target)\n            container = document;\n    }\n    \n    var doc = container.ownerDocument || container;\n    if (id && exports.hasCssString(id, container))\n        return null;\n    \n    if (id)\n        cssText += \"\\n/*# sourceURL=ace/css/\" + id + \" */\";\n    \n    var style = exports.createElement(\"style\");\n    style.appendChild(doc.createTextNode(cssText));\n    if (id)\n        style.id = id;\n\n    if (container == doc)\n        container = exports.getDocumentHead(doc);\n    container.insertBefore(style, container.firstChild);\n};\n\nexports.importCssStylsheet = function(uri, doc) {\n    exports.buildDom([\"link\", {rel: \"stylesheet\", href: uri}], exports.getDocumentHead(doc));\n};\nexports.scrollbarWidth = function(document) {\n    var inner = exports.createElement(\"ace_inner\");\n    inner.style.width = \"100%\";\n    inner.style.minWidth = \"0px\";\n    inner.style.height = \"200px\";\n    inner.style.display = \"block\";\n\n    var outer = exports.createElement(\"ace_outer\");\n    var style = outer.style;\n\n    style.position = \"absolute\";\n    style.left = \"-10000px\";\n    style.overflow = \"hidden\";\n    style.width = \"200px\";\n    style.minWidth = \"0px\";\n    style.height = \"150px\";\n    style.display = \"block\";\n\n    outer.appendChild(inner);\n\n    var body = document.documentElement;\n    body.appendChild(outer);\n\n    var noScrollbar = inner.offsetWidth;\n\n    style.overflow = \"scroll\";\n    var withScrollbar = inner.offsetWidth;\n\n    if (noScrollbar == withScrollbar) {\n        withScrollbar = outer.clientWidth;\n    }\n\n    body.removeChild(outer);\n\n    return noScrollbar-withScrollbar;\n};\n\nif (typeof document == \"undefined\") {\n    exports.importCssString = function() {};\n}\n\nexports.computedStyle = function(element, style) {\n    return window.getComputedStyle(element, \"\") || {};\n};\n\nexports.setStyle = function(styles, property, value) {\n    if (styles[property] !== value) {\n        styles[property] = value;\n    }\n};\n\nexports.HAS_CSS_ANIMATION = false;\nexports.HAS_CSS_TRANSFORMS = false;\nexports.HI_DPI = useragent.isWin\n    ? typeof window !== \"undefined\" && window.devicePixelRatio >= 1.5\n    : true;\n\nif (typeof document !== \"undefined\") {\n    var div = document.createElement(\"div\");\n    if (exports.HI_DPI && div.style.transform  !== undefined)\n        exports.HAS_CSS_TRANSFORMS = true;\n    if (!useragent.isEdge && typeof div.style.animationName !== \"undefined\")\n        exports.HAS_CSS_ANIMATION = true;\n    div = null;\n}\n\nif (exports.HAS_CSS_TRANSFORMS) {\n    exports.translate = function(element, tx, ty) {\n        element.style.transform = \"translate(\" + Math.round(tx) + \"px, \" + Math.round(ty) +\"px)\";\n    };\n} else {\n    exports.translate = function(element, tx, ty) {\n        element.style.top = Math.round(ty) + \"px\";\n        element.style.left = Math.round(tx) + \"px\";\n    };\n}\n\n});\n\nace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.inherits = function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\n\nexports.mixin = function(obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\n\nexports.implement = function(proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./oop\");\nvar Keys = (function() {\n    var ret = {\n        MODIFIER_KEYS: {\n            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'\n        },\n\n        KEY_MODS: {\n            \"ctrl\": 1, \"alt\": 2, \"option\" : 2, \"shift\": 4,\n            \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8\n        },\n\n        FUNCTION_KEYS : {\n            8  : \"Backspace\",\n            9  : \"Tab\",\n            13 : \"Return\",\n            19 : \"Pause\",\n            27 : \"Esc\",\n            32 : \"Space\",\n            33 : \"PageUp\",\n            34 : \"PageDown\",\n            35 : \"End\",\n            36 : \"Home\",\n            37 : \"Left\",\n            38 : \"Up\",\n            39 : \"Right\",\n            40 : \"Down\",\n            44 : \"Print\",\n            45 : \"Insert\",\n            46 : \"Delete\",\n            96 : \"Numpad0\",\n            97 : \"Numpad1\",\n            98 : \"Numpad2\",\n            99 : \"Numpad3\",\n            100: \"Numpad4\",\n            101: \"Numpad5\",\n            102: \"Numpad6\",\n            103: \"Numpad7\",\n            104: \"Numpad8\",\n            105: \"Numpad9\",\n            '-13': \"NumpadEnter\",\n            112: \"F1\",\n            113: \"F2\",\n            114: \"F3\",\n            115: \"F4\",\n            116: \"F5\",\n            117: \"F6\",\n            118: \"F7\",\n            119: \"F8\",\n            120: \"F9\",\n            121: \"F10\",\n            122: \"F11\",\n            123: \"F12\",\n            144: \"Numlock\",\n            145: \"Scrolllock\"\n        },\n\n        PRINTABLE_KEYS: {\n           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',\n           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',\n           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',\n           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',\n           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',\n           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',\n          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',\n          219: '[', 220: '\\\\',221: ']', 222: \"'\", 111: '/', 106: '*'\n        }\n    };\n    var name, i;\n    for (i in ret.FUNCTION_KEYS) {\n        name = ret.FUNCTION_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    for (i in ret.PRINTABLE_KEYS) {\n        name = ret.PRINTABLE_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    oop.mixin(ret, ret.MODIFIER_KEYS);\n    oop.mixin(ret, ret.PRINTABLE_KEYS);\n    oop.mixin(ret, ret.FUNCTION_KEYS);\n    ret.enter = ret[\"return\"];\n    ret.escape = ret.esc;\n    ret.del = ret[\"delete\"];\n    ret[173] = '-';\n    \n    (function() {\n        var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n        for (var i = Math.pow(2, mods.length); i--;) {            \n            ret.KEY_MODS[i] = mods.filter(function(x) {\n                return i & ret.KEY_MODS[x];\n            }).join(\"-\") + \"-\";\n        }\n    })();\n\n    ret.KEY_MODS[0] = \"\";\n    ret.KEY_MODS[-1] = \"input-\";\n\n    return ret;\n})();\noop.mixin(exports, Keys);\n\nexports.keyCodeToString = function(keyCode) {\n    var keyString = Keys[keyCode];\n    if (typeof keyString != \"string\")\n        keyString = String.fromCharCode(keyCode);\n    return keyString.toLowerCase();\n};\n\n});\n\nace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keys = require(\"./keys\");\nvar useragent = require(\"./useragent\");\n\nvar pressedKeys = null;\nvar ts = 0;\n\nexports.addListener = function(elem, type, callback) {\n    if (elem.addEventListener) {\n        return elem.addEventListener(type, callback, false);\n    }\n    if (elem.attachEvent) {\n        var wrapper = function() {\n            callback.call(elem, window.event);\n        };\n        callback._wrapper = wrapper;\n        elem.attachEvent(\"on\" + type, wrapper);\n    }\n};\n\nexports.removeListener = function(elem, type, callback) {\n    if (elem.removeEventListener) {\n        return elem.removeEventListener(type, callback, false);\n    }\n    if (elem.detachEvent) {\n        elem.detachEvent(\"on\" + type, callback._wrapper || callback);\n    }\n};\nexports.stopEvent = function(e) {\n    exports.stopPropagation(e);\n    exports.preventDefault(e);\n    return false;\n};\n\nexports.stopPropagation = function(e) {\n    if (e.stopPropagation)\n        e.stopPropagation();\n    else\n        e.cancelBubble = true;\n};\n\nexports.preventDefault = function(e) {\n    if (e.preventDefault)\n        e.preventDefault();\n    else\n        e.returnValue = false;\n};\nexports.getButton = function(e) {\n    if (e.type == \"dblclick\")\n        return 0;\n    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n        return 2;\n    if (e.preventDefault) {\n        return e.button;\n    }\n    else {\n        return {1:0, 2:2, 4:1}[e.button];\n    }\n};\n\nexports.capture = function(el, eventHandler, releaseCaptureHandler) {\n    function onMouseUp(e) {\n        eventHandler && eventHandler(e);\n        releaseCaptureHandler && releaseCaptureHandler(e);\n\n        exports.removeListener(document, \"mousemove\", eventHandler, true);\n        exports.removeListener(document, \"mouseup\", onMouseUp, true);\n        exports.removeListener(document, \"dragstart\", onMouseUp, true);\n    }\n\n    exports.addListener(document, \"mousemove\", eventHandler, true);\n    exports.addListener(document, \"mouseup\", onMouseUp, true);\n    exports.addListener(document, \"dragstart\", onMouseUp, true);\n    \n    return onMouseUp;\n};\n\nexports.addTouchMoveListener = function (el, callback) {\n    var startx, starty;\n    exports.addListener(el, \"touchstart\", function (e) {\n        var touches = e.touches;\n        var touchObj = touches[0];\n        startx = touchObj.clientX;\n        starty = touchObj.clientY;\n    });\n    exports.addListener(el, \"touchmove\", function (e) {\n        var touches = e.touches;\n        if (touches.length > 1) return;\n        \n        var touchObj = touches[0];\n\n        e.wheelX = startx - touchObj.clientX;\n        e.wheelY = starty - touchObj.clientY;\n\n        startx = touchObj.clientX;\n        starty = touchObj.clientY;\n\n        callback(e);\n    });\n};\n\nexports.addMouseWheelListener = function(el, callback) {\n    if (\"onmousewheel\" in el) {\n        exports.addListener(el, \"mousewheel\", function(e) {\n            var factor = 8;\n            if (e.wheelDeltaX !== undefined) {\n                e.wheelX = -e.wheelDeltaX / factor;\n                e.wheelY = -e.wheelDeltaY / factor;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = -e.wheelDelta / factor;\n            }\n            callback(e);\n        });\n    } else if (\"onwheel\" in el) {\n        exports.addListener(el, \"wheel\",  function(e) {\n            var factor = 0.35;\n            switch (e.deltaMode) {\n                case e.DOM_DELTA_PIXEL:\n                    e.wheelX = e.deltaX * factor || 0;\n                    e.wheelY = e.deltaY * factor || 0;\n                    break;\n                case e.DOM_DELTA_LINE:\n                case e.DOM_DELTA_PAGE:\n                    e.wheelX = (e.deltaX || 0) * 5;\n                    e.wheelY = (e.deltaY || 0) * 5;\n                    break;\n            }\n            \n            callback(e);\n        });\n    } else {\n        exports.addListener(el, \"DOMMouseScroll\", function(e) {\n            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {\n                e.wheelX = (e.detail || 0) * 5;\n                e.wheelY = 0;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = (e.detail || 0) * 5;\n            }\n            callback(e);\n        });\n    }\n};\n\nexports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {\n    var clicks = 0;\n    var startX, startY, timer; \n    var eventNames = {\n        2: \"dblclick\",\n        3: \"tripleclick\",\n        4: \"quadclick\"\n    };\n\n    function onMousedown(e) {\n        if (exports.getButton(e) !== 0) {\n            clicks = 0;\n        } else if (e.detail > 1) {\n            clicks++;\n            if (clicks > 4)\n                clicks = 1;\n        } else {\n            clicks = 1;\n        }\n        if (useragent.isIE) {\n            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n            if (!timer || isNewClick)\n                clicks = 1;\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);\n\n            if (clicks == 1) {\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        }\n        \n        e._clicks = clicks;\n\n        eventHandler[callbackName](\"mousedown\", e);\n\n        if (clicks > 4)\n            clicks = 0;\n        else if (clicks > 1)\n            return eventHandler[callbackName](eventNames[clicks], e);\n    }\n    function onDblclick(e) {\n        clicks = 2;\n        if (timer)\n            clearTimeout(timer);\n        timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);\n        eventHandler[callbackName](\"mousedown\", e);\n        eventHandler[callbackName](eventNames[clicks], e);\n    }\n    if (!Array.isArray(elements))\n        elements = [elements];\n    elements.forEach(function(el) {\n        exports.addListener(el, \"mousedown\", onMousedown);\n        if (useragent.isOldIE)\n            exports.addListener(el, \"dblclick\", onDblclick);\n    });\n};\n\nvar getModifierHash = useragent.isMac && useragent.isOpera && !(\"KeyboardEvent\" in window)\n    ? function(e) {\n        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);\n    }\n    : function(e) {\n        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n    };\n\nexports.getModifierString = function(e) {\n    return keys.KEY_MODS[getModifierHash(e)];\n};\n\nfunction normalizeCommandKeys(callback, e, keyCode) {\n    var hashId = getModifierHash(e);\n\n    if (!useragent.isMac && pressedKeys) {\n        if (e.getModifierState && (e.getModifierState(\"OS\") || e.getModifierState(\"Win\")))\n            hashId |= 8;\n        if (pressedKeys.altGr) {\n            if ((3 & hashId) != 3)\n                pressedKeys.altGr = 0;\n            else\n                return;\n        }\n        if (keyCode === 18 || keyCode === 17) {\n            var location = \"location\" in e ? e.location : e.keyLocation;\n            if (keyCode === 17 && location === 1) {\n                if (pressedKeys[keyCode] == 1)\n                    ts = e.timeStamp;\n            } else if (keyCode === 18 && hashId === 3 && location === 2) {\n                var dt = e.timeStamp - ts;\n                if (dt < 50)\n                    pressedKeys.altGr = true;\n            }\n        }\n    }\n    \n    if (keyCode in keys.MODIFIER_KEYS) {\n        keyCode = -1;\n    }\n    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {\n        keyCode = -1;\n    }\n    \n    if (!hashId && keyCode === 13) {\n        var location = \"location\" in e ? e.location : e.keyLocation;\n        if (location === 3) {\n            callback(e, hashId, -keyCode);\n            if (e.defaultPrevented)\n                return;\n        }\n    }\n    \n    if (useragent.isChromeOS && hashId & 8) {\n        callback(e, hashId, keyCode);\n        if (e.defaultPrevented)\n            return;\n        else\n            hashId &= ~8;\n    }\n    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n        return false;\n    }\n    \n    return callback(e, hashId, keyCode);\n}\n\n\nexports.addCommandKeyListener = function(el, callback) {\n    var addListener = exports.addListener;\n    if (useragent.isOldGecko || (useragent.isOpera && !(\"KeyboardEvent\" in window))) {\n        var lastKeyDownKeyCode = null;\n        addListener(el, \"keydown\", function(e) {\n            lastKeyDownKeyCode = e.keyCode;\n        });\n        addListener(el, \"keypress\", function(e) {\n            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);\n        });\n    } else {\n        var lastDefaultPrevented = null;\n\n        addListener(el, \"keydown\", function(e) {\n            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;\n            var result = normalizeCommandKeys(callback, e, e.keyCode);\n            lastDefaultPrevented = e.defaultPrevented;\n            return result;\n        });\n\n        addListener(el, \"keypress\", function(e) {\n            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n                exports.stopEvent(e);\n                lastDefaultPrevented = null;\n            }\n        });\n\n        addListener(el, \"keyup\", function(e) {\n            pressedKeys[e.keyCode] = null;\n        });\n\n        if (!pressedKeys) {\n            resetPressedKeys();\n            addListener(window, \"focus\", resetPressedKeys);\n        }\n    }\n};\nfunction resetPressedKeys() {\n    pressedKeys = Object.create(null);\n}\n\nif (typeof window == \"object\" && window.postMessage && !useragent.isOldIE) {\n    var postMessageId = 1;\n    exports.nextTick = function(callback, win) {\n        win = win || window;\n        var messageName = \"zero-timeout-message-\" + (postMessageId++);\n        \n        var listener = function(e) {\n            if (e.data == messageName) {\n                exports.stopPropagation(e);\n                exports.removeListener(win, \"message\", listener);\n                callback();\n            }\n        };\n        \n        exports.addListener(win, \"message\", listener);\n        win.postMessage(messageName, \"*\");\n    };\n}\n\nexports.$idleBlocked = false;\nexports.onIdle = function(cb, timeout) {\n    return setTimeout(function handler() {\n        if (!exports.$idleBlocked) {\n            cb();\n        } else {\n            setTimeout(handler, 100);\n        }\n    }, timeout);\n};\n\nexports.$idleBlockId = null;\nexports.blockIdle = function(delay) {\n    if (exports.$idleBlockId)\n        clearTimeout(exports.$idleBlockId);\n        \n    exports.$idleBlocked = true;\n    exports.$idleBlockId = setTimeout(function() {\n        exports.$idleBlocked = false;\n    }, delay || 100);\n};\n\nexports.nextFrame = typeof window == \"object\" && (window.requestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || window.oRequestAnimationFrame);\n\nif (exports.nextFrame)\n    exports.nextFrame = exports.nextFrame.bind(window);\nelse\n    exports.nextFrame = function(callback) {\n        setTimeout(callback, 17);\n    };\n});\n\nace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nvar Range = function(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n        row: startRow,\n        column: startColumn\n    };\n\n    this.end = {\n        row: endRow,\n        column: endColumn\n    };\n};\n\n(function() {\n    this.isEqual = function(range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    this.toString = function() {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n\n    this.contains = function(row, column) {\n        return this.compare(row, column) == 0;\n    };\n    this.compareRange = function(range) {\n        var cmp,\n            end = range.end,\n            start = range.start;\n\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            } else if (cmp == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (cmp == -1) {\n            return -2;\n        } else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            } else if (cmp == 1) {\n                return 42;\n            } else {\n                return 0;\n            }\n        }\n    };\n    this.comparePoint = function(p) {\n        return this.compare(p.row, p.column);\n    };\n    this.containsRange = function(range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function(range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    this.isEnd = function(row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function(row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function(row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        } else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    this.setEnd = function(row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        } else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    this.inside = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideStart = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideEnd = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.compare = function(row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n\n        if (row < this.start.row)\n            return -1;\n\n        if (row > this.end.row)\n            return 1;\n\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n\n        return 0;\n    };\n    this.compareStart = function(row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareEnd = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareInside = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.clipRows = function(firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = {row: lastRow + 1, column: 0};\n        else if (this.end.row < firstRow)\n            var end = {row: firstRow, column: 0};\n\n        if (this.start.row > lastRow)\n            var start = {row: lastRow + 1, column: 0};\n        else if (this.start.row < firstRow)\n            var start = {row: firstRow, column: 0};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function(row, column) {\n        var cmp = this.compare(row, column);\n\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = {row: row, column: column};\n        else\n            var end = {row: row, column: column};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n\n    this.isEmpty = function() {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    this.isMultiLine = function() {\n        return (this.start.row !== this.end.row);\n    };\n    this.clone = function() {\n        return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function() {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function(session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n\n        return new Range(\n            screenPosStart.row, screenPosStart.column,\n            screenPosEnd.row, screenPosEnd.column\n        );\n    };\n    this.moveBy = function(row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n\n}).call(Range.prototype);\nRange.fromPoints = function(start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = comparePoints;\n\nRange.comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\n\n\nexports.Range = Range;\n});\n\nace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.last = function(a) {\n    return a[a.length - 1];\n};\n\nexports.stringReverse = function(string) {\n    return string.split(\"\").reverse().join(\"\");\n};\n\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\n\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\n\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\n\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\n\nexports.copyObject = function(obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\n\nexports.copyArray = function(array){\n    var copy = [];\n    for (var i=0, l=array.length; i<l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else \n            copy[i] = array[i];\n    }\n    return copy;\n};\n\nexports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    \n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\n\nexports.arrayToMap = function(arr) {\n    var map = {};\n    for (var i=0; i<arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n\n};\n\nexports.createMap = function(props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function(array, value) {\n  for (var i = 0; i <= array.length; i++) {\n    if (value === array[i]) {\n      array.splice(i, 1);\n    }\n  }\n};\n\nexports.escapeRegExp = function(str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\n\nexports.escapeHTML = function(str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\n\nexports.getMatchOffsets = function(string, regExp) {\n    var matches = [];\n\n    string.replace(regExp, function(str) {\n        matches.push({\n            offset: arguments[arguments.length-2],\n            length: str.length\n        });\n    });\n\n    return matches;\n};\nexports.deferredCall = function(fcn) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var deferred = function(timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n\n    deferred.schedule = deferred;\n\n    deferred.call = function() {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n\n    deferred.cancel = function() {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    \n    deferred.isPending = function() {\n        return timer;\n    };\n\n    return deferred;\n};\n\n\nexports.delayedCall = function(fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var _self = function(timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n\n    _self.delay = function(timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n\n    _self.call = function() {\n        this.cancel();\n        fcn();\n    };\n\n    _self.cancel = function() {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n\n    _self.isPending = function() {\n        return timer;\n    };\n\n    return _self;\n};\n});\n\nace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/keys\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar BROKEN_SETDATA = useragent.isChrome < 18;\nvar USE_IE_MIME_TYPE =  useragent.isIE;\nvar HAS_FOCUS_ARGS = useragent.isChrome > 63;\nvar MAX_LINE_LENGTH = 400;\n\nvar KEYS = require(\"../lib/keys\");\nvar MODS = KEYS.KEY_MODS;\nvar isIOS = useragent.isIOS;\nvar valueResetRegex = isIOS ? /\\s/ : /\\n/;\n\nvar TextInput = function(parentNode, host) {\n    var text = dom.createElement(\"textarea\");\n    text.className = \"ace_text-input\";\n\n    text.setAttribute(\"wrap\", \"off\");\n    text.setAttribute(\"autocorrect\", \"off\");\n    text.setAttribute(\"autocapitalize\", \"off\");\n    text.setAttribute(\"spellcheck\", false);\n\n    text.style.opacity = \"0\";\n    parentNode.insertBefore(text, parentNode.firstChild);\n\n    var copied = false;\n    var pasted = false;\n    var inComposition = false;\n    var sendingText = false;\n    var tempStyle = '';\n    var isSelectionEmpty = true;\n    var copyWithEmptySelection = false;\n    \n    if (!useragent.isMobile)\n        text.style.fontSize = \"1px\";\n\n    var commandMode = false;\n    var ignoreFocusEvents = false;\n    \n    var lastValue = \"\";\n    var lastSelectionStart = 0;\n    var lastSelectionEnd = 0;\n    try { var isFocused = document.activeElement === text; } catch(e) {}\n    \n    event.addListener(text, \"blur\", function(e) {\n        if (ignoreFocusEvents) return;\n        host.onBlur(e);\n        isFocused = false;\n    });\n    event.addListener(text, \"focus\", function(e) {\n        if (ignoreFocusEvents) return;\n        isFocused = true;\n        if (useragent.isEdge) {\n            try {\n                if (!document.hasFocus())\n                    return;\n            } catch(e) {}\n        }\n        host.onFocus(e);\n        if (useragent.isEdge)\n            setTimeout(resetSelection);\n        else\n            resetSelection();\n    });\n    this.$focusScroll = false;\n    this.focus = function() {\n        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == \"browser\")\n            return text.focus({ preventScroll: true });\n\n        var top = text.style.top;\n        text.style.position = \"fixed\";\n        text.style.top = \"0px\";\n        try {\n            var isTransformed = text.getBoundingClientRect().top != 0;\n        } catch(e) {\n            return;\n        }\n        var ancestors = [];\n        if (isTransformed) {\n            var t = text.parentElement;\n            while (t && t.nodeType == 1) {\n                ancestors.push(t);\n                t.setAttribute(\"ace_nocontext\", true);\n                if (!t.parentElement && t.getRootNode)\n                    t = t.getRootNode().host;\n                else\n                    t = t.parentElement;\n            }\n        }\n        text.focus({ preventScroll: true });\n        if (isTransformed) {\n            ancestors.forEach(function(p) {\n                p.removeAttribute(\"ace_nocontext\");\n            });\n        }\n        setTimeout(function() {\n            text.style.position = \"\";\n            if (text.style.top == \"0px\")\n                text.style.top = top;\n        }, 0);\n    };\n    this.blur = function() {\n        text.blur();\n    };\n    this.isFocused = function() {\n        return isFocused;\n    };\n    \n    host.on(\"beforeEndOperation\", function() {\n        if (host.curOp && host.curOp.command.name == \"insertstring\")\n            return;\n        if (inComposition) {\n            lastValue = text.value = \"\";\n            onCompositionEnd();\n        }\n        resetSelection();\n    });\n    \n    var resetSelection = isIOS\n    ? function(value) {\n        if (!isFocused || (copied && !value) || sendingText) return;\n        if (!value) \n            value = \"\";\n        var newValue = \"\\n ab\" + value + \"cde fg\\n\";\n        if (newValue != text.value)\n            text.value = lastValue = newValue;\n        \n        var selectionStart = 4;\n        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));\n\n        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {\n            text.setSelectionRange(selectionStart, selectionEnd);\n        }\n        lastSelectionStart = selectionStart;\n        lastSelectionEnd = selectionEnd;\n    }\n    : function() {\n        if (inComposition || sendingText)\n            return;\n        if (!isFocused && !afterContextMenu)\n            return;\n        inComposition = true;\n        \n        var selection = host.selection;\n        var range = selection.getRange();\n        var row = selection.cursor.row;\n        var selectionStart = range.start.column;\n        var selectionEnd = range.end.column;\n        var line = host.session.getLine(row);\n\n        if (range.start.row != row) {\n            var prevLine = host.session.getLine(row - 1);\n            selectionStart = range.start.row < row - 1 ? 0 : selectionStart;\n            selectionEnd += prevLine.length + 1;\n            line = prevLine + \"\\n\" + line;\n        }\n        else if (range.end.row != row) {\n            var nextLine = host.session.getLine(row + 1);\n            selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;\n            selectionEnd += line.length + 1;\n            line = line + \"\\n\" + nextLine;\n        }\n\n        if (line.length > MAX_LINE_LENGTH) {\n            if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {\n                line = line.slice(0, MAX_LINE_LENGTH);\n            } else {\n                line = \"\\n\";\n                selectionStart = 0;\n                selectionEnd = 1;\n            }\n        }\n\n        var newValue = line + \"\\n\\n\";\n        if (newValue != lastValue) {\n            text.value = lastValue = newValue;\n            lastSelectionStart = lastSelectionEnd = newValue.length;\n        }\n        if (afterContextMenu) {\n            lastSelectionStart = text.selectionStart;\n            lastSelectionEnd = text.selectionEnd;\n        }\n        if (\n            lastSelectionEnd != selectionEnd \n            || lastSelectionStart != selectionStart \n            || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization\n        ) {\n            try {\n                text.setSelectionRange(selectionStart, selectionEnd);\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n            } catch(e){}\n        }\n        inComposition = false;\n    };\n\n    if (isFocused)\n        host.onFocus();\n\n\n    var isAllSelected = function(text) {\n        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length\n            && text.value === lastValue && lastValue\n            && text.selectionEnd !== lastSelectionEnd;\n    };\n\n    var onSelect = function(e) {\n        if (inComposition)\n            return;\n        if (copied) {\n            copied = false;\n        } else if (isAllSelected(text)) {\n            host.selectAll();\n            resetSelection();\n        }\n    };\n\n    var inputHandler = null;\n    this.setInputHandler = function(cb) {inputHandler = cb;};\n    this.getInputHandler = function() {return inputHandler;};\n    var afterContextMenu = false;\n    \n    var sendText = function(value, fromInput) {\n        if (afterContextMenu)\n            afterContextMenu = false;\n        if (pasted) {\n            resetSelection();\n            if (value)\n                host.onPaste(value);\n            pasted = false;\n            return \"\";\n        } else {\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n        \n            var extendLeft = lastSelectionStart;\n            var extendRight = lastValue.length - lastSelectionEnd;\n            \n            var inserted = value;\n            var restoreStart = value.length - selectionStart;\n            var restoreEnd = value.length - selectionEnd;\n        \n            var i = 0;\n            while (extendLeft > 0 && lastValue[i] == value[i]) {\n                i++;\n                extendLeft--;\n            }\n            inserted = inserted.slice(i);\n            i = 1;\n            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {\n                i++;\n                extendRight--;\n            }\n            restoreStart -= i-1;\n            restoreEnd -= i-1;\n            inserted = inserted.slice(0, inserted.length - i+1);\n            if (!fromInput && restoreStart == inserted.length && !extendLeft && !extendRight && !restoreEnd)\n                return \"\";\n            \n            sendingText = true;\n            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {\n                host.onTextInput(inserted);\n            } else {\n                host.onTextInput(inserted, {\n                    extendLeft: extendLeft,\n                    extendRight: extendRight,\n                    restoreStart: restoreStart,\n                    restoreEnd: restoreEnd\n                });\n            }\n            sendingText = false;\n            \n            lastValue = value;\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n            return inserted;\n        }\n    };\n    var onInput = function(e) {\n        if (inComposition)\n            return onCompositionUpdate();\n        var data = text.value;\n        var inserted = sendText(data, true);\n        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted))\n            resetSelection();\n    };\n    \n    var handleClipboardData = function(e, data, forceIEMime) {\n        var clipboardData = e.clipboardData || window.clipboardData;\n        if (!clipboardData || BROKEN_SETDATA)\n            return;\n        var mime = USE_IE_MIME_TYPE || forceIEMime ? \"Text\" : \"text/plain\";\n        try {\n            if (data) {\n                return clipboardData.setData(mime, data) !== false;\n            } else {\n                return clipboardData.getData(mime);\n            }\n        } catch(e) {\n            if (!forceIEMime)\n                return handleClipboardData(e, data, true);\n        }\n    };\n\n    var doCopy = function(e, isCut) {\n        var data = host.getCopyText();\n        if (!data)\n            return event.preventDefault(e);\n\n        if (handleClipboardData(e, data)) {\n            if (isIOS) {\n                resetSelection(data);\n                copied = data;\n                setTimeout(function () {\n                    copied = false;\n                }, 10);\n            }\n            isCut ? host.onCut() : host.onCopy();\n            event.preventDefault(e);\n        } else {\n            copied = true;\n            text.value = data;\n            text.select();\n            setTimeout(function(){\n                copied = false;\n                resetSelection();\n                isCut ? host.onCut() : host.onCopy();\n            });\n        }\n    };\n    \n    var onCut = function(e) {\n        doCopy(e, true);\n    };\n    \n    var onCopy = function(e) {\n        doCopy(e, false);\n    };\n    \n    var onPaste = function(e) {\n        var data = handleClipboardData(e);\n        if (typeof data == \"string\") {\n            if (data)\n                host.onPaste(data, e);\n            if (useragent.isIE)\n                setTimeout(resetSelection);\n            event.preventDefault(e);\n        }\n        else {\n            text.value = \"\";\n            pasted = true;\n        }\n    };\n\n    event.addCommandKeyListener(text, host.onCommandKey.bind(host));\n\n    event.addListener(text, \"select\", onSelect);\n    event.addListener(text, \"input\", onInput);\n\n    event.addListener(text, \"cut\", onCut);\n    event.addListener(text, \"copy\", onCopy);\n    event.addListener(text, \"paste\", onPaste);\n    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {\n        event.addListener(parentNode, \"keydown\", function(e) {\n            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n                return;\n\n            switch (e.keyCode) {\n                case 67:\n                    onCopy(e);\n                    break;\n                case 86:\n                    onPaste(e);\n                    break;\n                case 88:\n                    onCut(e);\n                    break;\n            }\n        });\n    }\n    var onCompositionStart = function(e) {\n        if (inComposition || !host.onCompositionStart || host.$readOnly) \n            return;\n        \n        inComposition = {};\n\n        if (commandMode)\n            return;\n        \n        setTimeout(onCompositionUpdate, 0);\n        host.on(\"mousedown\", cancelComposition);\n        \n        var range = host.getSelectionRange();\n        range.end.row = range.start.row;\n        range.end.column = range.start.column;\n        inComposition.markerRange = range;\n        inComposition.selectionStart = lastSelectionStart;\n        host.onCompositionStart(inComposition);\n        \n        if (inComposition.useTextareaForIME) {\n            text.value = \"\";\n            lastValue = \"\";\n            lastSelectionStart = 0;\n            lastSelectionEnd = 0;\n        }\n        else {\n            if (text.msGetInputContext)\n                inComposition.context = text.msGetInputContext();\n            if (text.getInputContext)\n                inComposition.context = text.getInputContext();\n        }\n    };\n\n    var onCompositionUpdate = function() {\n        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n            return;\n        if (commandMode)\n            return cancelComposition();\n        \n        if (inComposition.useTextareaForIME) {\n            host.onCompositionUpdate(text.value);\n        }\n        else {\n            var data = text.value;\n            sendText(data);\n            if (inComposition.markerRange) {\n                if (inComposition.context) {\n                    inComposition.markerRange.start.column = inComposition.selectionStart\n                        = inComposition.context.compositionStartOffset;\n                }\n                inComposition.markerRange.end.column = inComposition.markerRange.start.column\n                    + lastSelectionEnd - inComposition.selectionStart;\n            }\n        }\n    };\n\n    var onCompositionEnd = function(e) {\n        if (!host.onCompositionEnd || host.$readOnly) return;\n        inComposition = false;\n        host.onCompositionEnd();\n        host.off(\"mousedown\", cancelComposition);\n        if (e) onInput();\n    };\n    \n\n    function cancelComposition() {\n        ignoreFocusEvents = true;\n        text.blur();\n        text.focus();\n        ignoreFocusEvents = false;\n    }\n\n    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);\n    \n    function onKeyup(e) {\n        if (e.keyCode == 27 && text.value.length < text.selectionStart) {\n            if (!inComposition)\n                lastValue = text.value;\n            lastSelectionStart = lastSelectionEnd = -1;\n            resetSelection();\n        }\n        syncComposition();\n    }\n\n    event.addListener(text, \"compositionstart\", onCompositionStart);\n    event.addListener(text, \"compositionupdate\", onCompositionUpdate);\n    event.addListener(text, \"keyup\", onKeyup);\n    event.addListener(text, \"keydown\", syncComposition);\n    event.addListener(text, \"compositionend\", onCompositionEnd);\n\n    this.getElement = function() {\n        return text;\n    };\n    this.setCommandMode = function(value) {\n       commandMode = value;\n       text.readOnly = false;\n    };\n    \n    this.setReadOnly = function(readOnly) {\n        if (!commandMode)\n            text.readOnly = readOnly;\n    };\n\n    this.setCopyWithEmptySelection = function(value) {\n        copyWithEmptySelection = value;\n    };\n\n    this.onContextMenu = function(e) {\n        afterContextMenu = true;\n        resetSelection();\n        host._emit(\"nativecontextmenu\", {target: host, domEvent: e});\n        this.moveToMouse(e, true);\n    };\n    \n    this.moveToMouse = function(e, bringToFront) {\n        if (!tempStyle)\n            tempStyle = text.style.cssText;\n        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n            + (useragent.isIE ? \"opacity:0.1;\" : \"\")\n            + \"text-indent: -\" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + \"px;\";\n\n        var rect = host.container.getBoundingClientRect();\n        var style = dom.computedStyle(host.container);\n        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);\n        var maxTop = rect.bottom - top - text.clientHeight -2;\n        var move = function(e) {\n            text.style.left = e.clientX - left - 2 + \"px\";\n            text.style.top = Math.min(e.clientY - top - 2, maxTop) + \"px\";\n        }; \n        move(e);\n\n        if (e.type != \"mousedown\")\n            return;\n\n        if (host.renderer.$keepTextAreaAtCursor)\n            host.renderer.$keepTextAreaAtCursor = null;\n\n        clearTimeout(closeTimeout);\n        if (useragent.isWin)\n            event.capture(host.container, move, onContextMenuClose);\n    };\n\n    this.onContextMenuClose = onContextMenuClose;\n    var closeTimeout;\n    function onContextMenuClose() {\n        clearTimeout(closeTimeout);\n        closeTimeout = setTimeout(function () {\n            if (tempStyle) {\n                text.style.cssText = tempStyle;\n                tempStyle = '';\n            }\n            if (host.renderer.$keepTextAreaAtCursor == null) {\n                host.renderer.$keepTextAreaAtCursor = true;\n                host.renderer.$moveTextAreaToCursor();\n            }\n        }, 0);\n    }\n\n    var onContextMenu = function(e) {\n        host.textInput.onContextMenu(e);\n        onContextMenuClose();\n    };\n    event.addListener(text, \"mouseup\", onContextMenu);\n    event.addListener(text, \"mousedown\", function(e) {\n        e.preventDefault();\n        onContextMenuClose();\n    });\n    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu);\n    event.addListener(text, \"contextmenu\", onContextMenu);\n    \n    if (isIOS)\n        addIosSelectionHandler(parentNode, host, text);\n\n    function addIosSelectionHandler(parentNode, host, text) {\n        var typingResetTimeout = null;\n        var typing = false;\n \n        text.addEventListener(\"keydown\", function (e) {\n            if (typingResetTimeout) clearTimeout(typingResetTimeout);\n            typing = true;\n        }, true);\n\n        text.addEventListener(\"keyup\", function (e) {\n            typingResetTimeout = setTimeout(function () {\n                typing = false;\n            }, 100);\n        }, true);\n        var detectArrowKeys = function(e) {\n            if (document.activeElement !== text) return;\n            if (typing || inComposition) return;\n\n            if (copied) {\n                return;\n            }\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            \n            var key = null;\n            var modifier = 0;\n            console.log(selectionStart, selectionEnd);\n            if (selectionStart == 0) {\n                key = KEYS.up;\n            } else if (selectionStart == 1) {\n                key = KEYS.home;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == \"\\n\") {\n                key = KEYS.end;\n            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == \" \") {\n                key = KEYS.left;\n                modifier = MODS.option;\n            } else if (\n                selectionStart < lastSelectionStart\n                || (\n                    selectionStart == lastSelectionStart \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.left;\n            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split(\"\\n\").length > 2) {\n                key = KEYS.down;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == \" \") {\n                key = KEYS.right;\n                modifier = MODS.option;\n            } else if (\n                selectionEnd > lastSelectionEnd\n                || (\n                    selectionEnd == lastSelectionEnd \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.right;\n            }\n            \n            if (selectionStart !== selectionEnd)\n                modifier |= MODS.shift;\n\n            if (key) {\n                host.onCommandKey(null, modifier, key);\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n                resetSelection(\"\");\n            }\n        };\n        document.addEventListener(\"selectionchange\", detectArrowKeys);\n        host.on(\"destroy\", function() {\n            document.removeEventListener(\"selectionchange\", detectArrowKeys);\n        });\n    }\n\n};\n\nexports.TextInput = TextInput;\n});\n\nace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"../lib/useragent\");\n\nvar DRAG_OFFSET = 0; // pixels\nvar SCROLL_COOLDOWN_T = 550; // milliseconds\n\nfunction DefaultHandlers(mouseHandler) {\n    mouseHandler.$clickSelection = null;\n\n    var editor = mouseHandler.editor;\n    editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n    editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n    editor.setDefaultHandler(\"touchmove\", this.onTouchMove.bind(mouseHandler));\n\n    var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n        \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n\n    exports.forEach(function(x) {\n        mouseHandler[x] = this[x];\n    }, this);\n\n    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n}\n\n(function() {\n\n    this.onMouseDown = function(ev) {\n        var inSelection = ev.inSelection();\n        var pos = ev.getDocumentPosition();\n        this.mousedownEvent = ev;\n        var editor = this.editor;\n\n        var button = ev.getButton();\n        if (button !== 0) {\n            var selectionRange = editor.getSelectionRange();\n            var selectionEmpty = selectionRange.isEmpty();\n            if (selectionEmpty || button == 1)\n                editor.selection.moveToPosition(pos);\n            if (button == 2) {\n                editor.textInput.onContextMenu(ev.domEvent);\n                if (!useragent.isMozilla)\n                    ev.preventDefault();\n            }\n            return;\n        }\n\n        this.mousedownEvent.time = Date.now();\n        if (inSelection && !editor.isFocused()) {\n            editor.focus();\n            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {\n                this.setState(\"focusWait\");\n                this.captureMouse(ev);\n                return;\n            }\n        }\n\n        this.captureMouse(ev);\n        this.startSelect(pos, ev.domEvent._clicks > 1);\n        return ev.preventDefault();\n    };\n\n    this.startSelect = function(pos, waitForClickSelection) {\n        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var editor = this.editor;\n        if (!this.mousedownEvent) return;\n        if (this.mousedownEvent.getShiftKey())\n            editor.selection.selectToPosition(pos);\n        else if (!waitForClickSelection)\n            editor.selection.moveToPosition(pos);\n        if (!waitForClickSelection)\n            this.select();\n        if (editor.renderer.scroller.setCapture) {\n            editor.renderer.scroller.setCapture();\n        }\n        editor.setStyle(\"ace_selecting\");\n        this.setState(\"select\");\n    };\n\n    this.select = function() {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        if (this.$clickSelection) {\n            var cmp = this.$clickSelection.comparePoint(cursor);\n\n            if (cmp == -1) {\n                anchor = this.$clickSelection.end;\n            } else if (cmp == 1) {\n                anchor = this.$clickSelection.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.extendSelectionBy = function(unitName) {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var range = editor.selection[unitName](cursor.row, cursor.column);\n        if (this.$clickSelection) {\n            var cmpStart = this.$clickSelection.comparePoint(range.start);\n            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n\n            if (cmpStart == -1 && cmpEnd <= 0) {\n                anchor = this.$clickSelection.end;\n                if (range.end.row != cursor.row || range.end.column != cursor.column)\n                    cursor = range.start;\n            } else if (cmpEnd == 1 && cmpStart >= 0) {\n                anchor = this.$clickSelection.start;\n                if (range.start.row != cursor.row || range.start.column != cursor.column)\n                    cursor = range.end;\n            } else if (cmpStart == -1 && cmpEnd == 1) {\n                cursor = range.end;\n                anchor = range.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.selectEnd =\n    this.selectAllEnd =\n    this.selectByWordsEnd =\n    this.selectByLinesEnd = function() {\n        this.$clickSelection = null;\n        this.editor.unsetStyle(\"ace_selecting\");\n        if (this.editor.renderer.scroller.releaseCapture) {\n            this.editor.renderer.scroller.releaseCapture();\n        }\n    };\n\n    this.focusWait = function() {\n        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n        var time = Date.now();\n\n        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)\n            this.startSelect(this.mousedownEvent.getDocumentPosition());\n    };\n\n    this.onDoubleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        var session = editor.session;\n\n        var range = session.getBracketRange(pos);\n        if (range) {\n            if (range.isEmpty()) {\n                range.start.column--;\n                range.end.column++;\n            }\n            this.setState(\"select\");\n        } else {\n            range = editor.selection.getWordRange(pos.row, pos.column);\n            this.setState(\"selectByWords\");\n        }\n        this.$clickSelection = range;\n        this.select();\n    };\n\n    this.onTripleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n\n        this.setState(\"selectByLines\");\n        var range = editor.getSelectionRange();\n        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n        } else {\n            this.$clickSelection = editor.selection.getLineRange(pos.row);\n        }\n        this.select();\n    };\n\n    this.onQuadClick = function(ev) {\n        var editor = this.editor;\n\n        editor.selectAll();\n        this.$clickSelection = editor.getSelectionRange();\n        this.setState(\"selectAll\");\n    };\n\n    this.onMouseWheel = function(ev) {\n        if (ev.getAccelKey())\n            return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n        \n        var editor = this.editor;\n        \n        if (!this.$lastScroll)\n            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };\n        \n        var prevScroll = this.$lastScroll;\n        var t = ev.domEvent.timeStamp;\n        var dt = t - prevScroll.t;\n        var vx = dt ? ev.wheelX / dt : prevScroll.vx;\n        var vy = dt ? ev.wheelY / dt : prevScroll.vy;\n        if (dt < SCROLL_COOLDOWN_T) {\n            vx = (vx + prevScroll.vx) / 2;\n            vy = (vy + prevScroll.vy) / 2;\n        }\n        \n        var direction = Math.abs(vx / vy);\n        \n        var canScroll = false;\n        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))\n            canScroll = true;\n        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))\n            canScroll = true;\n            \n        if (canScroll) {\n            prevScroll.allowed = t;\n        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {\n            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)\n                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);\n            if (isSlower) {\n                canScroll = true;\n                prevScroll.allowed = t;\n            }\n            else {\n                prevScroll.allowed = 0;\n            }\n        }\n        \n        prevScroll.t = t;\n        prevScroll.vx = vx;\n        prevScroll.vy = vy;\n\n        if (canScroll) {\n            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    };\n    \n    this.onTouchMove = function(ev) {\n        this.editor._emit(\"mousewheel\", ev);\n    };\n\n}).call(DefaultHandlers.prototype);\n\nexports.DefaultHandlers = DefaultHandlers;\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nfunction calcRangeOrientation(range, cursor) {\n    if (range.start.row == range.end.row)\n        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n        var cmp = cursor.column - 4;\n    else\n        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n\n    if (cmp < 0)\n        return {cursor: range.start, anchor: range.end};\n    else\n        return {cursor: range.end, anchor: range.start};\n}\n\n});\n\nace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nfunction Tooltip (parentNode) {\n    this.isOpen = false;\n    this.$element = null;\n    this.$parentNode = parentNode;\n}\n\n(function() {\n    this.$init = function() {\n        this.$element = dom.createElement(\"div\");\n        this.$element.className = \"ace_tooltip\";\n        this.$element.style.display = \"none\";\n        this.$parentNode.appendChild(this.$element);\n        return this.$element;\n    };\n    this.getElement = function() {\n        return this.$element || this.$init();\n    };\n    this.setText = function(text) {\n        this.getElement().textContent = text;\n    };\n    this.setHtml = function(html) {\n        this.getElement().innerHTML = html;\n    };\n    this.setPosition = function(x, y) {\n        this.getElement().style.left = x + \"px\";\n        this.getElement().style.top = y + \"px\";\n    };\n    this.setClassName = function(className) {\n        dom.addCssClass(this.getElement(), className);\n    };\n    this.show = function(text, x, y) {\n        if (text != null)\n            this.setText(text);\n        if (x != null && y != null)\n            this.setPosition(x, y);\n        if (!this.isOpen) {\n            this.getElement().style.display = \"block\";\n            this.isOpen = true;\n        }\n    };\n\n    this.hide = function() {\n        if (this.isOpen) {\n            this.getElement().style.display = \"none\";\n            this.isOpen = false;\n        }\n    };\n    this.getHeight = function() {\n        return this.getElement().offsetHeight;\n    };\n    this.getWidth = function() {\n        return this.getElement().offsetWidth;\n    };\n    \n    this.destroy = function() {\n        this.isOpen = false;\n        if (this.$element && this.$element.parentNode) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    };\n\n}).call(Tooltip.prototype);\n\nexports.Tooltip = Tooltip;\n});\n\nace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event\",\"ace/tooltip\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar event = require(\"../lib/event\");\nvar Tooltip = require(\"../tooltip\").Tooltip;\n\nfunction GutterHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var gutter = editor.renderer.$gutterLayer;\n    var tooltip = new GutterTooltip(editor.container);\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function(e) {\n        if (!editor.isFocused() || e.getButton() != 0)\n            return;\n        var gutterRegion = gutter.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\")\n            return;\n\n        var row = e.getDocumentPosition().row;\n        var selection = editor.session.selection;\n\n        if (e.getShiftKey())\n            selection.selectTo(row, 0);\n        else {\n            if (e.domEvent.detail == 2) {\n                editor.selectAll();\n                return e.preventDefault();\n            }\n            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n        }\n        mouseHandler.setState(\"selectByLines\");\n        mouseHandler.captureMouse(e);\n        return e.preventDefault();\n    });\n\n\n    var tooltipTimeout, mouseEvent, tooltipAnnotation;\n\n    function showTooltip() {\n        var row = mouseEvent.getDocumentPosition().row;\n        var annotation = gutter.$annotations[row];\n        if (!annotation)\n            return hideTooltip();\n\n        var maxRow = editor.session.getLength();\n        if (row == maxRow) {\n            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n            var pos = mouseEvent.$pos;\n            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n                return hideTooltip();\n        }\n\n        if (tooltipAnnotation == annotation)\n            return;\n        tooltipAnnotation = annotation.text.join(\"<br/>\");\n\n        tooltip.setHtml(tooltipAnnotation);\n        tooltip.show();\n        editor._signal(\"showGutterTooltip\", tooltip);\n        editor.on(\"mousewheel\", hideTooltip);\n\n        if (mouseHandler.$tooltipFollowsMouse) {\n            moveTooltip(mouseEvent);\n        } else {\n            var gutterElement = mouseEvent.domEvent.target;\n            var rect = gutterElement.getBoundingClientRect();\n            var style = tooltip.getElement().style;\n            style.left = rect.right + \"px\";\n            style.top = rect.bottom + \"px\";\n        }\n    }\n\n    function hideTooltip() {\n        if (tooltipTimeout)\n            tooltipTimeout = clearTimeout(tooltipTimeout);\n        if (tooltipAnnotation) {\n            tooltip.hide();\n            tooltipAnnotation = null;\n            editor._signal(\"hideGutterTooltip\", tooltip);\n            editor.removeEventListener(\"mousewheel\", hideTooltip);\n        }\n    }\n\n    function moveTooltip(e) {\n        tooltip.setPosition(e.x, e.y);\n    }\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function(e) {\n        var target = e.domEvent.target || e.domEvent.srcElement;\n        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n            return hideTooltip();\n\n        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)\n            moveTooltip(e);\n\n        mouseEvent = e;\n        if (tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            if (mouseEvent && !mouseHandler.isMousePressed)\n                showTooltip();\n            else\n                hideTooltip();\n        }, 50);\n    });\n\n    event.addListener(editor.renderer.$gutter, \"mouseout\", function(e) {\n        mouseEvent = null;\n        if (!tooltipAnnotation || tooltipTimeout)\n            return;\n\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            hideTooltip();\n        }, 50);\n    });\n    \n    editor.on(\"changeSession\", hideTooltip);\n}\n\nfunction GutterTooltip(parentNode) {\n    Tooltip.call(this, parentNode);\n}\n\noop.inherits(GutterTooltip, Tooltip);\n\n(function(){\n    this.setPosition = function(x, y) {\n        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n        var width = this.getWidth();\n        var height = this.getHeight();\n        x += 15;\n        y += 15;\n        if (x + width > windowWidth) {\n            x -= (x + width) - windowWidth;\n        }\n        if (y + height > windowHeight) {\n            y -= 20 + height;\n        }\n        Tooltip.prototype.setPosition.call(this, x, y);\n    };\n\n}).call(GutterTooltip.prototype);\n\n\n\nexports.GutterHandler = GutterHandler;\n\n});\n\nace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar MouseEvent = exports.MouseEvent = function(domEvent, editor) {\n    this.domEvent = domEvent;\n    this.editor = editor;\n    \n    this.x = this.clientX = domEvent.clientX;\n    this.y = this.clientY = domEvent.clientY;\n\n    this.$pos = null;\n    this.$inSelection = null;\n    \n    this.propagationStopped = false;\n    this.defaultPrevented = false;\n};\n\n(function() {  \n    \n    this.stopPropagation = function() {\n        event.stopPropagation(this.domEvent);\n        this.propagationStopped = true;\n    };\n    \n    this.preventDefault = function() {\n        event.preventDefault(this.domEvent);\n        this.defaultPrevented = true;\n    };\n    \n    this.stop = function() {\n        this.stopPropagation();\n        this.preventDefault();\n    };\n    this.getDocumentPosition = function() {\n        if (this.$pos)\n            return this.$pos;\n        \n        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n        return this.$pos;\n    };\n    this.inSelection = function() {\n        if (this.$inSelection !== null)\n            return this.$inSelection;\n            \n        var editor = this.editor;\n        \n\n        var selectionRange = editor.getSelectionRange();\n        if (selectionRange.isEmpty())\n            this.$inSelection = false;\n        else {\n            var pos = this.getDocumentPosition();\n            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n        }\n\n        return this.$inSelection;\n    };\n    this.getButton = function() {\n        return event.getButton(this.domEvent);\n    };\n    this.getShiftKey = function() {\n        return this.domEvent.shiftKey;\n    };\n    \n    this.getAccelKey = useragent.isMac\n        ? function() { return this.domEvent.metaKey; }\n        : function() { return this.domEvent.ctrlKey; };\n    \n}).call(MouseEvent.prototype);\n\n});\n\nace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\n\nvar AUTOSCROLL_DELAY = 200;\nvar SCROLL_CURSOR_DELAY = 200;\nvar SCROLL_CURSOR_HYSTERESIS = 5;\n\nfunction DragdropHandler(mouseHandler) {\n\n    var editor = mouseHandler.editor;\n\n    var blankImage = dom.createElement(\"img\");\n    blankImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (useragent.isOpera)\n        blankImage.style.cssText = \"width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;\";\n\n    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n\n     exports.forEach(function(x) {\n         mouseHandler[x] = this[x];\n    }, this);\n    editor.addEventListener(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n\n\n    var mouseTarget = editor.container;\n    var dragSelectionMarker, x, y;\n    var timerId, range;\n    var dragCursor, counter = 0;\n    var dragOperation;\n    var isInternal;\n    var autoScrollStartTime;\n    var cursorMovedTime;\n    var cursorPointOnCaretMoved;\n\n    this.onDragStart = function(e) {\n        if (this.cancelDrag || !mouseTarget.draggable) {\n            var self = this;\n            setTimeout(function(){\n                self.startSelect();\n                self.captureMouse(e);\n            }, 0);\n            return e.preventDefault();\n        }\n        range = editor.getSelectionRange();\n\n        var dataTransfer = e.dataTransfer;\n        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n        if (useragent.isOpera) {\n            editor.container.appendChild(blankImage);\n            blankImage.scrollTop = 0;\n        }\n        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);\n        if (useragent.isOpera) {\n            editor.container.removeChild(blankImage);\n        }\n        dataTransfer.clearData();\n        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n\n        isInternal = true;\n        this.setState(\"drag\");\n    };\n\n    this.onDragEnd = function(e) {\n        mouseTarget.draggable = false;\n        isInternal = false;\n        this.setState(null);\n        if (!editor.getReadOnly()) {\n            var dropEffect = e.dataTransfer.dropEffect;\n            if (!dragOperation && dropEffect == \"move\")\n                editor.session.remove(editor.getSelectionRange());\n            editor.renderer.$cursorLayer.setBlinking(true);\n        }\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n    };\n\n    this.onDragEnter = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker)\n            addDragMarker();\n        counter++;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragOver = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker) {\n            addDragMarker();\n            counter++;\n        }\n        if (onMouseMoveTimer !== null)\n            onMouseMoveTimer = null;\n\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragLeave = function(e) {\n        counter--;\n        if (counter <= 0 && dragSelectionMarker) {\n            clearDragMarker();\n            dragOperation = null;\n            return event.preventDefault(e);\n        }\n    };\n\n    this.onDrop = function(e) {\n        if (!dragCursor)\n            return;\n        var dataTransfer = e.dataTransfer;\n        if (isInternal) {\n            switch (dragOperation) {\n                case \"move\":\n                    if (range.contains(dragCursor.row, dragCursor.column)) {\n                        range = {\n                            start: dragCursor,\n                            end: dragCursor\n                        };\n                    } else {\n                        range = editor.moveText(range, dragCursor);\n                    }\n                    break;\n                case \"copy\":\n                    range = editor.moveText(range, dragCursor, true);\n                    break;\n            }\n        } else {\n            var dropData = dataTransfer.getData('Text');\n            range = {\n                start: dragCursor,\n                end: editor.session.insert(dragCursor, dropData)\n            };\n            editor.focus();\n            dragOperation = null;\n        }\n        clearDragMarker();\n        return event.preventDefault(e);\n    };\n\n    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler));\n    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler));\n\n    function scrollCursorIntoView(cursor, prevCursor) {\n        var now = Date.now();\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n        if (!cursorMovedTime || vMovement || hMovement) {\n            editor.moveCursorToPosition(cursor);\n            cursorMovedTime = now;\n            cursorPointOnCaretMoved = {x: x, y: y};\n        } else {\n            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n                cursorMovedTime = null;\n            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n                editor.renderer.scrollCursorIntoView();\n                cursorMovedTime = null;\n            }\n        }\n    }\n\n    function autoScroll(cursor, prevCursor) {\n        var now = Date.now();\n        var lineHeight = editor.renderer.layerConfig.lineHeight;\n        var characterWidth = editor.renderer.layerConfig.characterWidth;\n        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n        var offsets = {\n           x: {\n               left: x - editorRect.left,\n               right: editorRect.right - x\n           },\n           y: {\n               top: y - editorRect.top,\n               bottom: editorRect.bottom - y\n           }\n        };\n        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n        var scrollCursor = {row: cursor.row, column: cursor.column};\n        if (nearestXOffset / characterWidth <= 2) {\n            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n        }\n        if (nearestYOffset / lineHeight <= 1) {\n            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n        }\n        var vScroll = cursor.row != scrollCursor.row;\n        var hScroll = cursor.column != scrollCursor.column;\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        if (vScroll || (hScroll && !vMovement)) {\n            if (!autoScrollStartTime)\n                autoScrollStartTime = now;\n            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n                editor.renderer.scrollCursorIntoView(scrollCursor);\n        } else {\n            autoScrollStartTime = null;\n        }\n    }\n\n    function onDragInterval() {\n        var prevCursor = dragCursor;\n        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n        scrollCursorIntoView(dragCursor, prevCursor);\n        autoScroll(dragCursor, prevCursor);\n    }\n\n    function addDragMarker() {\n        range = editor.selection.toOrientedRange();\n        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n        editor.clearSelection();\n        if (editor.isFocused())\n            editor.renderer.$cursorLayer.setBlinking(false);\n        clearInterval(timerId);\n        onDragInterval();\n        timerId = setInterval(onDragInterval, 20);\n        counter = 0;\n        event.addListener(document, \"mousemove\", onMouseMove);\n    }\n\n    function clearDragMarker() {\n        clearInterval(timerId);\n        editor.session.removeMarker(dragSelectionMarker);\n        dragSelectionMarker = null;\n        editor.selection.fromOrientedRange(range);\n        if (editor.isFocused() && !isInternal)\n            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());\n        range = null;\n        dragCursor = null;\n        counter = 0;\n        autoScrollStartTime = null;\n        cursorMovedTime = null;\n        event.removeListener(document, \"mousemove\", onMouseMove);\n    }\n    var onMouseMoveTimer = null;\n    function onMouseMove() {\n        if (onMouseMoveTimer == null) {\n            onMouseMoveTimer = setTimeout(function() {\n                if (onMouseMoveTimer != null && dragSelectionMarker)\n                    clearDragMarker();\n            }, 20);\n        }\n    }\n\n    function canAccept(dataTransfer) {\n        var types = dataTransfer.types;\n        return !types || Array.prototype.some.call(types, function(type) {\n            return type == 'text/plain' || type == 'Text';\n        });\n    }\n\n    function getDropEffect(e) {\n        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n\n        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n        var effectAllowed = \"uninitialized\";\n        try {\n            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n        } catch (e) {}\n        var dropEffect = \"none\";\n\n        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"move\";\n        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n\n        return dropEffect;\n    }\n}\n\n(function() {\n\n    this.dragWait = function() {\n        var interval = Date.now() - this.mousedownEvent.time;\n        if (interval > this.editor.getDragDelay())\n            this.startDrag();\n    };\n\n    this.dragWaitEnd = function() {\n        var target = this.editor.container;\n        target.draggable = false;\n        this.startSelect(this.mousedownEvent.getDocumentPosition());\n        this.selectEnd();\n    };\n\n    this.dragReadyEnd = function(e) {\n        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n        this.dragWaitEnd();\n    };\n\n    this.startDrag = function(){\n        this.cancelDrag = false;\n        var editor = this.editor;\n        var target = editor.container;\n        target.draggable = true;\n        editor.renderer.$cursorLayer.setBlinking(false);\n        editor.setStyle(\"ace_dragging\");\n        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n        editor.renderer.setCursorStyle(cursorStyle);\n        this.setState(\"dragReady\");\n    };\n\n    this.onMouseDrag = function(e) {\n        var target = this.editor.container;\n        if (useragent.isIE && this.state == \"dragReady\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 3)\n                target.dragDrop();\n        }\n        if (this.state === \"dragWait\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 0) {\n                target.draggable = false;\n                this.startSelect(this.mousedownEvent.getDocumentPosition());\n            }\n        }\n    };\n\n    this.onMouseDown = function(e) {\n        if (!this.$dragEnabled)\n            return;\n        this.mousedownEvent = e;\n        var editor = this.editor;\n\n        var inSelection = e.inSelection();\n        var button = e.getButton();\n        var clickCount = e.domEvent.detail || 1;\n        if (clickCount === 1 && button === 0 && inSelection) {\n            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n                return;\n            this.mousedownEvent.time = Date.now();\n            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n            if (\"unselectable\" in eventTarget)\n                eventTarget.unselectable = \"on\";\n            if (editor.getDragDelay()) {\n                if (useragent.isWebKit) {\n                    this.cancelDrag = true;\n                    var mouseTarget = editor.container;\n                    mouseTarget.draggable = true;\n                }\n                this.setState(\"dragWait\");\n            } else {\n                this.startDrag();\n            }\n            this.captureMouse(e, this.onMouseDrag.bind(this));\n            e.defaultPrevented = true;\n        }\n    };\n\n}).call(DragdropHandler.prototype);\n\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nexports.DragdropHandler = DragdropHandler;\n\n});\n\nace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"./dom\");\n\nexports.get = function (url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            callback(xhr.responseText);\n        }\n    };\n    xhr.send(null);\n};\n\nexports.loadScript = function(path, callback) {\n    var head = dom.getDocumentHead();\n    var s = document.createElement('script');\n\n    s.src = path;\n    head.appendChild(s);\n\n    s.onload = s.onreadystatechange = function(_, isAbort) {\n        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n            s = s.onload = s.onreadystatechange = null;\n            if (!isAbort)\n                callback();\n        }\n    };\n};\nexports.qualifyURL = function(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.href;\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar EventEmitter = {};\nvar stopPropagation = function() { this.propagationStopped = true; };\nvar preventDefault = function() { this.defaultPrevented = true; };\n\nEventEmitter._emit =\nEventEmitter._dispatchEvent = function(eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler)\n        return;\n\n    if (typeof e != \"object\" || !e)\n        e = {};\n\n    if (!e.type)\n        e.type = eventName;\n    if (!e.stopPropagation)\n        e.stopPropagation = stopPropagation;\n    if (!e.preventDefault)\n        e.preventDefault = preventDefault;\n\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++) {\n        listeners[i](e, this);\n        if (e.propagationStopped)\n            break;\n    }\n    \n    if (defaultHandler && !e.defaultPrevented)\n        return defaultHandler(e, this);\n};\n\n\nEventEmitter._signal = function(eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](e, this);\n};\n\nEventEmitter.once = function(eventName, callback) {\n    var _self = this;\n    this.addEventListener(eventName, function newCallback() {\n        _self.removeEventListener(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function(resolve) {\n            callback = resolve;\n        });\n    }\n};\n\n\nEventEmitter.setDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = {_disabled_: {}};\n    \n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1) \n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    \n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\n\nEventEmitter.on =\nEventEmitter.addEventListener = function(eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        listeners = this._eventRegistry[eventName] = [];\n\n    if (listeners.indexOf(callback) == -1)\n        listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n};\n\nEventEmitter.off =\nEventEmitter.removeListener =\nEventEmitter.removeEventListener = function(eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        return;\n\n    var index = listeners.indexOf(callback);\n    if (index !== -1)\n        listeners.splice(index, 1);\n};\n\nEventEmitter.removeAllListeners = function(eventName) {\n    if (this._eventRegistry) this._eventRegistry[eventName] = [];\n};\n\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/lib/app_config\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"no use strict\";\n\nvar oop = require(\"./oop\");\nvar EventEmitter = require(\"./event_emitter\").EventEmitter;\n\nvar optionsProvider = {\n    setOptions: function(optList) {\n        Object.keys(optList).forEach(function(key) {\n            this.setOption(key, optList[key]);\n        }, this);\n    },\n    getOptions: function(optionNames) {\n        var result = {};\n        if (!optionNames) {\n            var options = this.$options;\n            optionNames = Object.keys(options).filter(function(key) {\n                return !options[key].hidden;\n            });\n        } else if (!Array.isArray(optionNames)) {\n            result = optionNames;\n            optionNames = Object.keys(result);\n        }\n        optionNames.forEach(function(key) {\n            result[key] = this.getOption(key);\n        }, this);\n        return result;\n    },\n    setOption: function(name, value) {\n        if (this[\"$\" + name] === value)\n            return;\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n\n        if (!opt.handlesSet)\n            this[\"$\" + name] = value;\n        if (opt && opt.set)\n            opt.set.call(this, value);\n    },\n    getOption: function(name) {\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n    }\n};\n\nfunction warn(message) {\n    if (typeof console != \"undefined\" && console.warn)\n        console.warn.apply(console, arguments);\n}\n\nfunction reportError(msg, data) {\n    var e = new Error(msg);\n    e.data = data;\n    if (typeof console == \"object\" && console.error)\n        console.error(e);\n    setTimeout(function() { throw e; });\n}\n\nvar AppConfig = function() {\n    this.$defaultOptions = {};\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n    this.defineOptions = function(obj, path, options) {\n        if (!obj.$options)\n            this.$defaultOptions[path] = obj.$options = {};\n\n        Object.keys(options).forEach(function(key) {\n            var opt = options[key];\n            if (typeof opt == \"string\")\n                opt = {forwardTo: opt};\n\n            opt.name || (opt.name = key);\n            obj.$options[opt.name] = opt;\n            if (\"initialValue\" in opt)\n                obj[\"$\" + opt.name] = opt.initialValue;\n        });\n        oop.implement(obj, optionsProvider);\n\n        return this;\n    };\n\n    this.resetOptions = function(obj) {\n        Object.keys(obj.$options).forEach(function(key) {\n            var opt = obj.$options[key];\n            if (\"value\" in opt)\n                obj.setOption(key, opt.value);\n        });\n    };\n\n    this.setDefaultValue = function(path, name, value) {\n        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});\n        if (opts[name]) {\n            if (opts.forwardTo)\n                this.setDefaultValue(opts.forwardTo, name, value);\n            else\n                opts[name].value = value;\n        }\n    };\n\n    this.setDefaultValues = function(path, optionHash) {\n        Object.keys(optionHash).forEach(function(key) {\n            this.setDefaultValue(path, key, optionHash[key]);\n        }, this);\n    };\n    \n    this.warn = warn;\n    this.reportError = reportError;\n    \n}).call(AppConfig.prototype);\n\nexports.AppConfig = AppConfig;\n\n});\n\nace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/app_config\"], function(require, exports, module) {\n\"no use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar net = require(\"./lib/net\");\nvar AppConfig = require(\"./lib/app_config\").AppConfig;\n\nmodule.exports = exports = new AppConfig();\n\nvar global = (function() {\n    return this || typeof window != \"undefined\" && window;\n})();\n\nvar options = {\n    packaged: false,\n    workerPath: null,\n    modePath: null,\n    themePath: null,\n    basePath: \"\",\n    suffix: \".js\",\n    $moduleUrls: {},\n    loadWorkerFromBlob: true\n};\n\nexports.get = function(key) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n\n    return options[key];\n};\n\nexports.set = function(key, value) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n\n    options[key] = value;\n};\n\nexports.all = function() {\n    return lang.copyObject(options);\n};\n\nexports.$modes = {};\nexports.moduleUrl = function(name, component) {\n    if (options.$moduleUrls[name])\n        return options.$moduleUrls[name];\n\n    var parts = name.split(\"/\");\n    component = component || parts[parts.length - 2] || \"\";\n    var sep = component == \"snippets\" ? \"/\" : \"-\";\n    var base = parts[parts.length - 1];\n    if (component == \"worker\" && sep == \"-\") {\n        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n        base = base.replace(re, \"\");\n    }\n\n    if ((!base || base == component) && parts.length > 1)\n        base = parts[parts.length - 2];\n    var path = options[component + \"Path\"];\n    if (path == null) {\n        path = options.basePath;\n    } else if (sep == \"/\") {\n        component = sep = \"\";\n    }\n    if (path && path.slice(-1) != \"/\")\n        path += \"/\";\n    return path + component + sep + base + this.get(\"suffix\");\n};\n\nexports.setModuleUrl = function(name, subst) {\n    return options.$moduleUrls[name] = subst;\n};\n\nexports.$loading = {};\nexports.loadModule = function(moduleName, onLoad) {\n    var module, moduleType;\n    if (Array.isArray(moduleName)) {\n        moduleType = moduleName[0];\n        moduleName = moduleName[1];\n    }\n\n    try {\n        module = require(moduleName);\n    } catch (e) {}\n    if (module && !exports.$loading[moduleName])\n        return onLoad && onLoad(module);\n\n    if (!exports.$loading[moduleName])\n        exports.$loading[moduleName] = [];\n\n    exports.$loading[moduleName].push(onLoad);\n\n    if (exports.$loading[moduleName].length > 1)\n        return;\n\n    var afterLoad = function() {\n        require([moduleName], function(module) {\n            exports._emit(\"load.module\", {name: moduleName, module: module});\n            var listeners = exports.$loading[moduleName];\n            exports.$loading[moduleName] = null;\n            listeners.forEach(function(onLoad) {\n                onLoad && onLoad(module);\n            });\n        });\n    };\n\n    if (!exports.get(\"packaged\"))\n        return afterLoad();\n    \n    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n    reportErrorIfPathIsNotConfigured();\n};\n\nvar reportErrorIfPathIsNotConfigured = function() {\n    if (\n        !options.basePath && !options.workerPath \n        && !options.modePath && !options.themePath\n        && !Object.keys(options.$moduleUrls).length\n    ) {\n        console.error(\n            \"Unable to infer path to ace from script src,\",\n            \"use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes\",\n            \"or with webpack use ace/webpack-resolver\"\n        );\n        reportErrorIfPathIsNotConfigured = function() {};\n    }\n};\ninit(true);function init(packaged) {\n\n    if (!global || !global.document)\n        return;\n    \n    options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);\n\n    var scriptOptions = {};\n    var scriptUrl = \"\";\n    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n    var currentDocument = currentScript && currentScript.ownerDocument || document;\n    \n    var scripts = currentDocument.getElementsByTagName(\"script\");\n    for (var i=0; i<scripts.length; i++) {\n        var script = scripts[i];\n\n        var src = script.src || script.getAttribute(\"src\");\n        if (!src)\n            continue;\n\n        var attributes = script.attributes;\n        for (var j=0, l=attributes.length; j < l; j++) {\n            var attr = attributes[j];\n            if (attr.name.indexOf(\"data-ace-\") === 0) {\n                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n            }\n        }\n\n        var m = src.match(/^(.*)\\/ace(\\-\\w+)?\\.js(\\?|$)/);\n        if (m)\n            scriptUrl = m[1];\n    }\n\n    if (scriptUrl) {\n        scriptOptions.base = scriptOptions.base || scriptUrl;\n        scriptOptions.packaged = true;\n    }\n\n    scriptOptions.basePath = scriptOptions.base;\n    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n    delete scriptOptions.base;\n\n    for (var key in scriptOptions)\n        if (typeof scriptOptions[key] !== \"undefined\")\n            exports.set(key, scriptOptions[key]);\n}\n\nexports.init = init;\n\nfunction deHyphenate(str) {\n    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n}\n\n});\n\nace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar DefaultHandlers = require(\"./default_handlers\").DefaultHandlers;\nvar DefaultGutterHandler = require(\"./default_gutter_handler\").GutterHandler;\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar DragdropHandler = require(\"./dragdrop_handler\").DragdropHandler;\nvar config = require(\"../config\");\n\nvar MouseHandler = function(editor) {\n    var _self = this;\n    this.editor = editor;\n\n    new DefaultHandlers(this);\n    new DefaultGutterHandler(this);\n    new DragdropHandler(this);\n\n    var focusEditor = function(e) {\n        var windowBlurred = !document.hasFocus || !document.hasFocus()\n            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());\n        if (windowBlurred)\n            window.focus();\n        editor.focus();\n    };\n\n    var mouseTarget = editor.renderer.getMouseEventTarget();\n    event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"));\n    event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"));\n    event.addMultiMouseDownListener([\n        mouseTarget,\n        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,\n        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,\n        editor.textInput && editor.textInput.getElement()\n    ].filter(Boolean), [400, 300, 250], this, \"onMouseEvent\");\n    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"));\n    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, \"touchmove\"));\n\n    var gutterEl = editor.renderer.$gutter;\n    event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"));\n    event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"));\n    event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"));\n    event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"));\n\n    event.addListener(mouseTarget, \"mousedown\", focusEditor);\n    event.addListener(gutterEl, \"mousedown\", focusEditor);\n    if (useragent.isIE && editor.renderer.scrollBarV) {\n        event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor);\n        event.addListener(editor.renderer.scrollBarH.element, \"mousedown\", focusEditor);\n    }\n\n    editor.on(\"mousemove\", function(e){\n        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n            return;\n\n        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);\n        var range = editor.session.selection.getRange();\n        var renderer = editor.renderer;\n\n        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {\n            renderer.setCursorStyle(\"default\");\n        } else {\n            renderer.setCursorStyle(\"\");\n        }\n    });\n};\n\n(function() {\n    this.onMouseEvent = function(name, e) {\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseMove = function(name, e) {\n        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n        if (!listeners || !listeners.length)\n            return;\n\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseWheel = function(name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n\n        this.editor._emit(name, mouseEvent);\n    };\n    \n    this.onTouchMove = function (name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = 1;//this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n        this.editor._emit(name, mouseEvent);\n    };\n\n    this.setState = function(state) {\n        this.state = state;\n    };\n\n    this.captureMouse = function(ev, mouseMoveHandler) {\n        this.x = ev.x;\n        this.y = ev.y;\n\n        this.isMousePressed = true;\n        var editor = this.editor;\n        var renderer = this.editor.renderer;\n        if (renderer.$keepTextAreaAtCursor)\n            renderer.$keepTextAreaAtCursor = null;\n\n        var self = this;\n        var onMouseMove = function(e) {\n            if (!e) return;\n            if (useragent.isWebKit && !e.which && self.releaseMouse)\n                return self.releaseMouse();\n\n            self.x = e.clientX;\n            self.y = e.clientY;\n            mouseMoveHandler && mouseMoveHandler(e);\n            self.mouseEvent = new MouseEvent(e, self.editor);\n            self.$mouseMoved = true;\n        };\n\n        var onCaptureEnd = function(e) {\n            editor.off(\"beforeEndOperation\", onOperationEnd);\n            clearInterval(timerId);\n            onCaptureInterval();\n            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n            self.state = \"\";\n            if (renderer.$keepTextAreaAtCursor == null) {\n                renderer.$keepTextAreaAtCursor = true;\n                renderer.$moveTextAreaToCursor();\n            }\n            self.isMousePressed = false;\n            self.$onCaptureMouseMove = self.releaseMouse = null;\n            e && self.onMouseEvent(\"mouseup\", e);\n            editor.endOperation();\n        };\n\n        var onCaptureInterval = function() {\n            self[self.state] && self[self.state]();\n            self.$mouseMoved = false;\n        };\n\n        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n            return setTimeout(function() {onCaptureEnd(ev);});\n        }\n\n        var onOperationEnd = function(e) {\n            if (!self.releaseMouse) return;\n            if (editor.curOp.command.name && editor.curOp.selectionChanged) {\n                self[self.state + \"End\"] && self[self.state + \"End\"]();\n                self.state = \"\";\n                self.releaseMouse();\n            }\n        };\n\n        editor.on(\"beforeEndOperation\", onOperationEnd);\n        editor.startOperation({command: {name: \"mouse\"}});\n\n        self.$onCaptureMouseMove = onMouseMove;\n        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n        var timerId = setInterval(onCaptureInterval, 20);\n    };\n    this.releaseMouse = null;\n    this.cancelContextMenu = function() {\n        var stop = function(e) {\n            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n                return;\n            this.editor.off(\"nativecontextmenu\", stop);\n            if (e && e.domEvent)\n                event.stopEvent(e.domEvent);\n        }.bind(this);\n        setTimeout(stop, 10);\n        this.editor.on(\"nativecontextmenu\", stop);\n    };\n}).call(MouseHandler.prototype);\n\nconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n    scrollSpeed: {initialValue: 2},\n    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},\n    dragEnabled: {initialValue: true},\n    focusTimeout: {initialValue: 0},\n    tooltipFollowsMouse: {initialValue: true}\n});\n\n\nexports.MouseHandler = MouseHandler;\n});\n\nace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\n\nfunction FoldHandler(editor) {\n\n    editor.on(\"click\", function(e) {\n        var position = e.getDocumentPosition();\n        var session = editor.session;\n        var fold = session.getFoldAt(position.row, position.column, 1);\n        if (fold) {\n            if (e.getAccelKey())\n                session.removeFold(fold);\n            else\n                session.expandFold(fold);\n\n            e.stop();\n        }\n        \n        var target = e.domEvent && e.domEvent.target;\n        if (target && dom.hasCssClass(target, \"ace_inline_button\")) {\n            if (dom.hasCssClass(target, \"ace_toggle_wrap\")) {\n                session.setOption(\"wrap\", true);\n                editor.renderer.scrollCursorIntoView();\n            }\n        }\n    });\n\n    editor.on(\"gutterclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            if (session.foldWidgets && session.foldWidgets[row])\n                editor.session.onFoldWidgetClick(row, e);\n            if (!editor.isFocused())\n                editor.focus();\n            e.stop();\n        }\n    });\n\n    editor.on(\"gutterdblclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            var data = session.getParentFoldRangeData(row, true);\n            var range = data.range || data.firstRange;\n\n            if (range) {\n                row = range.start.row;\n                var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n\n                if (fold) {\n                    session.removeFold(fold);\n                } else {\n                    session.addFold(\"...\", range);\n                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});\n                }\n            }\n            e.stop();\n        }\n    });\n}\n\nexports.FoldHandler = FoldHandler;\n\n});\n\nace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil  = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\n\nvar KeyBinding = function(editor) {\n    this.$editor = editor;\n    this.$data = {editor: editor};\n    this.$handlers = [];\n    this.setDefaultHandler(editor.commands);\n};\n\n(function() {\n    this.setDefaultHandler = function(kb) {\n        this.removeKeyboardHandler(this.$defaultHandler);\n        this.$defaultHandler = kb;\n        this.addKeyboardHandler(kb, 0);\n    };\n\n    this.setKeyboardHandler = function(kb) {\n        var h = this.$handlers;\n        if (h[h.length - 1] == kb)\n            return;\n\n        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n            this.removeKeyboardHandler(h[h.length - 1]);\n\n        this.addKeyboardHandler(kb, 1);\n    };\n\n    this.addKeyboardHandler = function(kb, pos) {\n        if (!kb)\n            return;\n        if (typeof kb == \"function\" && !kb.handleKeyboard)\n            kb.handleKeyboard = kb;\n        var i = this.$handlers.indexOf(kb);\n        if (i != -1)\n            this.$handlers.splice(i, 1);\n\n        if (pos == undefined)\n            this.$handlers.push(kb);\n        else\n            this.$handlers.splice(pos, 0, kb);\n\n        if (i == -1 && kb.attach)\n            kb.attach(this.$editor);\n    };\n\n    this.removeKeyboardHandler = function(kb) {\n        var i = this.$handlers.indexOf(kb);\n        if (i == -1)\n            return false;\n        this.$handlers.splice(i, 1);\n        kb.detach && kb.detach(this.$editor);\n        return true;\n    };\n\n    this.getKeyboardHandler = function() {\n        return this.$handlers[this.$handlers.length - 1];\n    };\n    \n    this.getStatusText = function() {\n        var data = this.$data;\n        var editor = data.editor;\n        return this.$handlers.map(function(h) {\n            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n        }).filter(Boolean).join(\" \");\n    };\n\n    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {\n        var toExecute;\n        var success = false;\n        var commands = this.$editor.commands;\n\n        for (var i = this.$handlers.length; i--;) {\n            toExecute = this.$handlers[i].handleKeyboard(\n                this.$data, hashId, keyString, keyCode, e\n            );\n            if (!toExecute || !toExecute.command)\n                continue;\n            if (toExecute.command == \"null\") {\n                success = true;\n            } else {\n                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);\n            }\n            if (success && e && hashId != -1 && \n                toExecute.passEvent != true && toExecute.command.passEvent != true\n            ) {\n                event.stopEvent(e);\n            }\n            if (success)\n                break;\n        }\n        \n        if (!success && hashId == -1) {\n            toExecute = {command: \"insertstring\"};\n            success = commands.exec(\"insertstring\", this.$editor, keyString);\n        }\n        \n        if (success && this.$editor._signal)\n            this.$editor._signal(\"keyboardActivity\", toExecute);\n        \n        return success;\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        var keyString = keyUtil.keyCodeToString(keyCode);\n        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n    };\n\n    this.onTextInput = function(text) {\n        this.$callKeyboardHandlers(-1, text);\n    };\n\n}).call(KeyBinding.prototype);\n\nexports.KeyBinding = KeyBinding;\n});\n\nace.define(\"ace/lib/bidiutil\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar ArabicAlefBetIntervalsBegine = ['\\u0621', '\\u0641'];\nvar ArabicAlefBetIntervalsEnd = ['\\u063A', '\\u064a'];\nvar dir = 0, hiLevel = 0;\nvar lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;\n\nvar impTab_LTR = [\t[\t0,\t\t3,\t\t0,\t\t1,\t\t0,\t\t0,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t1,\t\t2,\t\t2,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t0x11,\t\t2,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t1,\t\t0\t],\t[\t0,\t\t3,\t\t0x15,\t\t0x15,\t\t4,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t2,\t\t0\t]\n];\n\nvar impTab_RTL = [\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t1,\t\t0\t],\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t1,\t\t3,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t0x21,\t\t3,\t\t1,\t\t1\t]\n];\n\nvar LTR = 0, RTL = 1;\n\nvar L = 0;\nvar R = 1;\nvar EN = 2;\nvar AN = 3;\nvar ON = 4;\nvar B = 5;\nvar S = 6;\nvar AL = 7;\nvar WS = 8;\nvar CS = 9;\nvar ES = 10;\nvar ET = 11;\nvar NSM = 12;\nvar LRE = 13;\nvar RLE = 14;\nvar PDF = 15;\nvar LRO = 16;\nvar RLO = 17;\nvar BN = 18;\n\nvar UnicodeTBL00 = [\nBN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,\nWS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,\nEN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,\nBN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nCS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,\nET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON\n];\n\nvar UnicodeTBL20 = [\nWS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R\t,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,\nET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS\n];\n\nfunction _computeLevels(chars, levels, len, charTypes) {\n\tvar impTab = dir ? impTab_RTL : impTab_LTR\n\t\t, prevState = null, newClass = null, newLevel = null, newState = 0\n\t\t, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];\n\n\tif (!charTypes) {\n\t\tfor (i = 0, charTypes = []; i < len; i++) {\n\t\t\tcharTypes[i] = _getCharacterType(chars[i]);\n\t\t}\n\t}\n\thiLevel = dir;\n\tlastArabic = false;\n\thasUBAT_AL = false;\n\thasUBAT_B = false;\n\thasUBAT_S = false;\n\tfor (ix = 0; ix < len; ix++){\n\t\tprevState = newState;\n\t\tclasses[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);\n\t\tnewState = impTab[prevState][newClass];\n\t\taction = newState & 0xF0;\n\t\tnewState &= 0x0F;\n\t\tlevels[ix] = newLevel = impTab[newState][5];\n\t\tif (action > 0){\n\t\t\tif (action == 0x10){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = 1;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t} else {\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tcond = impTab[newState][6];\n\t\tif (cond){\n\t\t\tif(condPos == -1){\n\t\t\t\tcondPos = ix;\n\t\t\t}\n\t\t}else{\n\t\t\tif (condPos > -1){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = newLevel;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tif (charTypes[ix] == B){\n\t\t\tlevels[ix] = 0;\n\t\t}\n\t\thiLevel |= newLevel;\n\t}\n\tif (hasUBAT_S){\n\t\tfor(i = 0; i < len; i++){\n\t\t\tif(charTypes[i] == S){\n\t\t\t\tlevels[i] = dir;\n\t\t\t\tfor(var j = i - 1; j >= 0; j--){\n\t\t\t\t\tif(charTypes[j] == WS){\n\t\t\t\t\t\tlevels[j] = dir;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction _invertLevel(lev, levels, _array) {\n\tif (hiLevel < lev){\n\t\treturn;\n\t}\n\tif (lev == 1 && dir == RTL && !hasUBAT_B){\n\t\t_array.reverse();\n\t\treturn;\n\t}\n\tvar len = _array.length, start = 0, end, lo, hi, tmp;\n\twhile(start < len){\n\t\tif (levels[start] >= lev){\n\t\t\tend = start + 1;\n\t\twhile(end < len && levels[end] >= lev){\n\t\t\tend++;\n\t\t}\n\t\tfor(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){\n\t\t\ttmp = _array[lo];\n\t\t\t_array[lo] = _array[hi];\n\t\t\t_array[hi] = tmp;\n\t\t}\n\t\tstart = end;\n\t}\n\tstart++;\n\t}\n}\n\nfunction _getCharClass(chars, types, classes, ix) {\t\t\t\n\tvar cType = types[ix], wType, nType, len, i;\n\tswitch(cType){\n\t\tcase L:\n\t\tcase R:\n\t\t\tlastArabic = false;\n\t\tcase ON:\n\t\tcase AN:\n\t\t\treturn cType;\n\t\tcase EN:\n\t\t\treturn lastArabic ? AN : EN;\n\t\tcase AL:\n\t\t\tlastArabic = true;\n\t\t\thasUBAT_AL = true;\n\t\t\treturn R;\n\t\tcase WS:\n\t\t\treturn ON;\n\t\tcase CS:\n\t\t\tif (ix < 1 || (ix + 1) >= types.length ||\n\t\t\t\t((wType = classes[ix - 1]) != EN && wType != AN) ||\n\t\t\t\t((nType = types[ix + 1]) != EN && nType != AN)){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\tif (lastArabic){nType = AN;}\n\t\t\treturn nType == wType ? nType : ON;\n\t\tcase ES:\n\t\t\twType = ix > 0 ? classes[ix - 1] : B;\n\t\t\tif (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase ET:\n\t\t\tif (ix > 0 && classes[ix - 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\tif (lastArabic){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\ti = ix + 1;\n\t\t\tlen = types.length;\n\t\t\twhile (i < len && types[i] == ET){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len && types[i] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase NSM:\n\t\t\tlen = types.length;\n\t\t\ti = ix + 1;\n\t\t\twhile (i < len && types[i] == NSM){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len){\n\t\t\t\tvar c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;\n\t\t\t\t\n\t\t\t\twType = types[i];\n\t\t\t\tif (rtlCandidate && (wType == R || wType == AL)){\n\t\t\t\t\treturn R;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ix < 1 || (wType = types[ix - 1]) == B){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\treturn classes[ix - 1];\n\t\tcase B:\n\t\t\tlastArabic = false;\n\t\t\thasUBAT_B = true;\n\t\t\treturn dir;\n\t\tcase S:\n\t\t\thasUBAT_S = true;\n\t\t\treturn ON;\n\t\tcase LRE:\n\t\tcase RLE:\n\t\tcase LRO:\n\t\tcase RLO:\n\t\tcase PDF:\n\t\t\tlastArabic = false;\n\t\tcase BN:\n\t\t\treturn ON;\n\t}\n}\n\nfunction _getCharacterType( ch ) {\t\t\n\tvar uc = ch.charCodeAt(0), hi = uc >> 8;\n\t\n\tif (hi == 0) {\t\t\n\t\treturn ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);\n\t} else if (hi == 5) {\n\t\treturn (/[\\u0591-\\u05f4]/.test(ch) ? R : L);\n\t} else if (hi == 6) {\n\t\tif (/[\\u0610-\\u061a\\u064b-\\u065f\\u06d6-\\u06e4\\u06e7-\\u06ed]/.test(ch))\n\t\t\treturn NSM;\n\t\telse if (/[\\u0660-\\u0669\\u066b-\\u066c]/.test(ch))\n\t\t\treturn AN;\n\t\telse if (uc == 0x066A)\n\t\t\treturn ET;\n\t\telse if (/[\\u06f0-\\u06f9]/.test(ch))\n\t\t\treturn EN;\t\t\t\n\t\telse\n\t\t\treturn AL;\n\t} else if (hi == 0x20 && uc <= 0x205F) {\n\t\treturn UnicodeTBL20[uc & 0xFF];\n\t} else if (hi == 0xFE) {\n\t\treturn (uc >= 0xFE70 ? AL : ON);\n\t}\t\t\n\treturn ON;\t\n}\n\nfunction _isArabicDiacritics( ch ) {\n\treturn (ch >= '\\u064b' && ch <= '\\u0655');\n}\nexports.L = L;\nexports.R = R;\nexports.EN = EN;\nexports.ON_R = 3;\nexports.AN = 4;\nexports.R_H = 5;\nexports.B = 6;\nexports.RLE = 7;\n\nexports.DOT = \"\\xB7\";\nexports.doBidiReorder = function(text, textCharTypes, isRtl) {\n\tif (text.length < 2)\n\t\treturn {};\n\t\t\n\tvar chars = text.split(\"\"), logicalFromVisual = new Array(chars.length),\n\t\tbidiLevels = new Array(chars.length), levels = []; \n\n\tdir = isRtl ? RTL : LTR;\n\n\t_computeLevels(chars, levels, chars.length, textCharTypes);\n\n\tfor (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);\n\n\t_invertLevel(2, levels, logicalFromVisual);\n\t_invertLevel(1, levels, logicalFromVisual);\n\n\tfor (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width\n\t\tif (textCharTypes[i] === AN) {\n\t\t\tlevels[i] = exports.AN;\n\t\t} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) \n\t\t\t|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {\n\t\t\tlevels[i] = exports.ON_R;\n\t\t} else if ((i > 0 && chars[i - 1] === '\\u0644') && /\\u0622|\\u0623|\\u0625|\\u0627/.test(chars[i])) {\n\t\t\tlevels[i - 1] = levels[i] = exports.R_H;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (chars[chars.length - 1] === exports.DOT)\n\t\tlevels[chars.length - 1] = exports.B;\n\t\t\t\t\n\tif (chars[0] === '\\u202B')\n\t\tlevels[0] = exports.RLE;\n\t\t\t\t\n\tfor (var i = 0; i < logicalFromVisual.length; i++) {\n\t\tbidiLevels[i] = levels[logicalFromVisual[i]];\n\t}\n\n\treturn {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};\n};\nexports.hasBidiCharacters = function(text, textCharTypes){\n\tvar ret = false;\n\tfor (var i = 0; i < text.length; i++){\n\t\ttextCharTypes[i] = _getCharacterType(text.charAt(i));\n\t\tif (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))\n\t\t\tret = true;\n\t}\n\treturn ret;\n};\t\nexports.getVisualFromLogicalIdx = function(logIdx, rowMap) {\n\tfor (var i = 0; i < rowMap.logicalFromVisual.length; i++) {\n\t\tif (rowMap.logicalFromVisual[i] == logIdx)\n\t\t\treturn i;\n\t}\n\treturn 0;\n};\n\n});\n\nace.define(\"ace/bidihandler\",[\"require\",\"exports\",\"module\",\"ace/lib/bidiutil\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar bidiUtil = require(\"./lib/bidiutil\");\nvar lang = require(\"./lib/lang\");\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\nvar BidiHandler = function(session) {\n    this.session = session;\n    this.bidiMap = {};\n    this.currentRow = null;\n    this.bidiUtil = bidiUtil;\n    this.charWidths = [];\n    this.EOL = \"\\xAC\";\n    this.showInvisibles = true;\n    this.isRtlDir = false;\n    this.$isRtl = false;\n    this.line = \"\";\n    this.wrapIndent = 0;\n    this.EOF = \"\\xB6\";\n    this.RLE = \"\\u202B\";\n    this.contentWidth = 0;\n    this.fontMetrics = null;\n    this.rtlLineOffset = 0;\n    this.wrapOffset = 0;\n    this.isMoveLeftOperation = false;\n    this.seenBidi = bidiRE.test(session.getValue());\n};\n\n(function() {\n    this.isBidiRow = function(screenRow, docRow, splitIndex) {\n        if (!this.seenBidi)\n            return false;\n        if (screenRow !== this.currentRow) {\n            this.currentRow = screenRow;\n            this.updateRowLine(docRow, splitIndex);\n            this.updateBidiMap();\n        }\n        return this.bidiMap.bidiLevels;\n    };\n\n    this.onChange = function(delta) {\n        if (!this.seenBidi) {\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\n                this.seenBidi = true;\n                this.currentRow = null;\n            }\n        } \n        else {\n            this.currentRow = null;\n        }\n    };\n\n    this.getDocumentRow = function() {\n        var docRow = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            if (index >= 0)\n                docRow = this.session.$docRowCache[index];\n        }\n\n        return docRow;\n    };\n\n    this.getSplitIndex = function() {\n        var splitIndex = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            while (this.currentRow - splitIndex > 0) {\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\n                if (currentIndex !== prevIndex)\n                    break;\n\n                prevIndex = currentIndex;\n                splitIndex++;\n            }\n        } else {\n            splitIndex = this.currentRow;\n        }\n\n        return splitIndex;\n    };\n\n    this.updateRowLine = function(docRow, splitIndex) {\n        if (docRow === undefined)\n            docRow = this.getDocumentRow();\n            \n        var isLastRow = (docRow === this.session.getLength() - 1),\n            endOfLine = isLastRow ? this.EOF : this.EOL;\n\n        this.wrapIndent = 0;\n        this.line = this.session.getLine(docRow);\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\n        if (this.session.$useWrapMode) {\n            var splits = this.session.$wrapData[docRow];\n            if (splits) {\n                if (splitIndex === undefined)\n                    splitIndex = this.getSplitIndex();\n\n                if(splitIndex > 0 && splits.length) {\n                    this.wrapIndent = splits.indent;\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\n                    this.line = (splitIndex < splits.length) ?\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\n                            this.line.substring(splits[splits.length - 1]);\n                } else {\n                    this.line = this.line.substring(0, splits[splitIndex]);\n                }\n            }\n            if (splitIndex == splits.length)\n                this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\n        } else {\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\n        }\n        var session = this.session, shift = 0, size;\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function(ch, i){\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\n                shift += size - 1;\n                return lang.stringRepeat(bidiUtil.DOT, size);\n            }\n            return ch;\n        });\n\n        if (this.isRtlDir) {\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\n        }\n    };\n    \n    this.updateBidiMap = function() {\n        var textCharTypes = [];\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\n             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\n        } else {\n            this.bidiMap = {};\n        }\n    };\n    this.markAsDirty = function() {\n        this.currentRow = null;\n    };\n    this.updateCharacterWidths = function(fontMetrics) {\n        if (this.characterWidth === fontMetrics.$characterSize.width)\n            return;\n\n        this.fontMetrics = fontMetrics;\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\n\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\n\n        this.currentRow = null;\n    };\n\n    this.setShowInvisibles = function(showInvisibles) {\n        this.showInvisibles = showInvisibles;\n        this.currentRow = null;\n    };\n\n    this.setEolChar = function(eolChar) {\n        this.EOL = eolChar; \n    };\n\n    this.setContentWidth = function(width) {\n        this.contentWidth = width;\n    };\n\n    this.isRtlLine = function(row) {\n        if (this.$isRtl) return true;\n        if (row != undefined)\n            return (this.session.getLine(row).charAt(0) == this.RLE);\n        else\n            return this.isRtlDir; \n    };\n\n    this.setRtlDirection = function(editor, isRtlDir) {\n        var cursor = editor.getCursorPosition(); \n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\n                editor.session.doc.removeInLine(row, 0, 1);\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\n                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);\n        }\n    };\n    this.getPosLeft = function(col) {\n        col -= this.wrapIndent;\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),\n            levels = this.bidiMap.bidiLevels, left = 0;\n\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\n            visualIdx++;\n            \n        for (var i = 0; i < visualIdx; i++) {\n            left += this.charWidths[levels[i]];\n        }\n\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\n            left += this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        if (this.isRtlDir)\n            left += this.rtlLineOffset;\n\n        return left;\n    };\n    this.getSelections = function(startCol, endCol) {\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,\n            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,\n                isSelected = false, isSelectedPrev = false, selectionStart = 0;\n            \n        if (this.wrapIndent)\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\n            logIdx = map.logicalFromVisual[visIdx];\n            level = levels[visIdx];\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\n            if (isSelected && !isSelectedPrev) {\n                selectionStart = offset;\n            } else if (!isSelected && isSelectedPrev) {\n                selections.push({left: selectionStart, width: offset - selectionStart});\n            }\n            offset += this.charWidths[level];\n            isSelectedPrev = isSelected;\n        }\n\n        if (isSelected && (visIdx === levels.length)) {\n            selections.push({left: selectionStart, width: offset - selectionStart});\n        }\n\n        if(this.isRtlDir) {\n            for (var i = 0; i < selections.length; i++) {\n                selections[i].left += this.rtlLineOffset;\n            }\n        }\n        return selections;\n    };\n    this.offsetToCol = function(posX) {\n        if(this.isRtlDir)\n            posX -= this.rtlLineOffset;\n\n        var logicalIdx = 0, posX = Math.max(posX, 0),\n            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,\n                charWidth = this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n    \n        while(posX > offset + charWidth/2) {\n            offset += charWidth;\n            if(visualIdx === levels.length - 1) {\n                charWidth = 0;\n                break;\n            }\n            charWidth = this.charWidths[levels[++visualIdx]];\n        }\n    \n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){\n            if(posX < offset)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n\n        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\n                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);\n\n        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\n                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\n        } else {\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n\n        if (logicalIdx === 0 && this.isRtlDir)\n            logicalIdx++;\n\n        return (logicalIdx + this.wrapIndent);\n    };\n\n}).call(BidiHandler.prototype);\n\nexports.BidiHandler = BidiHandler;\n});\n\nace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Selection = function(session) {\n    this.session = session;\n    this.doc = session.getDocument();\n\n    this.clearSelection();\n    this.cursor = this.lead = this.doc.createAnchor(0, 0);\n    this.anchor = this.doc.createAnchor(0, 0);\n    this.$silent = false;\n\n    var self = this;\n    this.cursor.on(\"change\", function(e) {\n        self.$cursorChanged = true;\n        if (!self.$silent)\n            self._emit(\"changeCursor\");\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n            self.$desiredColumn = null;\n    });\n\n    this.anchor.on(\"change\", function() {\n        self.$anchorChanged = true;\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n    });\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.isEmpty = function() {\n        return this.$isEmpty || (\n            this.anchor.row == this.lead.row &&\n            this.anchor.column == this.lead.column\n        );\n    };\n    this.isMultiLine = function() {\n        return !this.$isEmpty && this.anchor.row != this.cursor.row;\n    };\n    this.getCursor = function() {\n        return this.lead.getPosition();\n    };\n    this.setSelectionAnchor = function(row, column) {\n        this.$isEmpty = false;\n        this.anchor.setPosition(row, column);\n    };\n    this.getAnchor = \n    this.getSelectionAnchor = function() {\n        if (this.$isEmpty)\n            return this.getSelectionLead();\n        \n        return this.anchor.getPosition();\n    };\n    this.getSelectionLead = function() {\n        return this.lead.getPosition();\n    };\n    this.isBackwards = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n    };\n    this.getRange = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n\n        if (this.$isEmpty)\n            return Range.fromPoints(lead, lead);\n\n        return this.isBackwards()\n            ? Range.fromPoints(lead, anchor)\n            : Range.fromPoints(anchor, lead);\n    };\n    this.clearSelection = function() {\n        if (!this.$isEmpty) {\n            this.$isEmpty = true;\n            this._emit(\"changeSelection\");\n        }\n    };\n    this.selectAll = function() {\n        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);\n    };\n    this.setRange =\n    this.setSelectionRange = function(range, reverse) {\n        var start = reverse ? range.end : range.start;\n        var end = reverse ? range.start : range.end;\n        this.$setSelection(start.row, start.column, end.row, end.column);\n    };\n\n    this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {\n        var wasEmpty = this.$isEmpty;\n        var wasMultiselect = this.inMultiSelectMode;\n        this.$silent = true;\n        this.$cursorChanged = this.$anchorChanged = false;\n        this.anchor.setPosition(anchorRow, anchorColumn);\n        this.cursor.setPosition(cursorRow, cursorColumn);\n        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);\n        this.$silent = false;\n        if (this.$cursorChanged)\n            this._emit(\"changeCursor\");\n        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)\n            this._emit(\"changeSelection\");\n    };\n\n    this.$moveSelection = function(mover) {\n        var lead = this.lead;\n        if (this.$isEmpty)\n            this.setSelectionAnchor(lead.row, lead.column);\n\n        mover.call(this);\n    };\n    this.selectTo = function(row, column) {\n        this.$moveSelection(function() {\n            this.moveCursorTo(row, column);\n        });\n    };\n    this.selectToPosition = function(pos) {\n        this.$moveSelection(function() {\n            this.moveCursorToPosition(pos);\n        });\n    };\n    this.moveTo = function(row, column) {\n        this.clearSelection();\n        this.moveCursorTo(row, column);\n    };\n    this.moveToPosition = function(pos) {\n        this.clearSelection();\n        this.moveCursorToPosition(pos);\n    };\n    this.selectUp = function() {\n        this.$moveSelection(this.moveCursorUp);\n    };\n    this.selectDown = function() {\n        this.$moveSelection(this.moveCursorDown);\n    };\n    this.selectRight = function() {\n        this.$moveSelection(this.moveCursorRight);\n    };\n    this.selectLeft = function() {\n        this.$moveSelection(this.moveCursorLeft);\n    };\n    this.selectLineStart = function() {\n        this.$moveSelection(this.moveCursorLineStart);\n    };\n    this.selectLineEnd = function() {\n        this.$moveSelection(this.moveCursorLineEnd);\n    };\n    this.selectFileEnd = function() {\n        this.$moveSelection(this.moveCursorFileEnd);\n    };\n    this.selectFileStart = function() {\n        this.$moveSelection(this.moveCursorFileStart);\n    };\n    this.selectWordRight = function() {\n        this.$moveSelection(this.moveCursorWordRight);\n    };\n    this.selectWordLeft = function() {\n        this.$moveSelection(this.moveCursorWordLeft);\n    };\n    this.getWordRange = function(row, column) {\n        if (typeof column == \"undefined\") {\n            var cursor = row || this.lead;\n            row = cursor.row;\n            column = cursor.column;\n        }\n        return this.session.getWordRange(row, column);\n    };\n    this.selectWord = function() {\n        this.setSelectionRange(this.getWordRange());\n    };\n    this.selectAWord = function() {\n        var cursor = this.getCursor();\n        var range = this.session.getAWordRange(cursor.row, cursor.column);\n        this.setSelectionRange(range);\n    };\n\n    this.getLineRange = function(row, excludeLastChar) {\n        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n        var rowEnd;\n\n        var foldLine = this.session.getFoldLine(rowStart);\n        if (foldLine) {\n            rowStart = foldLine.start.row;\n            rowEnd = foldLine.end.row;\n        } else {\n            rowEnd = rowStart;\n        }\n        if (excludeLastChar === true)\n            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n        else\n            return new Range(rowStart, 0, rowEnd + 1, 0);\n    };\n    this.selectLine = function() {\n        this.setSelectionRange(this.getLineRange());\n    };\n    this.moveCursorUp = function() {\n        this.moveCursorBy(-1, 0);\n    };\n    this.moveCursorDown = function() {\n        this.moveCursorBy(1, 0);\n    };\n    this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {\n        var start = cursor.column;\n        var end = cursor.column + tabSize;\n\n        if (direction < 0) {\n            start = cursor.column - tabSize;\n            end = cursor.column;\n        }\n        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(\" \").length-1 == tabSize;\n    };\n    this.moveCursorLeft = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n        } else if (cursor.column === 0) {\n            if (cursor.row > 0) {\n                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, -tabSize);\n            } else {\n                this.moveCursorBy(0, -1);\n            }\n        }\n    };\n    this.moveCursorRight = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n        }\n        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n            if (this.lead.row < this.doc.getLength() - 1) {\n                this.moveCursorTo(this.lead.row + 1, 0);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            var cursor = this.lead;\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, tabSize);\n            } else {\n                this.moveCursorBy(0, 1);\n            }\n        }\n    };\n    this.moveCursorLineStart = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var screenRow = this.session.documentToScreenRow(row, column);\n        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n        var beforeCursor = this.session.getDisplayLine(\n            row, null, firstColumnPosition.row,\n            firstColumnPosition.column\n        );\n\n        var leadingSpace = beforeCursor.match(/^\\s*/);\n        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n            firstColumnPosition.column += leadingSpace[0].length;\n        this.moveCursorToPosition(firstColumnPosition);\n    };\n    this.moveCursorLineEnd = function() {\n        var lead = this.lead;\n        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n        if (this.lead.column == lineEnd.column) {\n            var line = this.session.getLine(lineEnd.row);\n            if (lineEnd.column == line.length) {\n                var textEnd = line.search(/\\s+$/);\n                if (textEnd > 0)\n                    lineEnd.column = textEnd;\n            }\n        }\n\n        this.moveCursorTo(lineEnd.row, lineEnd.column);\n    };\n    this.moveCursorFileEnd = function() {\n        var row = this.doc.getLength() - 1;\n        var column = this.doc.getLine(row).length;\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorFileStart = function() {\n        this.moveCursorTo(0, 0);\n    };\n    this.moveCursorLongWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n            return;\n        }\n        if (this.session.nonTokenRe.exec(rightOfCursor)) {\n            column += this.session.nonTokenRe.lastIndex;\n            this.session.nonTokenRe.lastIndex = 0;\n            rightOfCursor = line.substring(column);\n        }\n        if (column >= line.length) {\n            this.moveCursorTo(row, line.length);\n            this.moveCursorRight();\n            if (row < this.doc.getLength() - 1)\n                this.moveCursorWordRight();\n            return;\n        }\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            column += this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorLongWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n            return;\n        }\n\n        var str = this.session.getFoldStringAt(row, column, -1);\n        if (str == null) {\n            str = this.doc.getLine(row).substring(0, column);\n        }\n\n        var leftOfCursor = lang.stringReverse(str);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        if (this.session.nonTokenRe.exec(leftOfCursor)) {\n            column -= this.session.nonTokenRe.lastIndex;\n            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n            this.session.nonTokenRe.lastIndex = 0;\n        }\n        if (column <= 0) {\n            this.moveCursorTo(row, 0);\n            this.moveCursorLeft();\n            if (row > 0)\n                this.moveCursorWordLeft();\n            return;\n        }\n        if (this.session.tokenRe.exec(leftOfCursor)) {\n            column -= this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n\n    this.$shortWordEndIndex = function(rightOfCursor) {\n        var index = 0, ch;\n        var whitespaceRe = /\\s/;\n        var tokenRe = this.session.tokenRe;\n\n        tokenRe.lastIndex = 0;\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            index = this.session.tokenRe.lastIndex;\n        } else {\n            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                index ++;\n\n            if (index < 1) {\n                tokenRe.lastIndex = 0;\n                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n                    tokenRe.lastIndex = 0;\n                    index ++;\n                    if (whitespaceRe.test(ch)) {\n                        if (index > 2) {\n                            index--;\n                            break;\n                        } else {\n                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                                index ++;\n                            if (index > 2)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        tokenRe.lastIndex = 0;\n\n        return index;\n    };\n\n    this.moveCursorShortWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold)\n            return this.moveCursorTo(fold.end.row, fold.end.column);\n\n        if (column == line.length) {\n            var l = this.doc.getLength();\n            do {\n                row++;\n                rightOfCursor = this.doc.getLine(row);\n            } while (row < l && /^\\s*$/.test(rightOfCursor));\n\n            if (!/^\\s+/.test(rightOfCursor))\n                rightOfCursor = \"\";\n            column = 0;\n        }\n\n        var index = this.$shortWordEndIndex(rightOfCursor);\n\n        this.moveCursorTo(row, column + index);\n    };\n\n    this.moveCursorShortWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1))\n            return this.moveCursorTo(fold.start.row, fold.start.column);\n\n        var line = this.session.getLine(row).substring(0, column);\n        if (column === 0) {\n            do {\n                row--;\n                line = this.doc.getLine(row);\n            } while (row > 0 && /^\\s*$/.test(line));\n\n            column = line.length;\n            if (!/\\s+$/.test(line))\n                line = \"\";\n        }\n\n        var leftOfCursor = lang.stringReverse(line);\n        var index = this.$shortWordEndIndex(leftOfCursor);\n\n        return this.moveCursorTo(row, column - index);\n    };\n\n    this.moveCursorWordRight = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordRight();\n        else\n            this.moveCursorShortWordRight();\n    };\n\n    this.moveCursorWordLeft = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordLeft();\n        else\n            this.moveCursorShortWordLeft();\n    };\n    this.moveCursorBy = function(rows, chars) {\n        var screenPos = this.session.documentToScreenPosition(\n            this.lead.row,\n            this.lead.column\n        );\n\n        var offsetX;\n\n        if (chars === 0) {\n            if (rows !== 0) {\n                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {\n                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);\n                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);\n                } else {\n                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];\n                }\n            }\n\n            if (this.$desiredColumn)\n                screenPos.column = this.$desiredColumn;\n            else\n                this.$desiredColumn = screenPos.column;\n        }\n\n        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);\n        \n        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {\n                if (docPos.row > 0 || rows > 0)\n                    docPos.row++;\n            }\n        }\n        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n    };\n    this.moveCursorToPosition = function(position) {\n        this.moveCursorTo(position.row, position.column);\n    };\n    this.moveCursorTo = function(row, column, keepDesiredColumn) {\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            row = fold.start.row;\n            column = fold.start.column;\n        }\n\n        this.$keepDesiredColumnOnChange = true;\n        var line = this.session.getLine(row);\n        if (/[\\uDC00-\\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {\n            if (this.lead.row == row && this.lead.column == column + 1)\n                column = column - 1;\n            else\n                column = column + 1;\n        }\n        this.lead.setPosition(row, column);\n        this.$keepDesiredColumnOnChange = false;\n\n        if (!keepDesiredColumn)\n            this.$desiredColumn = null;\n    };\n    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {\n        var pos = this.session.screenToDocumentPosition(row, column);\n        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n    };\n    this.detach = function() {\n        this.lead.detach();\n        this.anchor.detach();\n        this.session = this.doc = null;\n    };\n\n    this.fromOrientedRange = function(range) {\n        this.setSelectionRange(range, range.cursor == range.start);\n        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n    };\n\n    this.toOrientedRange = function(range) {\n        var r = this.getRange();\n        if (range) {\n            range.start.column = r.start.column;\n            range.start.row = r.start.row;\n            range.end.column = r.end.column;\n            range.end.row = r.end.row;\n        } else {\n            range = r;\n        }\n\n        range.cursor = this.isBackwards() ? range.start : range.end;\n        range.desiredColumn = this.$desiredColumn;\n        return range;\n    };\n    this.getRangeOfMovements = function(func) {\n        var start = this.getCursor();\n        try {\n            func(this);\n            var end = this.getCursor();\n            return Range.fromPoints(start, end);\n        } catch(e) {\n            return Range.fromPoints(start, start);\n        } finally {\n            this.moveCursorToPosition(start);\n        }\n    };\n\n    this.toJSON = function() {\n        if (this.rangeCount) {\n            var data = this.ranges.map(function(r) {\n                var r1 = r.clone();\n                r1.isBackwards = r.cursor == r.start;\n                return r1;\n            });\n        } else {\n            var data = this.getRange();\n            data.isBackwards = this.isBackwards();\n        }\n        return data;\n    };\n\n    this.fromJSON = function(data) {\n        if (data.start == undefined) {\n            if (this.rangeList && data.length > 1) {\n                this.toSingleRange(data[0]);\n                for (var i = data.length; i--; ) {\n                    var r = Range.fromPoints(data[i].start, data[i].end);\n                    if (data[i].isBackwards)\n                        r.cursor = r.start;\n                    this.addRange(r, true);\n                }\n                return;\n            } else {\n                data = data[0];\n            }\n        }\n        if (this.rangeList)\n            this.toSingleRange(data);\n        this.setSelectionRange(data, data.isBackwards);\n    };\n\n    this.isEqual = function(data) {\n        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n            return false;\n        if (!data.length || !this.ranges)\n            return this.getRange().isEqual(data);\n\n        for (var i = this.ranges.length; i--; ) {\n            if (!this.ranges[i].isEqual(data[i]))\n                return false;\n        }\n        return true;\n    };\n\n}).call(Selection.prototype);\n\nexports.Selection = Selection;\n});\n\nace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar config = require(\"./config\");\nvar MAX_TOKEN_COUNT = 2000;\nvar Tokenizer = function(rules) {\n    this.states = rules;\n\n    this.regExps = {};\n    this.matchMappings = {};\n    for (var key in this.states) {\n        var state = this.states[key];\n        var ruleRegExps = [];\n        var matchTotal = 0;\n        var mapping = this.matchMappings[key] = {defaultToken: \"text\"};\n        var flag = \"g\";\n\n        var splitterRurles = [];\n        for (var i = 0; i < state.length; i++) {\n            var rule = state[i];\n            if (rule.defaultToken)\n                mapping.defaultToken = rule.defaultToken;\n            if (rule.caseInsensitive)\n                flag = \"gi\";\n            if (rule.regex == null)\n                continue;\n\n            if (rule.regex instanceof RegExp)\n                rule.regex = rule.regex.toString().slice(1, -1);\n            var adjustedregex = rule.regex;\n            var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n            if (Array.isArray(rule.token)) {\n                if (rule.token.length == 1 || matchcount == 1) {\n                    rule.token = rule.token[0];\n                } else if (matchcount - 1 != rule.token.length) {\n                    this.reportError(\"number of classes and regexp groups doesn't match\", { \n                        rule: rule,\n                        groupCount: matchcount - 1\n                    });\n                    rule.token = rule.token[0];\n                } else {\n                    rule.tokenArray = rule.token;\n                    rule.token = null;\n                    rule.onMatch = this.$arrayTokens;\n                }\n            } else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                if (matchcount > 1)\n                    rule.onMatch = this.$applyToken;\n                else\n                    rule.onMatch = rule.token;\n            }\n\n            if (matchcount > 1) {\n                if (/\\\\\\d/.test(rule.regex)) {\n                    adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function(match, digit) {\n                        return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                    });\n                } else {\n                    matchcount = 1;\n                    adjustedregex = this.removeCapturingGroups(rule.regex);\n                }\n                if (!rule.splitRegex && typeof rule.token != \"string\")\n                    splitterRurles.push(rule); // flag will be known only at the very end\n            }\n\n            mapping[matchTotal] = i;\n            matchTotal += matchcount;\n\n            ruleRegExps.push(adjustedregex);\n            if (!rule.onMatch)\n                rule.onMatch = null;\n        }\n        \n        if (!ruleRegExps.length) {\n            mapping[0] = 0;\n            ruleRegExps.push(\"$\");\n        }\n        \n        splitterRurles.forEach(function(rule) {\n            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n        }, this);\n\n        this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n    }\n};\n\n(function() {\n    this.$setMaxTokenCount = function(m) {\n        MAX_TOKEN_COUNT = m | 0;\n    };\n    \n    this.$applyToken = function(str) {\n        var values = this.splitRegex.exec(str).slice(1);\n        var types = this.token.apply(this, values);\n        if (typeof types === \"string\")\n            return [{type: types, value: str}];\n\n        var tokens = [];\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i]\n                };\n        }\n        return tokens;\n    };\n\n    this.$arrayTokens = function(str) {\n        if (!str)\n            return [];\n        var values = this.splitRegex.exec(str);\n        if (!values)\n            return \"text\";\n        var tokens = [];\n        var types = this.tokenArray;\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i + 1])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i + 1]\n                };\n        }\n        return tokens;\n    };\n\n    this.removeCapturingGroups = function(src) {\n        var r = src.replace(\n            /\\\\.|\\[(?:\\\\.|[^\\\\\\]])*|\\(\\?[:=!]|(\\()/g,\n            function(x, y) {return y ? \"(?:\" : x;}\n        );\n        return r;\n    };\n\n    this.createSplitterRegexp = function(src, flag) {\n        if (src.indexOf(\"(?=\") != -1) {\n            var stack = 0;\n            var inChClass = false;\n            var lastCapture = {};\n            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function(\n                m, esc, parenOpen, parenClose, square, index\n            ) {\n                if (inChClass) {\n                    inChClass = square != \"]\";\n                } else if (square) {\n                    inChClass = true;\n                } else if (parenClose) {\n                    if (stack == lastCapture.stack) {\n                        lastCapture.end = index+1;\n                        lastCapture.stack = -1;\n                    }\n                    stack--;\n                } else if (parenOpen) {\n                    stack++;\n                    if (parenOpen.length != 1) {\n                        lastCapture.stack = stack;\n                        lastCapture.start = index;\n                    }\n                }\n                return m;\n            });\n\n            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n        }\n        if (src.charAt(0) != \"^\") src = \"^\" + src;\n        if (src.charAt(src.length - 1) != \"$\") src += \"$\";\n        \n        return new RegExp(src, (flag||\"\").replace(\"g\", \"\"));\n    };\n    this.getLineTokens = function(line, startState) {\n        if (startState && typeof startState != \"string\") {\n            var stack = startState.slice(0);\n            startState = stack[0];\n            if (startState === \"#tmp\") {\n                stack.shift();\n                startState = stack.shift();\n            }\n        } else\n            var stack = [];\n\n        var currentState = startState || \"start\";\n        var state = this.states[currentState];\n        if (!state) {\n            currentState = \"start\";\n            state = this.states[currentState];\n        }\n        var mapping = this.matchMappings[currentState];\n        var re = this.regExps[currentState];\n        re.lastIndex = 0;\n\n        var match, tokens = [];\n        var lastIndex = 0;\n        var matchAttempts = 0;\n\n        var token = {type: null, value: \"\"};\n\n        while (match = re.exec(line)) {\n            var type = mapping.defaultToken;\n            var rule = null;\n            var value = match[0];\n            var index = re.lastIndex;\n\n            if (index - value.length > lastIndex) {\n                var skipped = line.substring(lastIndex, index - value.length);\n                if (token.type == type) {\n                    token.value += skipped;\n                } else {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: type, value: skipped};\n                }\n            }\n\n            for (var i = 0; i < match.length-2; i++) {\n                if (match[i + 1] === undefined)\n                    continue;\n\n                rule = state[mapping[i]];\n\n                if (rule.onMatch)\n                    type = rule.onMatch(value, currentState, stack, line);\n                else\n                    type = rule.token;\n\n                if (rule.next) {\n                    if (typeof rule.next == \"string\") {\n                        currentState = rule.next;\n                    } else {\n                        currentState = rule.next(currentState, stack);\n                    }\n                    \n                    state = this.states[currentState];\n                    if (!state) {\n                        this.reportError(\"state doesn't exist\", currentState);\n                        currentState = \"start\";\n                        state = this.states[currentState];\n                    }\n                    mapping = this.matchMappings[currentState];\n                    lastIndex = index;\n                    re = this.regExps[currentState];\n                    re.lastIndex = index;\n                }\n                if (rule.consumeLineEnd)\n                    lastIndex = index;\n                break;\n            }\n\n            if (value) {\n                if (typeof type === \"string\") {\n                    if ((!rule || rule.merge !== false) && token.type === type) {\n                        token.value += value;\n                    } else {\n                        if (token.type)\n                            tokens.push(token);\n                        token = {type: type, value: value};\n                    }\n                } else if (type) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: null, value: \"\"};\n                    for (var i = 0; i < type.length; i++)\n                        tokens.push(type[i]);\n                }\n            }\n\n            if (lastIndex == line.length)\n                break;\n\n            lastIndex = index;\n\n            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n                if (matchAttempts > 2 * line.length) {\n                    this.reportError(\"infinite loop with in ace tokenizer\", {\n                        startState: startState,\n                        line: line\n                    });\n                }\n                while (lastIndex < line.length) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {\n                        value: line.substring(lastIndex, lastIndex += 2000),\n                        type: \"overflow\"\n                    };\n                }\n                currentState = \"start\";\n                stack = [];\n                break;\n            }\n        }\n\n        if (token.type)\n            tokens.push(token);\n        \n        if (stack.length > 1) {\n            if (stack[0] !== currentState)\n                stack.unshift(\"#tmp\", currentState);\n        }\n        return {\n            tokens : tokens,\n            state : stack.length ? stack : currentState\n        };\n    };\n    \n    this.reportError = config.reportError;\n    \n}).call(Tokenizer.prototype);\n\nexports.Tokenizer = Tokenizer;\n});\n\nace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\n\nvar TextHighlightRules = function() {\n\n    this.$rules = {\n        \"start\" : [{\n            token : \"empty_line\",\n            regex : '^$'\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n};\n\n(function() {\n\n    this.addRules = function(rules, prefix) {\n        if (!prefix) {\n            for (var key in rules)\n                this.$rules[key] = rules[key];\n            return;\n        }\n        for (var key in rules) {\n            var state = rules[key];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.next || rule.onMatch) {\n                    if (typeof rule.next == \"string\") {\n                        if (rule.next.indexOf(prefix) !== 0)\n                            rule.next = prefix + rule.next;\n                    }\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n                        rule.nextState = prefix + rule.nextState;\n                }\n            }\n            this.$rules[prefix + key] = state;\n        }\n    };\n\n    this.getRules = function() {\n        return this.$rules;\n    };\n\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n        var embedRules = typeof HighlightRules == \"function\"\n            ? new HighlightRules().getRules()\n            : HighlightRules;\n        if (states) {\n            for (var i = 0; i < states.length; i++)\n                states[i] = prefix + states[i];\n        } else {\n            states = [];\n            for (var key in embedRules)\n                states.push(prefix + key);\n        }\n\n        this.addRules(embedRules, prefix);\n\n        if (escapeRules) {\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n            for (var i = 0; i < states.length; i++)\n                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));\n        }\n\n        if (!this.$embeds)\n            this.$embeds = [];\n        this.$embeds.push(prefix);\n    };\n\n    this.getEmbeds = function() {\n        return this.$embeds;\n    };\n\n    var pushState = function(currentState, stack) {\n        if (currentState != \"start\" || stack.length)\n            stack.unshift(this.nextState, currentState);\n        return this.nextState;\n    };\n    var popState = function(currentState, stack) {\n        stack.shift();\n        return stack.shift() || \"start\";\n    };\n\n    this.normalizeRules = function() {\n        var id = 0;\n        var rules = this.$rules;\n        function processState(key) {\n            var state = rules[key];\n            state.processed = true;\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                var toInsert = null;\n                if (Array.isArray(rule)) {\n                    toInsert = rule;\n                    rule = {};\n                }\n                if (!rule.regex && rule.start) {\n                    rule.regex = rule.start;\n                    if (!rule.next)\n                        rule.next = [];\n                    rule.next.push({\n                        defaultToken: rule.token\n                    }, {\n                        token: rule.token + \".end\",\n                        regex: rule.end || rule.start,\n                        next: \"pop\"\n                    });\n                    rule.token = rule.token + \".start\";\n                    rule.push = true;\n                }\n                var next = rule.next || rule.push;\n                if (next && Array.isArray(next)) {\n                    var stateName = rule.stateName;\n                    if (!stateName)  {\n                        stateName = rule.token;\n                        if (typeof stateName != \"string\")\n                            stateName = stateName[0] || \"\";\n                        if (rules[stateName])\n                            stateName += id++;\n                    }\n                    rules[stateName] = next;\n                    rule.next = stateName;\n                    processState(stateName);\n                } else if (next == \"pop\") {\n                    rule.next = popState;\n                }\n\n                if (rule.push) {\n                    rule.nextState = rule.next || rule.push;\n                    rule.next = pushState;\n                    delete rule.push;\n                }\n\n                if (rule.rules) {\n                    for (var r in rule.rules) {\n                        if (rules[r]) {\n                            if (rules[r].push)\n                                rules[r].push.apply(rules[r], rule.rules[r]);\n                        } else {\n                            rules[r] = rule.rules[r];\n                        }\n                    }\n                }\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\n                if (includeName) {\n                    if (Array.isArray(includeName))\n                        toInsert = includeName.map(function(x) { return rules[x]; });\n                    else\n                        toInsert = rules[includeName];\n                }\n\n                if (toInsert) {\n                    var args = [i, 1].concat(toInsert);\n                    if (rule.noEscape)\n                        args = args.filter(function(x) {return !x.next;});\n                    state.splice.apply(state, args);\n                    i--;\n                }\n                \n                if (rule.keywordMap) {\n                    rule.token = this.createKeywordMapper(\n                        rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive\n                    );\n                    delete rule.defaultToken;\n                }\n            }\n        }\n        Object.keys(rules).forEach(processState, this);\n    };\n\n    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {\n        var keywords = Object.create(null);\n        Object.keys(map).forEach(function(className) {\n            var a = map[className];\n            if (ignoreCase)\n                a = a.toLowerCase();\n            var list = a.split(splitChar || \"|\");\n            for (var i = list.length; i--; )\n                keywords[list[i]] = className;\n        });\n        if (Object.getPrototypeOf(keywords)) {\n            keywords.__proto__ = null;\n        }\n        this.$keywordList = Object.keys(keywords);\n        map = null;\n        return ignoreCase\n            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }\n            : function(value) {return keywords[value] || defaultToken; };\n    };\n\n    this.getKeywords = function() {\n        return this.$keywords;\n    };\n\n}).call(TextHighlightRules.prototype);\n\nexports.TextHighlightRules = TextHighlightRules;\n});\n\nace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar Behaviour = function() {\n   this.$behaviours = {};\n};\n\n(function () {\n\n    this.add = function (name, action, callback) {\n        switch (undefined) {\n          case this.$behaviours:\n              this.$behaviours = {};\n          case this.$behaviours[name]:\n              this.$behaviours[name] = {};\n        }\n        this.$behaviours[name][action] = callback;\n    };\n    \n    this.addBehaviours = function (behaviours) {\n        for (var key in behaviours) {\n            for (var action in behaviours[key]) {\n                this.add(key, action, behaviours[key][action]);\n            }\n        }\n    };\n    \n    this.remove = function (name) {\n        if (this.$behaviours && this.$behaviours[name]) {\n            delete this.$behaviours[name];\n        }\n    };\n    \n    this.inherit = function (mode, filter) {\n        if (typeof mode === \"function\") {\n            var behaviours = new mode().getBehaviours(filter);\n        } else {\n            var behaviours = mode.getBehaviours(filter);\n        }\n        this.addBehaviours(behaviours);\n    };\n    \n    this.getBehaviours = function (filter) {\n        if (!filter) {\n            return this.$behaviours;\n        } else {\n            var ret = {};\n            for (var i = 0; i < filter.length; i++) {\n                if (this.$behaviours[filter[i]]) {\n                    ret[filter[i]] = this.$behaviours[filter[i]];\n                }\n            }\n            return ret;\n        }\n    };\n\n}).call(Behaviour.prototype);\n\nexports.Behaviour = Behaviour;\n});\n\nace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar TokenIterator = function(session, initialRow, initialColumn) {\n    this.$session = session;\n    this.$row = initialRow;\n    this.$rowTokens = session.getTokens(initialRow);\n\n    var token = session.getTokenAt(initialRow, initialColumn);\n    this.$tokenIndex = token ? token.index : -1;\n};\n\n(function() { \n    this.stepBackward = function() {\n        this.$tokenIndex -= 1;\n        \n        while (this.$tokenIndex < 0) {\n            this.$row -= 1;\n            if (this.$row < 0) {\n                this.$row = 0;\n                return null;\n            }\n                \n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = this.$rowTokens.length - 1;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };   \n    this.stepForward = function() {\n        this.$tokenIndex += 1;\n        var rowCount;\n        while (this.$tokenIndex >= this.$rowTokens.length) {\n            this.$row += 1;\n            if (!rowCount)\n                rowCount = this.$session.getLength();\n            if (this.$row >= rowCount) {\n                this.$row = rowCount - 1;\n                return null;\n            }\n\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = 0;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentToken = function () {\n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentTokenRow = function () {\n        return this.$row;\n    };     \n    this.getCurrentTokenColumn = function() {\n        var rowTokens = this.$rowTokens;\n        var tokenIndex = this.$tokenIndex;\n        var column = rowTokens[tokenIndex].start;\n        if (column !== undefined)\n            return column;\n            \n        column = 0;\n        while (tokenIndex > 0) {\n            tokenIndex -= 1;\n            column += rowTokens[tokenIndex].value.length;\n        }\n        \n        return column;  \n    };\n    this.getCurrentTokenPosition = function() {\n        return {row: this.$row, column: this.getCurrentTokenColumn()};\n    };\n    this.getCurrentTokenRange = function() {\n        var token = this.$rowTokens[this.$tokenIndex];\n        var column = this.getCurrentTokenColumn();\n        return new Range(this.$row, column, this.$row, column + token.value.length);\n    };\n    \n}).call(TokenIterator.prototype);\n\nexports.TokenIterator = TokenIterator;\n});\n\nace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\n\nvar SAFE_INSERT_IN_TOKENS =\n    [\"text\", \"paren.rparen\", \"punctuation.operator\"];\nvar SAFE_INSERT_BEFORE_TOKENS =\n    [\"text\", \"paren.rparen\", \"punctuation.operator\", \"comment\"];\n\nvar context;\nvar contextCache = {};\nvar defaultQuotes = {'\"' : '\"', \"'\" : \"'\"};\n\nvar initContext = function(editor) {\n    var id = -1;\n    if (editor.multiSelect) {\n        id = editor.selection.index;\n        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n            contextCache = {rangeCount: editor.multiSelect.rangeCount};\n    }\n    if (contextCache[id])\n        return context = contextCache[id];\n    context = contextCache[id] = {\n        autoInsertedBrackets: 0,\n        autoInsertedRow: -1,\n        autoInsertedLineEnd: \"\",\n        maybeInsertedBrackets: 0,\n        maybeInsertedRow: -1,\n        maybeInsertedLineStart: \"\",\n        maybeInsertedLineEnd: \"\"\n    };\n};\n\nvar getWrapped = function(selection, selected, opening, closing) {\n    var rowDiff = selection.end.row - selection.start.row;\n    return {\n        text: opening + selected + closing,\n        selection: [\n                0,\n                selection.start.column + 1,\n                rowDiff,\n                selection.end.column + (rowDiff ? 0 : 1)\n            ]\n    };\n};\n\nvar CstyleBehaviour = function(options) {\n    this.add(\"braces\", \"insertion\", function(state, action, editor, session, text) {\n        var cursor = editor.getCursorPosition();\n        var line = session.doc.getLine(cursor.row);\n        if (text == '{') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '{', '}');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {\n                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                    return {\n                        text: '{}',\n                        selection: [1, 1]\n                    };\n                } else {\n                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n                    return {\n                        text: '{',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == '}') {\n            initContext(editor);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == '}') {\n                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == \"\\n\" || text == \"\\r\\n\") {\n            initContext(editor);\n            var closing = \"\";\n            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n                CstyleBehaviour.clearMaybeInsertedClosing();\n            }\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === '}') {\n                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');\n                if (!openBracePos)\n                     return null;\n                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n            } else if (closing) {\n                var next_indent = this.$getIndent(line);\n            } else {\n                CstyleBehaviour.clearMaybeInsertedClosing();\n                return;\n            }\n            var indent = next_indent + session.getTabString();\n\n            return {\n                text: '\\n' + indent + '\\n' + next_indent + closing,\n                selection: [1, indent.length, 1, indent.length]\n            };\n        } else {\n            CstyleBehaviour.clearMaybeInsertedClosing();\n        }\n    });\n\n    this.add(\"braces\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '{') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.end.column, range.end.column + 1);\n            if (rightChar == '}') {\n                range.end.column++;\n                return range;\n            } else {\n                context.maybeInsertedBrackets--;\n            }\n        }\n    });\n\n    this.add(\"parens\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '(') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '(', ')');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n                return {\n                    text: '()',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ')') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ')') {\n                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"parens\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '(') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ')') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '[') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '[', ']');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n                return {\n                    text: '[]',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ']') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ']') {\n                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '[') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ']') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"insertion\", function(state, action, editor, session, text) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        if (text.length == 1 && quotes[text]) {\n            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) \n                return;\n            initContext(editor);\n            var quote = text;\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, quote, quote);\n            } else if (!selected) {\n                var cursor = editor.getCursorPosition();\n                var line = session.doc.getLine(cursor.row);\n                var leftChar = line.substring(cursor.column-1, cursor.column);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                \n                var token = session.getTokenAt(cursor.row, cursor.column);\n                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);\n                if (leftChar == \"\\\\\" && token && /escape/.test(token.type))\n                    return null;\n                \n                var stringBefore = token && /string|escape/.test(token.type);\n                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);\n                \n                var pair;\n                if (rightChar == quote) {\n                    pair = stringBefore !== stringAfter;\n                    if (pair && /string\\.end/.test(rightToken.type))\n                        pair = false;\n                } else {\n                    if (stringBefore && !stringAfter)\n                        return null; // wrap string with different quote\n                    if (stringBefore && stringAfter)\n                        return null; // do not pair quotes inside strings\n                    var wordRe = session.$mode.tokenRe;\n                    wordRe.lastIndex = 0;\n                    var isWordBefore = wordRe.test(leftChar);\n                    wordRe.lastIndex = 0;\n                    var isWordAfter = wordRe.test(leftChar);\n                    if (isWordBefore || isWordAfter)\n                        return null; // before or after alphanumeric\n                    if (rightChar && !/[\\s;,.})\\]\\\\]/.test(rightChar))\n                        return null; // there is rightChar and it isn't closing\n                    pair = true;\n                }\n                return {\n                    text: pair ? quote + quote : \"\",\n                    selection: [1,1]\n                };\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n};\n\n    \nCstyleBehaviour.isSaneInsertion = function(editor, session) {\n    var cursor = editor.getCursorPosition();\n    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n            return false;\n    }\n    iterator.stepForward();\n    return iterator.getCurrentTokenRow() !== cursor.row ||\n        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n};\n\nCstyleBehaviour.$matchTokenType = function(token, types) {\n    return types.indexOf(token.type || token) > -1;\n};\n\nCstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))\n        context.autoInsertedBrackets = 0;\n    context.autoInsertedRow = cursor.row;\n    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n    context.autoInsertedBrackets++;\n};\n\nCstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isMaybeInsertedClosing(cursor, line))\n        context.maybeInsertedBrackets = 0;\n    context.maybeInsertedRow = cursor.row;\n    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n    context.maybeInsertedLineEnd = line.substr(cursor.column);\n    context.maybeInsertedBrackets++;\n};\n\nCstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {\n    return context.autoInsertedBrackets > 0 &&\n        cursor.row === context.autoInsertedRow &&\n        bracket === context.autoInsertedLineEnd[0] &&\n        line.substr(cursor.column) === context.autoInsertedLineEnd;\n};\n\nCstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {\n    return context.maybeInsertedBrackets > 0 &&\n        cursor.row === context.maybeInsertedRow &&\n        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n};\n\nCstyleBehaviour.popAutoInsertedClosing = function() {\n    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n    context.autoInsertedBrackets--;\n};\n\nCstyleBehaviour.clearMaybeInsertedClosing = function() {\n    if (context) {\n        context.maybeInsertedBrackets = 0;\n        context.maybeInsertedRow = -1;\n    }\n};\n\n\n\noop.inherits(CstyleBehaviour, Behaviour);\n\nexports.CstyleBehaviour = CstyleBehaviour;\n});\n\nace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];\n\nvar code = 0;\nvar str = [];\nfor (var i = 0; i < wordChars.length; i += 2) {\n    str.push(code += wordChars[i]);\n    if (wordChars[i + 1])\n        str.push(45, code += wordChars[i + 1]);\n}\n\nexports.wordChars = String.fromCharCode.apply(null, str);\n\n});\n\nace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar config = require(\"../config\");\n\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar unicode = require(\"../unicode\");\nvar lang = require(\"../lib/lang\");\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\nvar Mode = function() {\n    this.HighlightRules = TextHighlightRules;\n};\n\n(function() {\n    this.$defaultBehaviour = new CstyleBehaviour();\n\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\n\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\n\n    this.getTokenizer = function() {\n        if (!this.$tokenizer) {\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n        }\n        return this.$tokenizer;\n    };\n\n    this.lineCommentStart = \"\";\n    this.blockComment = \"\";\n\n    this.toggleCommentLines = function(state, session, startRow, endRow) {\n        var doc = session.doc;\n\n        var ignoreBlankLines = true;\n        var shouldRemove = true;\n        var minIndent = Infinity;\n        var tabSize = session.getTabSize();\n        var insertAtTabStop = false;\n\n        if (!this.lineCommentStart) {\n            if (!this.blockComment)\n                return false;\n            var lineCommentStart = this.blockComment.start;\n            var lineCommentEnd = this.blockComment.end;\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n\n            var comment = function(line, i) {\n                if (testRemove(line, i))\n                    return;\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);\n                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n\n            var uncomment = function(line, i) {\n                var m;\n                if (m = line.match(regexpEnd))\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\n                if (m = line.match(regexpStart))\n                    doc.removeInLine(i, m[1].length, m[0].length);\n            };\n\n            var testRemove = function(line, row) {\n                if (regexpStart.test(line))\n                    return true;\n                var tokens = session.getTokens(row);\n                for (var i = 0; i < tokens.length; i++) {\n                    if (tokens[i].type === \"comment\")\n                        return true;\n                }\n            };\n        } else {\n            if (Array.isArray(this.lineCommentStart)) {\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n                var lineCommentStart = this.lineCommentStart[0];\n            } else {\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n                var lineCommentStart = this.lineCommentStart;\n            }\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n            \n            insertAtTabStop = session.getUseSoftTabs();\n\n            var uncomment = function(line, i) {\n                var m = line.match(regexpStart);\n                if (!m) return;\n                var start = m[1].length, end = m[0].length;\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n                    end--;\n                doc.removeInLine(i, start, end);\n            };\n            var commentWithSpace = lineCommentStart + \" \";\n            var comment = function(line, i) {\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    if (shouldInsertSpace(line, minIndent, minIndent))\n                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);\n                    else\n                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n            var testRemove = function(line, i) {\n                return regexpStart.test(line);\n            };\n            \n            var shouldInsertSpace = function(line, before, after) {\n                var spaces = 0;\n                while (before-- && line.charAt(before) == \" \")\n                    spaces++;\n                if (spaces % tabSize != 0)\n                    return false;\n                var spaces = 0;\n                while (line.charAt(after++) == \" \")\n                    spaces++;\n                if (tabSize > 2)\n                    return spaces % tabSize != tabSize - 1;\n                else\n                    return spaces % tabSize == 0;\n            };\n        }\n\n        function iter(fun) {\n            for (var i = startRow; i <= endRow; i++)\n                fun(doc.getLine(i), i);\n        }\n\n\n        var minEmptyLength = Infinity;\n        iter(function(line, i) {\n            var indent = line.search(/\\S/);\n            if (indent !== -1) {\n                if (indent < minIndent)\n                    minIndent = indent;\n                if (shouldRemove && !testRemove(line, i))\n                    shouldRemove = false;\n            } else if (minEmptyLength > line.length) {\n                minEmptyLength = line.length;\n            }\n        });\n\n        if (minIndent == Infinity) {\n            minIndent = minEmptyLength;\n            ignoreBlankLines = false;\n            shouldRemove = false;\n        }\n\n        if (insertAtTabStop && minIndent % tabSize != 0)\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n\n        iter(shouldRemove ? uncomment : comment);\n    };\n\n    this.toggleBlockComment = function(state, session, range, cursor) {\n        var comment = this.blockComment;\n        if (!comment)\n            return;\n        if (!comment.start && comment[0])\n            comment = comment[0];\n\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n        var token = iterator.getCurrentToken();\n\n        var sel = session.selection;\n        var initialRange = session.selection.toOrientedRange();\n        var startRow, colDiff;\n\n        if (token && /comment/.test(token.type)) {\n            var startRange, endRange;\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.start);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    startRange = new Range(row, column, row, column + comment.start.length);\n                    break;\n                }\n                token = iterator.stepBackward();\n            }\n\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.end);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    endRange = new Range(row, column, row, column + comment.end.length);\n                    break;\n                }\n                token = iterator.stepForward();\n            }\n            if (endRange)\n                session.remove(endRange);\n            if (startRange) {\n                session.remove(startRange);\n                startRow = startRange.start.row;\n                colDiff = -comment.start.length;\n            }\n        } else {\n            colDiff = comment.start.length;\n            startRow = range.start.row;\n            session.insert(range.end, comment.end);\n            session.insert(range.start, comment.start);\n        }\n        if (initialRange.start.row == startRow)\n            initialRange.start.column += colDiff;\n        if (initialRange.end.row == startRow)\n            initialRange.end.column += colDiff;\n        session.selection.fromOrientedRange(initialRange);\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$getIndent(line);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return false;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n    this.createWorker = function(session) {\n        return null;\n    };\n\n    this.createModeDelegates = function (mapping) {\n        this.$embeds = [];\n        this.$modes = {};\n        for (var i in mapping) {\n            if (mapping[i]) {\n                var Mode = mapping[i];\n                var id = Mode.prototype.$id;\n                var mode = config.$modes[id];\n                if (!mode)\n                    config.$modes[id] = mode = new Mode();\n                if (!config.$modes[i])\n                    config.$modes[i] = mode;\n                this.$embeds.push(i);\n                this.$modes[i] = mode;\n            }\n        }\n\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\", \n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\n\n        for (var i = 0; i < delegations.length; i++) {\n            (function(scope) {\n              var functionName = delegations[i];\n              var defaultHandler = scope[functionName];\n              scope[delegations[i]] = function() {\n                  return this.$delegator(functionName, arguments, defaultHandler);\n              };\n            }(this));\n        }\n    };\n\n    this.$delegator = function(method, args, defaultHandler) {\n        var state = args[0] || \"start\";\n        if (typeof state != \"string\") {\n            if (Array.isArray(state[2])) {\n                var language = state[2][state[2].length - 1];\n                var mode = this.$modes[language];\n                if (mode)\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\n            }\n            state = state[0] || \"start\";\n        }\n            \n        for (var i = 0; i < this.$embeds.length; i++) {\n            if (!this.$modes[this.$embeds[i]]) continue;\n\n            var split = state.split(this.$embeds[i]);\n            if (!split[0] && split[1]) {\n                args[0] = split[1];\n                var mode = this.$modes[this.$embeds[i]];\n                return mode[method].apply(mode, args);\n            }\n        }\n        var ret = defaultHandler.apply(this, args);\n        return defaultHandler ? ret : undefined;\n    };\n\n    this.transformAction = function(state, action, editor, session, param) {\n        if (this.$behaviour) {\n            var behaviours = this.$behaviour.getBehaviours();\n            for (var key in behaviours) {\n                if (behaviours[key][action]) {\n                    var ret = behaviours[key][action].apply(this, arguments);\n                    if (ret) {\n                        return ret;\n                    }\n                }\n            }\n        }\n    };\n    \n    this.getKeywords = function(append) {\n        if (!this.completionKeywords) {\n            var rules = this.$tokenizer.rules;\n            var completionKeywords = [];\n            for (var rule in rules) {\n                var ruleItr = rules[rule];\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\n                    if (typeof ruleItr[r].token === \"string\") {\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\n                            completionKeywords.push(ruleItr[r].regex);\n                    }\n                    else if (typeof ruleItr[r].token === \"object\") {\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    \n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\n                            }\n                        }\n                    }\n                }\n            }\n            this.completionKeywords = completionKeywords;\n        }\n        if (!append)\n            return this.$keywordList;\n        return completionKeywords.concat(this.$keywordList || []);\n    };\n    \n    this.$createKeywordList = function() {\n        if (!this.$highlightRules)\n            this.getTokenizer();\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        var keywords = this.$keywordList || this.$createKeywordList();\n        return keywords.map(function(word) {\n            return {\n                name: word,\n                value: word,\n                score: 0,\n                meta: \"keyword\"\n            };\n        });\n    };\n\n    this.$id = \"ace/mode/text\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nfunction throwDeltaError(delta, errorText){\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\n\nfunction positionInDocument(docLines, position) {\n    return position.row    >= 0 && position.row    <  docLines.length &&\n           position.column >= 0 && position.column <= docLines[position.row].length;\n}\n\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n       throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\n\nexports.applyDelta = function(docLines, delta, doNotValidate) {\n    \n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            } else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            } else {\n                docLines.splice(\n                    row, endRow - row + 1,\n                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)\n                );\n            }\n            break;\n    }\n};\n});\n\nace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar Anchor = exports.Anchor = function(doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    \n    if (typeof column == \"undefined\")\n        this.setPosition(row.row, row.column);\n    else\n        this.setPosition(row, column);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.getPosition = function() {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function() {\n        return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function(delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n\n        if (delta.start.row > this.row)\n            return;\n            \n        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    \n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n    }\n            \n    function $getTransformedPoint(delta, point, moveIfEqual) {\n        var deltaIsInsert = delta.action == \"insert\";\n        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);\n        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n        var deltaStart = delta.start;\n        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n            return {\n                row: point.row,\n                column: point.column\n            };\n        }\n        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n            return {\n                row: point.row + deltaRowShift,\n                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n            };\n        }\n        \n        return {\n            row: deltaStart.row,\n            column: deltaStart.column\n        };\n    }\n    this.setPosition = function(row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        } else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    this.detach = function() {\n        this.document.removeEventListener(\"change\", this.$onChange);\n    };\n    this.attach = function(doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function(row, column) {\n        var pos = {};\n\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n\n        if (column < 0)\n            pos.column = 0;\n\n        return pos;\n    };\n\n}).call(Anchor.prototype);\n\n});\n\nace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\n\nvar Document = function(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({row: 0, column: 0}, textOrLines);\n    } else {\n        this.insert({row: 0, column:0}, textOrLines);\n    }\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setValue = function(text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({row: 0, column: 0}, text);\n    };\n    this.getValue = function() {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function(row, column) {\n        return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n        this.$split = function(text) {\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n        };\n    } else {\n        this.$split = function(text) {\n            return text.split(/\\r\\n|\\r|\\n/);\n        };\n    }\n\n\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function() {\n        switch (this.$newLineMode) {\n          case \"windows\":\n            return \"\\r\\n\";\n          case \"unix\":\n            return \"\\n\";\n          default:\n            return this.$autoNewLine || \"\\n\";\n        }\n    };\n\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function(newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function() {\n        return this.$newLineMode;\n    };\n    this.isNewLine = function(text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    this.getLine = function(row) {\n        return this.$lines[row] || \"\";\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function() {\n        return this.getLines(0, this.getLength());\n    };\n    this.getLength = function() {\n        return this.$lines.length;\n    };\n    this.getTextRange = function(range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function(range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        } else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    this.insertLines = function(row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function(firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function(position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function(position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        \n        return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function(position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        \n        return this.clonePos(end);\n    };\n    \n    this.clippedPos = function(row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        } else if (row < 0) {\n            row = 0;\n        } else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return {row: row, column: column};\n    };\n    \n    this.clonePos = function(pos) {\n        return {row: pos.row, column: pos.column};\n    };\n    \n    this.pos = function(row, column) {\n        return {row: row, column: column};\n    };\n    \n    this.$clipPosition = function(position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        } else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    this.insertFullLines = function(row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        } else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({row: row, column: column}, lines);\n    };    \n    this.insertMergedLines = function(position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        \n        return this.clonePos(end);\n    };\n    this.remove = function(range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        });\n        return this.clonePos(start);\n    };\n    this.removeInLine = function(row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        }, true);\n        \n        return this.clonePos(start);\n    };\n    this.removeFullLines = function(firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine  = lastRow  < this.getLength() - 1;\n        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );\n        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );\n        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );\n        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); \n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        \n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    this.removeNewLine = function(row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    this.replace = function(range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        \n        return end;\n    };\n    this.applyDeltas = function(deltas) {\n        for (var i=0; i<deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    this.revertDeltas = function(deltas) {\n        for (var i=deltas.length-1; i>=0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    this.applyDelta = function(delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        \n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    \n    this.$splitAndapplyLargeDelta = function(delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row; \n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    this.revertDelta = function(delta) {\n        this.applyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    this.indexToPosition = function(index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return {row: i, column: index + lines[i].length + newlineLength};\n        }\n        return {row: l-1, column: index + lines[l-1].length + newlineLength};\n    };\n    this.positionToIndex = function(pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n\n        return index + pos.column;\n    };\n\n}).call(Document.prototype);\n\nexports.Document = Document;\n});\n\nace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar BackgroundTokenizer = function(tokenizer, editor) {\n    this.running = false;\n    this.lines = [];\n    this.states = [];\n    this.currentLine = 0;\n    this.tokenizer = tokenizer;\n\n    var self = this;\n\n    this.$worker = function() {\n        if (!self.running) { return; }\n\n        var workerStart = new Date();\n        var currentLine = self.currentLine;\n        var endLine = -1;\n        var doc = self.doc;\n\n        var startLine = currentLine;\n        while (self.lines[currentLine])\n            currentLine++;\n        \n        var len = doc.getLength();\n        var processedLines = 0;\n        self.running = false;\n        while (currentLine < len) {\n            self.$tokenizeRow(currentLine);\n            endLine = currentLine;\n            do {\n                currentLine++;\n            } while (self.lines[currentLine]);\n            processedLines ++;\n            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\n                self.running = setTimeout(self.$worker, 20);\n                break;\n            }\n        }\n        self.currentLine = currentLine;\n        \n        if (endLine == -1)\n            endLine = currentLine;\n        \n        if (startLine <= endLine)\n            self.fireUpdateEvent(startLine, endLine);\n    };\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n    this.setTokenizer = function(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.lines = [];\n        this.states = [];\n\n        this.start(0);\n    };\n    this.setDocument = function(doc) {\n        this.doc = doc;\n        this.lines = [];\n        this.states = [];\n\n        this.stop();\n    };\n    this.fireUpdateEvent = function(firstRow, lastRow) {\n        var data = {\n            first: firstRow,\n            last: lastRow\n        };\n        this._signal(\"update\", {data: data});\n    };\n    this.start = function(startRow) {\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n        this.lines.splice(this.currentLine, this.lines.length);\n        this.states.splice(this.currentLine, this.states.length);\n\n        this.stop();\n        this.running = setTimeout(this.$worker, 700);\n    };\n    \n    this.scheduleStart = function() {\n        if (!this.running)\n            this.running = setTimeout(this.$worker, 700);\n    };\n\n    this.$updateOnChange = function(delta) {\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n            this.lines[startRow] = null;\n        } else if (delta.action == \"remove\") {\n            this.lines.splice(startRow, len + 1, null);\n            this.states.splice(startRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(startRow, 1);\n            this.lines.splice.apply(this.lines, args);\n            this.states.splice.apply(this.states, args);\n        }\n\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n\n        this.stop();\n    };\n    this.stop = function() {\n        if (this.running)\n            clearTimeout(this.running);\n        this.running = false;\n    };\n    this.getTokens = function(row) {\n        return this.lines[row] || this.$tokenizeRow(row);\n    };\n    this.getState = function(row) {\n        if (this.currentLine == row)\n            this.$tokenizeRow(row);\n        return this.states[row] || \"start\";\n    };\n\n    this.$tokenizeRow = function(row) {\n        var line = this.doc.getLine(row);\n        var state = this.states[row - 1];\n\n        var data = this.tokenizer.getLineTokens(line, state, row);\n\n        if (this.states[row] + \"\" !== data.state + \"\") {\n            this.states[row] = data.state;\n            this.lines[row + 1] = null;\n            if (this.currentLine > row + 1)\n                this.currentLine = row + 1;\n        } else if (this.currentLine == row) {\n            this.currentLine = row + 1;\n        }\n\n        return this.lines[row] = data.tokens;\n    };\n\n}).call(BackgroundTokenizer.prototype);\n\nexports.BackgroundTokenizer = BackgroundTokenizer;\n});\n\nace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar SearchHighlight = function(regExp, clazz, type) {\n    this.setRegexp(regExp);\n    this.clazz = clazz;\n    this.type = type || \"text\";\n};\n\n(function() {\n    this.MAX_RANGES = 500;\n    \n    this.setRegexp = function(regExp) {\n        if (this.regExp+\"\" == regExp+\"\")\n            return;\n        this.regExp = regExp;\n        this.cache = [];\n    };\n\n    this.update = function(html, markerLayer, session, config) {\n        if (!this.regExp)\n            return;\n        var start = config.firstRow, end = config.lastRow;\n\n        for (var i = start; i <= end; i++) {\n            var ranges = this.cache[i];\n            if (ranges == null) {\n                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n                if (ranges.length > this.MAX_RANGES)\n                    ranges = ranges.slice(0, this.MAX_RANGES);\n                ranges = ranges.map(function(match) {\n                    return new Range(i, match.offset, i, match.offset + match.length);\n                });\n                this.cache[i] = ranges.length ? ranges : \"\";\n            }\n\n            for (var j = ranges.length; j --; ) {\n                markerLayer.drawSingleLineMarker(\n                    html, ranges[j].toScreenRange(session), this.clazz, config);\n            }\n        }\n    };\n\n}).call(SearchHighlight.prototype);\n\nexports.SearchHighlight = SearchHighlight;\n});\n\nace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nfunction FoldLine(foldData, folds) {\n    this.foldData = foldData;\n    if (Array.isArray(folds)) {\n        this.folds = folds;\n    } else {\n        folds = this.folds = [ folds ];\n    }\n\n    var last = folds[folds.length - 1];\n    this.range = new Range(folds[0].start.row, folds[0].start.column,\n                           last.end.row, last.end.column);\n    this.start = this.range.start;\n    this.end   = this.range.end;\n\n    this.folds.forEach(function(fold) {\n        fold.setFoldLine(this);\n    }, this);\n}\n\n(function() {\n    this.shiftRow = function(shift) {\n        this.start.row += shift;\n        this.end.row += shift;\n        this.folds.forEach(function(fold) {\n            fold.start.row += shift;\n            fold.end.row += shift;\n        });\n    };\n\n    this.addFold = function(fold) {\n        if (fold.sameRow) {\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n            }\n            this.folds.push(fold);\n            this.folds.sort(function(a, b) {\n                return -a.range.compareEnd(b.start.row, b.start.column);\n            });\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n                this.end.row = fold.end.row;\n                this.end.column =  fold.end.column;\n            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n                this.start.row = fold.start.row;\n                this.start.column = fold.start.column;\n            }\n        } else if (fold.start.row == this.end.row) {\n            this.folds.push(fold);\n            this.end.row = fold.end.row;\n            this.end.column = fold.end.column;\n        } else if (fold.end.row == this.start.row) {\n            this.folds.unshift(fold);\n            this.start.row = fold.start.row;\n            this.start.column = fold.start.column;\n        } else {\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n        }\n        fold.foldLine = this;\n    };\n\n    this.containsRow = function(row) {\n        return row >= this.start.row && row <= this.end.row;\n    };\n\n    this.walk = function(callback, endRow, endColumn) {\n        var lastEnd = 0,\n            folds = this.folds,\n            fold,\n            cmp, stop, isNewRow = true;\n\n        if (endRow == null) {\n            endRow = this.end.row;\n            endColumn = this.end.column;\n        }\n\n        for (var i = 0; i < folds.length; i++) {\n            fold = folds[i];\n\n            cmp = fold.range.compareStart(endRow, endColumn);\n            if (cmp == -1) {\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\n                return;\n            }\n\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n            if (stop || cmp === 0) {\n                return;\n            }\n            isNewRow = !fold.sameRow;\n            lastEnd = fold.end.column;\n        }\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\n    };\n\n    this.getNextFoldTo = function(row, column) {\n        var fold, cmp;\n        for (var i = 0; i < this.folds.length; i++) {\n            fold = this.folds[i];\n            cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                return {\n                    fold: fold,\n                    kind: \"after\"\n                };\n            } else if (cmp === 0) {\n                return {\n                    fold: fold,\n                    kind: \"inside\"\n                };\n            }\n        }\n        return null;\n    };\n\n    this.addRemoveChars = function(row, column, len) {\n        var ret = this.getNextFoldTo(row, column),\n            fold, folds;\n        if (ret) {\n            fold = ret.fold;\n            if (ret.kind == \"inside\"\n                && fold.start.column != column\n                && fold.start.row != row)\n            {\n                window.console && window.console.log(row, column, fold);\n            } else if (fold.start.row == row) {\n                folds = this.folds;\n                var i = folds.indexOf(fold);\n                if (i === 0) {\n                    this.start.column += len;\n                }\n                for (i; i < folds.length; i++) {\n                    fold = folds[i];\n                    fold.start.column += len;\n                    if (!fold.sameRow) {\n                        return;\n                    }\n                    fold.end.column += len;\n                }\n                this.end.column += len;\n            }\n        }\n    };\n\n    this.split = function(row, column) {\n        var pos = this.getNextFoldTo(row, column);\n        \n        if (!pos || pos.kind == \"inside\")\n            return null;\n            \n        var fold = pos.fold;\n        var folds = this.folds;\n        var foldData = this.foldData;\n        \n        var i = folds.indexOf(fold);\n        var foldBefore = folds[i - 1];\n        this.end.row = foldBefore.end.row;\n        this.end.column = foldBefore.end.column;\n        folds = folds.splice(i, folds.length - i);\n\n        var newFoldLine = new FoldLine(foldData, folds);\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n        return newFoldLine;\n    };\n\n    this.merge = function(foldLineNext) {\n        var folds = foldLineNext.folds;\n        for (var i = 0; i < folds.length; i++) {\n            this.addFold(folds[i]);\n        }\n        var foldData = this.foldData;\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\n    };\n\n    this.toString = function() {\n        var ret = [this.range.toString() + \": [\" ];\n\n        this.folds.forEach(function(fold) {\n            ret.push(\"  \" + fold.toString());\n        });\n        ret.push(\"]\");\n        return ret.join(\"\\n\");\n    };\n\n    this.idxToPosition = function(idx) {\n        var lastFoldEndColumn = 0;\n\n        for (var i = 0; i < this.folds.length; i++) {\n            var fold = this.folds[i];\n\n            idx -= fold.start.column - lastFoldEndColumn;\n            if (idx < 0) {\n                return {\n                    row: fold.start.row,\n                    column: fold.start.column + idx\n                };\n            }\n\n            idx -= fold.placeholder.length;\n            if (idx < 0) {\n                return fold.start;\n            }\n\n            lastFoldEndColumn = fold.end.column;\n        }\n\n        return {\n            row: this.end.row,\n            column: this.end.column + idx\n        };\n    };\n}).call(FoldLine.prototype);\n\nexports.FoldLine = FoldLine;\n});\n\nace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar Range = require(\"./range\").Range;\nvar comparePoints = Range.comparePoints;\n\nvar RangeList = function() {\n    this.ranges = [];\n};\n\n(function() {\n    this.comparePoints = comparePoints;\n\n    this.pointIndex = function(pos, excludeEdges, startIndex) {\n        var list = this.ranges;\n\n        for (var i = startIndex || 0; i < list.length; i++) {\n            var range = list[i];\n            var cmpEnd = comparePoints(pos, range.end);\n            if (cmpEnd > 0)\n                continue;\n            var cmpStart = comparePoints(pos, range.start);\n            if (cmpEnd === 0)\n                return excludeEdges && cmpStart !== 0 ? -i-2 : i;\n            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n                return i;\n\n            return -i-1;\n        }\n        return -i - 1;\n    };\n\n    this.add = function(range) {\n        var excludeEdges = !range.isEmpty();\n        var startIndex = this.pointIndex(range.start, excludeEdges);\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n\n        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        else\n            endIndex++;\n        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n    };\n\n    this.addList = function(list) {\n        var removed = [];\n        for (var i = list.length; i--; ) {\n            removed.push.apply(removed, this.add(list[i]));\n        }\n        return removed;\n    };\n\n    this.substractPoint = function(pos) {\n        var i = this.pointIndex(pos);\n\n        if (i >= 0)\n            return this.ranges.splice(i, 1);\n    };\n    this.merge = function() {\n        var removed = [];\n        var list = this.ranges;\n        \n        list = list.sort(function(a, b) {\n            return comparePoints(a.start, b.start);\n        });\n        \n        var next = list[0], range;\n        for (var i = 1; i < list.length; i++) {\n            range = next;\n            next = list[i];\n            var cmp = comparePoints(range.end, next.start);\n            if (cmp < 0)\n                continue;\n\n            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n                continue;\n\n            if (comparePoints(range.end, next.end) < 0) {\n                range.end.row = next.end.row;\n                range.end.column = next.end.column;\n            }\n\n            list.splice(i, 1);\n            removed.push(next);\n            next = range;\n            i--;\n        }\n        \n        this.ranges = list;\n\n        return removed;\n    };\n\n    this.contains = function(row, column) {\n        return this.pointIndex({row: row, column: column}) >= 0;\n    };\n\n    this.containsPoint = function(pos) {\n        return this.pointIndex(pos) >= 0;\n    };\n\n    this.rangeAtPoint = function(pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges[i];\n    };\n\n\n    this.clipRows = function(startRow, endRow) {\n        var list = this.ranges;\n        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n            return [];\n\n        var startIndex = this.pointIndex({row: startRow, column: 0});\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n\n        var clipped = [];\n        for (var i = startIndex; i < endIndex; i++) {\n            clipped.push(list[i]);\n        }\n        return clipped;\n    };\n\n    this.removeAll = function() {\n        return this.ranges.splice(0, this.ranges.length);\n    };\n\n    this.attach = function(session) {\n        if (this.session)\n            this.detach();\n\n        this.session = session;\n        this.onChange = this.$onChange.bind(this);\n\n        this.session.on('change', this.onChange);\n    };\n\n    this.detach = function() {\n        if (!this.session)\n            return;\n        this.session.removeListener('change', this.onChange);\n        this.session = null;\n    };\n\n    this.$onChange = function(delta) {\n        var start = delta.start;\n        var end = delta.end;\n        var startRow = start.row;\n        var endRow = end.row;\n        var ranges = this.ranges;\n        for (var i = 0, n = ranges.length; i < n; i++) {\n            var r = ranges[i];\n            if (r.end.row >= startRow)\n                break;\n        }\n        \n        if (delta.action == \"insert\") {\n            var lineDif = endRow - startRow;\n            var colDiff = -start.column + end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > startRow)\n                    break;\n    \n                if (r.start.row == startRow && r.start.column >= start.column) {\n                    if (r.start.column == start.column && this.$insertRight) {\n                    } else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                if (r.end.row == startRow && r.end.column >= start.column) {\n                    if (r.end.column == start.column && this.$insertRight) {\n                        continue;\n                    }\n                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {\n                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)\n                            r.end.column -= colDiff;\n                    }\n                    r.end.column += colDiff;\n                    r.end.row += lineDif;\n                }\n            }\n        } else {\n            var lineDif = startRow - endRow;\n            var colDiff = start.column - end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                \n                if (r.start.row > endRow)\n                    break;\n                    \n                if (r.end.row < endRow\n                    && (\n                        startRow < r.end.row \n                        || startRow == r.end.row && start.column < r.end.column\n                    )\n                ) {\n                    r.end.row = startRow;\n                    r.end.column = start.column;\n                }\n                else if (r.end.row == endRow) {\n                    if (r.end.column <= end.column) {\n                        if (lineDif || r.end.column > start.column) {\n                            r.end.column = start.column;\n                            r.end.row = start.row;\n                        }\n                    }\n                    else {\n                        r.end.column += colDiff;\n                        r.end.row += lineDif;\n                    }\n                }\n                else if (r.end.row > endRow) {\n                    r.end.row += lineDif;\n                }\n                \n                if (r.start.row < endRow\n                    && (\n                        startRow < r.start.row \n                        || startRow == r.start.row && start.column < r.start.column\n                    )\n                ) {\n                    r.start.row = startRow;\n                    r.start.column = start.column;\n                }\n                else if (r.start.row == endRow) {\n                    if (r.start.column <= end.column) {\n                        if (lineDif || r.start.column > start.column) {\n                            r.start.column = start.column;\n                            r.start.row = start.row;\n                        }\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                else if (r.start.row > endRow) {\n                    r.start.row += lineDif;\n                }\n            }\n        }\n\n        if (lineDif != 0 && i < n) {\n            for (; i < n; i++) {\n                var r = ranges[i];\n                r.start.row += lineDif;\n                r.end.row += lineDif;\n            }\n        }\n    };\n\n}).call(RangeList.prototype);\n\nexports.RangeList = RangeList;\n});\n\nace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/range_list\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar RangeList = require(\"../range_list\").RangeList;\nvar oop = require(\"../lib/oop\");\nvar Fold = exports.Fold = function(range, placeholder) {\n    this.foldLine = null;\n    this.placeholder = placeholder;\n    this.range = range;\n    this.start = range.start;\n    this.end = range.end;\n\n    this.sameRow = range.start.row == range.end.row;\n    this.subFolds = this.ranges = [];\n};\n\noop.inherits(Fold, RangeList);\n\n(function() {\n\n    this.toString = function() {\n        return '\"' + this.placeholder + '\" ' + this.range.toString();\n    };\n\n    this.setFoldLine = function(foldLine) {\n        this.foldLine = foldLine;\n        this.subFolds.forEach(function(fold) {\n            fold.setFoldLine(foldLine);\n        });\n    };\n\n    this.clone = function() {\n        var range = this.range.clone();\n        var fold = new Fold(range, this.placeholder);\n        this.subFolds.forEach(function(subFold) {\n            fold.subFolds.push(subFold.clone());\n        });\n        fold.collapseChildren = this.collapseChildren;\n        return fold;\n    };\n\n    this.addSubFold = function(fold) {\n        if (this.range.isEqual(fold))\n            return;\n\n        if (!this.range.containsRange(fold))\n            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n        consumeRange(fold, this.start);\n\n        var row = fold.start.row, column = fold.start.column;\n        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n            cmp = this.subFolds[i].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterStart = this.subFolds[i];\n\n        if (cmp == 0)\n            return afterStart.addSubFold(fold);\n        var row = fold.range.end.row, column = fold.range.end.column;\n        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n            cmp = this.subFolds[j].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterEnd = this.subFolds[j];\n\n        if (cmp == 0)\n            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n\n        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n        fold.setFoldLine(this.foldLine);\n\n        return fold;\n    };\n    \n    this.restoreRange = function(range) {\n        return restoreRange(range, this.start);\n    };\n\n}).call(Fold.prototype);\n\nfunction consumePoint(point, anchor) {\n    point.row -= anchor.row;\n    if (point.row == 0)\n        point.column -= anchor.column;\n}\nfunction consumeRange(range, anchor) {\n    consumePoint(range.start, anchor);\n    consumePoint(range.end, anchor);\n}\nfunction restorePoint(point, anchor) {\n    if (point.row == 0)\n        point.column += anchor.column;\n    point.row += anchor.row;\n}\nfunction restoreRange(range, anchor) {\n    restorePoint(range.start, anchor);\n    restorePoint(range.end, anchor);\n}\n\n});\n\nace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar FoldLine = require(\"./fold_line\").FoldLine;\nvar Fold = require(\"./fold\").Fold;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nfunction Folding() {\n    this.getFoldAt = function(row, column, side) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var folds = foldLine.folds;\n        for (var i = 0; i < folds.length; i++) {\n            var fold = folds[i];\n            if (fold.range.contains(row, column)) {\n                if (side == 1 && fold.range.isEnd(row, column)) {\n                    continue;\n                } else if (side == -1 && fold.range.isStart(row, column)) {\n                    continue;\n                }\n                return fold;\n            }\n        }\n    };\n    this.getFoldsInRange = function(range) {\n        var start = range.start;\n        var end = range.end;\n        var foldLines = this.$foldData;\n        var foundFolds = [];\n\n        start.column += 1;\n        end.column -= 1;\n\n        for (var i = 0; i < foldLines.length; i++) {\n            var cmp = foldLines[i].range.compareRange(range);\n            if (cmp == 2) {\n                continue;\n            }\n            else if (cmp == -2) {\n                break;\n            }\n\n            var folds = foldLines[i].folds;\n            for (var j = 0; j < folds.length; j++) {\n                var fold = folds[j];\n                cmp = fold.range.compareRange(range);\n                if (cmp == -2) {\n                    break;\n                } else if (cmp == 2) {\n                    continue;\n                } else\n                if (cmp == 42) {\n                    break;\n                }\n                foundFolds.push(fold);\n            }\n        }\n        start.column -= 1;\n        end.column += 1;\n\n        return foundFolds;\n    };\n\n    this.getFoldsInRangeList = function(ranges) {\n        if (Array.isArray(ranges)) {\n            var folds = [];\n            ranges.forEach(function(range) {\n                folds = folds.concat(this.getFoldsInRange(range));\n            }, this);\n        } else {\n            var folds = this.getFoldsInRange(ranges);\n        }\n        return folds;\n    };\n    this.getAllFolds = function() {\n        var folds = [];\n        var foldLines = this.$foldData;\n        \n        for (var i = 0; i < foldLines.length; i++)\n            for (var j = 0; j < foldLines[i].folds.length; j++)\n                folds.push(foldLines[i].folds[j]);\n\n        return folds;\n    };\n    this.getFoldStringAt = function(row, column, trim, foldLine) {\n        foldLine = foldLine || this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var lastFold = {\n            end: { column: 0 }\n        };\n        var str, fold;\n        for (var i = 0; i < foldLine.folds.length; i++) {\n            fold = foldLine.folds[i];\n            var cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                str = this\n                    .getLine(fold.start.row)\n                    .substring(lastFold.end.column, fold.start.column);\n                break;\n            }\n            else if (cmp === 0) {\n                return null;\n            }\n            lastFold = fold;\n        }\n        if (!str)\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n\n        if (trim == -1)\n            return str.substring(0, column - lastFold.end.column);\n        else if (trim == 1)\n            return str.substring(column - lastFold.end.column);\n        else\n            return str;\n    };\n\n    this.getFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n                return foldLine;\n            } else if (foldLine.end.row > docRow) {\n                return null;\n            }\n        }\n        return null;\n    };\n    this.getNextFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n        }\n        return null;\n    };\n\n    this.getFoldedRowCount = function(first, last) {\n        var foldData = this.$foldData, rowCount = last-first+1;\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i],\n                end = foldLine.end.row,\n                start = foldLine.start.row;\n            if (end >= last) {\n                if (start < last) {\n                    if (start >= first)\n                        rowCount -= last-start;\n                    else\n                        rowCount = 0; // in one fold\n                }\n                break;\n            } else if (end >= first){\n                if (start >= first) // fold inside range\n                    rowCount -=  end-start;\n                else\n                    rowCount -=  end-first+1;\n            }\n        }\n        return rowCount;\n    };\n\n    this.$addFoldLine = function(foldLine) {\n        this.$foldData.push(foldLine);\n        this.$foldData.sort(function(a, b) {\n            return a.start.row - b.start.row;\n        });\n        return foldLine;\n    };\n    this.addFold = function(placeholder, range) {\n        var foldData = this.$foldData;\n        var added = false;\n        var fold;\n        \n        if (placeholder instanceof Fold)\n            fold = placeholder;\n        else {\n            fold = new Fold(range, placeholder);\n            fold.collapseChildren = range.collapseChildren;\n        }\n        this.$clipRangeToDocument(fold.range);\n\n        var startRow = fold.start.row;\n        var startColumn = fold.start.column;\n        var endRow = fold.end.row;\n        var endColumn = fold.end.column;\n        if (!(startRow < endRow || \n            startRow == endRow && startColumn <= endColumn - 2))\n            throw new Error(\"The range has to be at least 2 characters width\");\n\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\n        if (startFold && endFold == startFold)\n            return startFold.addSubFold(fold);\n\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\n            this.removeFold(startFold);\n        \n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n            this.removeFold(endFold);\n        var folds = this.getFoldsInRange(fold.range);\n        if (folds.length > 0) {\n            this.removeFolds(folds);\n            folds.forEach(function(subFold) {\n                fold.addSubFold(subFold);\n            });\n        }\n\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (endRow == foldLine.start.row) {\n                foldLine.addFold(fold);\n                added = true;\n                break;\n            } else if (startRow == foldLine.end.row) {\n                foldLine.addFold(fold);\n                added = true;\n                if (!fold.sameRow) {\n                    var foldLineNext = foldData[i + 1];\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\n                        foldLine.merge(foldLineNext);\n                        break;\n                    }\n                }\n                break;\n            } else if (endRow <= foldLine.start.row) {\n                break;\n            }\n        }\n\n        if (!added)\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n\n        if (this.$useWrapMode)\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n        else\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\n\n        return fold;\n    };\n\n    this.addFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.addFold(fold);\n        }, this);\n    };\n\n    this.removeFold = function(fold) {\n        var foldLine = fold.foldLine;\n        var startRow = foldLine.start.row;\n        var endRow = foldLine.end.row;\n\n        var foldLines = this.$foldData;\n        var folds = foldLine.folds;\n        if (folds.length == 1) {\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\n        } else\n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n            folds.pop();\n            foldLine.end.row = folds[folds.length - 1].end.row;\n            foldLine.end.column = folds[folds.length - 1].end.column;\n        } else\n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n            folds.shift();\n            foldLine.start.row = folds[0].start.row;\n            foldLine.start.column = folds[0].start.column;\n        } else\n        if (fold.sameRow) {\n            folds.splice(folds.indexOf(fold), 1);\n        } else\n        {\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n            folds = newFoldLine.folds;\n            folds.shift();\n            newFoldLine.start.row = folds[0].start.row;\n            newFoldLine.start.column = folds[0].start.column;\n        }\n\n        if (!this.$updating) {\n            if (this.$useWrapMode)\n                this.$updateWrapData(startRow, endRow);\n            else\n                this.$updateRowLengthCache(startRow, endRow);\n        }\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\n    };\n\n    this.removeFolds = function(folds) {\n        var cloneFolds = [];\n        for (var i = 0; i < folds.length; i++) {\n            cloneFolds.push(folds[i]);\n        }\n\n        cloneFolds.forEach(function(fold) {\n            this.removeFold(fold);\n        }, this);\n        this.$modified = true;\n    };\n\n    this.expandFold = function(fold) {\n        this.removeFold(fold);\n        fold.subFolds.forEach(function(subFold) {\n            fold.restoreRange(subFold);\n            this.addFold(subFold);\n        }, this);\n        if (fold.collapseChildren > 0) {\n            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);\n        }\n        fold.subFolds = [];\n    };\n\n    this.expandFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.expandFold(fold);\n        }, this);\n    };\n\n    this.unfold = function(location, expandInner) {\n        var range, folds;\n        if (location == null) {\n            range = new Range(0, 0, this.getLength(), 0);\n            expandInner = true;\n        } else if (typeof location == \"number\")\n            range = new Range(location, 0, location, this.getLine(location).length);\n        else if (\"row\" in location)\n            range = Range.fromPoints(location, location);\n        else\n            range = location;\n        \n        folds = this.getFoldsInRangeList(range);\n        if (expandInner) {\n            this.removeFolds(folds);\n        } else {\n            var subFolds = folds;\n            while (subFolds.length) {\n                this.expandFolds(subFolds);\n                subFolds = this.getFoldsInRangeList(range);\n            }\n        }\n        if (folds.length)\n            return folds;\n    };\n    this.isRowFolded = function(docRow, startFoldRow) {\n        return !!this.getFoldLine(docRow, startFoldRow);\n    };\n\n    this.getRowFoldEnd = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.end.row : docRow;\n    };\n\n    this.getRowFoldStart = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.start.row : docRow;\n    };\n\n    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {\n        if (startRow == null)\n            startRow = foldLine.start.row;\n        if (startColumn == null)\n            startColumn = 0;\n        if (endRow == null)\n            endRow = foldLine.end.row;\n        if (endColumn == null)\n            endColumn = this.getLine(endRow).length;\n        var doc = this.doc;\n        var textLine = \"\";\n\n        foldLine.walk(function(placeholder, row, column, lastColumn) {\n            if (row < startRow)\n                return;\n            if (row == startRow) {\n                if (column < startColumn)\n                    return;\n                lastColumn = Math.max(startColumn, lastColumn);\n            }\n\n            if (placeholder != null) {\n                textLine += placeholder;\n            } else {\n                textLine += doc.getLine(row).substring(lastColumn, column);\n            }\n        }, endRow, endColumn);\n        return textLine;\n    };\n\n    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {\n        var foldLine = this.getFoldLine(row);\n\n        if (!foldLine) {\n            var line;\n            line = this.doc.getLine(row);\n            return line.substring(startColumn || 0, endColumn || line.length);\n        } else {\n            return this.getFoldDisplayLine(\n                foldLine, row, endColumn, startRow, startColumn);\n        }\n    };\n\n    this.$cloneFoldData = function() {\n        var fd = [];\n        fd = this.$foldData.map(function(foldLine) {\n            var folds = foldLine.folds.map(function(fold) {\n                return fold.clone();\n            });\n            return new FoldLine(fd, folds);\n        });\n\n        return fd;\n    };\n\n    this.toggleFold = function(tryToUnfold) {\n        var selection = this.selection;\n        var range = selection.getRange();\n        var fold;\n        var bracketPos;\n\n        if (range.isEmpty()) {\n            var cursor = range.start;\n            fold = this.getFoldAt(cursor.row, cursor.column);\n\n            if (fold) {\n                this.expandFold(fold);\n                return;\n            } else if (bracketPos = this.findMatchingBracket(cursor)) {\n                if (range.comparePoint(bracketPos) == 1) {\n                    range.end = bracketPos;\n                } else {\n                    range.start = bracketPos;\n                    range.start.column++;\n                    range.end.column--;\n                }\n            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {\n                if (range.comparePoint(bracketPos) == 1)\n                    range.end = bracketPos;\n                else\n                    range.start = bracketPos;\n\n                range.start.column++;\n            } else {\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n            }\n        } else {\n            var folds = this.getFoldsInRange(range);\n            if (tryToUnfold && folds.length) {\n                this.expandFolds(folds);\n                return;\n            } else if (folds.length == 1 ) {\n                fold = folds[0];\n            }\n        }\n\n        if (!fold)\n            fold = this.getFoldAt(range.start.row, range.start.column);\n\n        if (fold && fold.range.toString() == range.toString()) {\n            this.expandFold(fold);\n            return;\n        }\n\n        var placeholder = \"...\";\n        if (!range.isMultiLine()) {\n            placeholder = this.getTextRange(range);\n            if (placeholder.length < 4)\n                return;\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n        }\n\n        this.addFold(placeholder, range);\n    };\n\n    this.getCommentFoldRange = function(row, column, dir) {\n        var iterator = new TokenIterator(this, row, column);\n        var token = iterator.getCurrentToken();\n        var type = token.type;\n        if (token && /^comment|string/.test(type)) {\n            type = type.match(/comment|string/)[0];\n            if (type == \"comment\")\n                type += \"|doc-start\";\n            var re = new RegExp(type);\n            var range = new Range();\n            if (dir != 1) {\n                do {\n                    token = iterator.stepBackward();\n                } while (token && re.test(token.type));\n                iterator.stepForward();\n            }\n            \n            range.start.row = iterator.getCurrentTokenRow();\n            range.start.column = iterator.getCurrentTokenColumn() + 2;\n\n            iterator = new TokenIterator(this, row, column);\n            \n            if (dir != -1) {\n                var lastRow = -1;\n                do {\n                    token = iterator.stepForward();\n                    if (lastRow == -1) {\n                        var state = this.getState(iterator.$row);\n                        if (!re.test(state))\n                            lastRow = iterator.$row;\n                    } else if (iterator.$row > lastRow) {\n                        break;\n                    }\n                } while (token && re.test(token.type));\n                token = iterator.stepBackward();\n            } else\n                token = iterator.getCurrentToken();\n\n            range.end.row = iterator.getCurrentTokenRow();\n            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;\n            return range;\n        }\n    };\n\n    this.foldAll = function(startRow, endRow, depth) {\n        if (depth == undefined)\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\n        var foldWidgets = this.foldWidgets;\n        if (!foldWidgets)\n            return; // mode doesn't support folding\n        endRow = endRow || this.getLength();\n        startRow = startRow || 0;\n        for (var row = startRow; row < endRow; row++) {\n            if (foldWidgets[row] == null)\n                foldWidgets[row] = this.getFoldWidget(row);\n            if (foldWidgets[row] != \"start\")\n                continue;\n\n            var range = this.getFoldWidgetRange(row);\n            if (range && range.isMultiLine()\n                && range.end.row <= endRow\n                && range.start.row >= startRow\n            ) {\n                row = range.end.row;\n                try {\n                    var fold = this.addFold(\"...\", range);\n                    if (fold)\n                        fold.collapseChildren = depth;\n                } catch(e) {}\n            }\n        }\n    };\n    this.$foldStyles = {\n        \"manual\": 1,\n        \"markbegin\": 1,\n        \"markbeginend\": 1\n    };\n    this.$foldStyle = \"markbegin\";\n    this.setFoldStyle = function(style) {\n        if (!this.$foldStyles[style])\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n        \n        if (this.$foldStyle == style)\n            return;\n\n        this.$foldStyle = style;\n        \n        if (style == \"manual\")\n            this.unfold();\n        var mode = this.$foldMode;\n        this.$setFolding(null);\n        this.$setFolding(mode);\n    };\n\n    this.$setFolding = function(foldMode) {\n        if (this.$foldMode == foldMode)\n            return;\n            \n        this.$foldMode = foldMode;\n        \n        this.off('change', this.$updateFoldWidgets);\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n        this._signal(\"changeAnnotation\");\n        \n        if (!foldMode || this.$foldStyle == \"manual\") {\n            this.foldWidgets = null;\n            return;\n        }\n        \n        this.foldWidgets = [];\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n        \n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\n        this.on('change', this.$updateFoldWidgets);\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n    };\n\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n        var fw = this.foldWidgets;\n        if (!fw || (ignoreCurrent && fw[row]))\n            return {};\n\n        var i = row - 1, firstRange;\n        while (i >= 0) {\n            var c = fw[i];\n            if (c == null)\n                c = fw[i] = this.getFoldWidget(i);\n\n            if (c == \"start\") {\n                var range = this.getFoldWidgetRange(i);\n                if (!firstRange)\n                    firstRange = range;\n                if (range && range.end.row >= row)\n                    break;\n            }\n            i--;\n        }\n\n        return {\n            range: i !== -1 && range,\n            firstRange: firstRange\n        };\n    };\n\n    this.onFoldWidgetClick = function(row, e) {\n        e = e.domEvent;\n        var options = {\n            children: e.shiftKey,\n            all: e.ctrlKey || e.metaKey,\n            siblings: e.altKey\n        };\n        \n        var range = this.$toggleFoldWidget(row, options);\n        if (!range) {\n            var el = (e.target || e.srcElement);\n            if (el && /ace_fold-widget/.test(el.className))\n                el.className += \" ace_invalid\";\n        }\n    };\n    \n    this.$toggleFoldWidget = function(row, options) {\n        if (!this.getFoldWidget)\n            return;\n        var type = this.getFoldWidget(row);\n        var line = this.getLine(row);\n\n        var dir = type === \"end\" ? -1 : 1;\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n\n        if (fold) {\n            if (options.children || options.all)\n                this.removeFold(fold);\n            else\n                this.expandFold(fold);\n            return fold;\n        }\n\n        var range = this.getFoldWidgetRange(row, true);\n        if (range && !range.isMultiLine()) {\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n            if (fold && range.isEqual(fold.range)) {\n                this.removeFold(fold);\n                return fold;\n            }\n        }\n        \n        if (options.siblings) {\n            var data = this.getParentFoldRangeData(row);\n            if (data.range) {\n                var startRow = data.range.start.row + 1;\n                var endRow = data.range.end.row;\n            }\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n        } else if (options.children) {\n            endRow = range ? range.end.row : this.getLength();\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\n        } else if (range) {\n            if (options.all) \n                range.collapseChildren = 10000;\n            this.addFold(\"...\", range);\n        }\n        \n        return range;\n    };\n    \n    \n    \n    this.toggleFoldWidget = function(toggleParent) {\n        var row = this.selection.getCursor().row;\n        row = this.getRowFoldStart(row);\n        var range = this.$toggleFoldWidget(row, {});\n        \n        if (range)\n            return;\n        var data = this.getParentFoldRangeData(row, true);\n        range = data.range || data.firstRange;\n        \n        if (range) {\n            row = range.start.row;\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n\n            if (fold) {\n                this.removeFold(fold);\n            } else {\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n\n    this.updateFoldWidgets = function(delta) {\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n\n        if (len === 0) {\n            this.foldWidgets[firstRow] = null;\n        } else if (delta.action == 'remove') {\n            this.foldWidgets.splice(firstRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\n        }\n    };\n    this.tokenizerUpdateFoldWidgets = function(e) {\n        var rows = e.data;\n        if (rows.first != rows.last) {\n            if (this.foldWidgets.length > rows.first)\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\n        }\n    };\n}\n\nexports.Folding = Folding;\n\n});\n\nace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\n\nfunction BracketMatch() {\n\n    this.findMatchingBracket = function(position, chr) {\n        if (position.column == 0) return null;\n\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);\n        if (charBeforeCursor == \"\") return null;\n\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match)\n            return null;\n\n        if (match[1])\n            return this.$findClosingBracket(match[1], position);\n        else\n            return this.$findOpeningBracket(match[2], position);\n    };\n    \n    this.getBracketRange = function(pos) {\n        var line = this.getLine(pos.row);\n        var before = true, range;\n\n        var chr = line.charAt(pos.column-1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = {row: pos.row, column: pos.column + 1};\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n            before = false;\n        }\n        if (!match)\n            return null;\n\n        if (match[1]) {\n            var bracketPos = this.$findClosingBracket(match[1], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(pos, bracketPos);\n            if (!before) {\n                range.end.column++;\n                range.start.column--;\n            }\n            range.cursor = range.end;\n        } else {\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(bracketPos, pos);\n            if (!before) {\n                range.start.column++;\n                range.end.column--;\n            }\n            range.cursor = range.start;\n        }\n        \n        return range;\n    };\n\n    this.$brackets = {\n        \")\": \"(\",\n        \"(\": \")\",\n        \"]\": \"[\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"<\": \">\",\n        \">\": \"<\"\n    };\n\n    this.$findOpeningBracket = function(bracket, position, typeRe) {\n        var openBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        \n         if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n        var value = token.value;\n        \n        while (true) {\n        \n            while (valueIndex >= 0) {\n                var chr = value.charAt(valueIndex);\n                if (chr == openBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex -= 1;\n            }\n            do {\n                token = iterator.stepBackward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n                \n            value = token.value;\n            valueIndex = value.length - 1;\n        }\n        \n        return null;\n    };\n\n    this.$findClosingBracket = function(bracket, position, typeRe) {\n        var closingBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n\n        if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n\n        while (true) {\n\n            var value = token.value;\n            var valueLength = value.length;\n            while (valueIndex < valueLength) {\n                var chr = value.charAt(valueIndex);\n                if (chr == closingBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex += 1;\n            }\n            do {\n                token = iterator.stepForward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n\n            valueIndex = 0;\n        }\n        \n        return null;\n    };\n}\nexports.BracketMatch = BracketMatch;\n\n});\n\nace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/bidihandler\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\nvar config = require(\"./config\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Selection = require(\"./selection\").Selection;\nvar TextMode = require(\"./mode/text\").Mode;\nvar Range = require(\"./range\").Range;\nvar Document = require(\"./document\").Document;\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\n\nvar EditSession = function(text, mode) {\n    this.$breakpoints = [];\n    this.$decorations = [];\n    this.$frontMarkers = {};\n    this.$backMarkers = {};\n    this.$markerId = 1;\n    this.$undoSelect = true;\n\n    this.$foldData = [];\n    this.id = \"session\" + (++EditSession.$uid);\n    this.$foldData.toString = function() {\n        return this.join(\"\\n\");\n    };\n    this.on(\"changeFold\", this.onChangeFold.bind(this));\n    this.$onChange = this.onChange.bind(this);\n\n    if (typeof text != \"object\" || !text.getLine)\n        text = new Document(text);\n\n    this.setDocument(text);\n    this.selection = new Selection(this);\n    this.$bidiHandler = new BidiHandler(this);\n\n    config.resetOptions(this);\n    this.setMode(mode);\n    config._signal(\"session\", this);\n};\n\n\nEditSession.$uid = 0;\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setDocument = function(doc) {\n        if (this.doc)\n            this.doc.removeListener(\"change\", this.$onChange);\n\n        this.doc = doc;\n        doc.on(\"change\", this.$onChange);\n\n        if (this.bgTokenizer)\n            this.bgTokenizer.setDocument(this.getDocument());\n\n        this.resetCaches();\n    };\n    this.getDocument = function() {\n        return this.doc;\n    };\n    this.$resetRowCache = function(docRow) {\n        if (!docRow) {\n            this.$docRowCache = [];\n            this.$screenRowCache = [];\n            return;\n        }\n        var l = this.$docRowCache.length;\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n        if (l > i) {\n            this.$docRowCache.splice(i, l);\n            this.$screenRowCache.splice(i, l);\n        }\n    };\n\n    this.$getRowCacheIndex = function(cacheArray, val) {\n        var low = 0;\n        var hi = cacheArray.length - 1;\n\n        while (low <= hi) {\n            var mid = (low + hi) >> 1;\n            var c = cacheArray[mid];\n\n            if (val > c)\n                low = mid + 1;\n            else if (val < c)\n                hi = mid - 1;\n            else\n                return mid;\n        }\n\n        return low -1;\n    };\n\n    this.resetCaches = function() {\n        this.$modified = true;\n        this.$wrapData = [];\n        this.$rowLengthCache = [];\n        this.$resetRowCache(0);\n        if (this.bgTokenizer)\n            this.bgTokenizer.start(0);\n    };\n\n    this.onChangeFold = function(e) {\n        var fold = e.data;\n        this.$resetRowCache(fold.start.row);\n    };\n\n    this.onChange = function(delta) {\n        this.$modified = true;\n        this.$bidiHandler.onChange(delta);\n        this.$resetRowCache(delta.start.row);\n\n        var removedFolds = this.$updateInternalDataOnChange(delta);\n        if (!this.$fromUndo && this.$undoManager) {\n            if (removedFolds && removedFolds.length) {\n                this.$undoManager.add({\n                    action: \"removeFolds\",\n                    folds:  removedFolds\n                }, this.mergeUndoDeltas);\n                this.mergeUndoDeltas = true;\n            }\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\n            this.mergeUndoDeltas = true;\n            \n            this.$informUndoManager.schedule();\n        }\n\n        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);\n        this._signal(\"change\", delta);\n    };\n    this.setValue = function(text) {\n        this.doc.setValue(text);\n        this.selection.moveTo(0, 0);\n\n        this.$resetRowCache(0);\n        this.setUndoManager(this.$undoManager);\n        this.getUndoManager().reset();\n    };\n    this.getValue =\n    this.toString = function() {\n        return this.doc.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.getState = function(row) {\n        return this.bgTokenizer.getState(row);\n    };\n    this.getTokens = function(row) {\n        return this.bgTokenizer.getTokens(row);\n    };\n    this.getTokenAt = function(row, column) {\n        var tokens = this.bgTokenizer.getTokens(row);\n        var token, c = 0;\n        if (column == null) {\n            var i = tokens.length - 1;\n            c = this.getLine(row).length;\n        } else {\n            for (var i = 0; i < tokens.length; i++) {\n                c += tokens[i].value.length;\n                if (c >= column)\n                    break;\n            }\n        }\n        token = tokens[i];\n        if (!token)\n            return null;\n        token.index = i;\n        token.start = c - token.value.length;\n        return token;\n    };\n    this.setUndoManager = function(undoManager) {\n        this.$undoManager = undoManager;\n        \n        if (this.$informUndoManager)\n            this.$informUndoManager.cancel();\n        \n        if (undoManager) {\n            var self = this;\n            undoManager.addSession(this);\n            this.$syncInformUndoManager = function() {\n                self.$informUndoManager.cancel();\n                self.mergeUndoDeltas = false;\n            };\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n        } else {\n            this.$syncInformUndoManager = function() {};\n        }\n    };\n    this.markUndoGroup = function() {\n        if (this.$syncInformUndoManager)\n            this.$syncInformUndoManager();\n    };\n    \n    this.$defaultUndoManager = {\n        undo: function() {},\n        redo: function() {},\n        reset: function() {},\n        add: function() {},\n        addSelection: function() {},\n        startNewGroup: function() {},\n        addSession: function() {}\n    };\n    this.getUndoManager = function() {\n        return this.$undoManager || this.$defaultUndoManager;\n    };\n    this.getTabString = function() {\n        if (this.getUseSoftTabs()) {\n            return lang.stringRepeat(\" \", this.getTabSize());\n        } else {\n            return \"\\t\";\n        }\n    };\n    this.setUseSoftTabs = function(val) {\n        this.setOption(\"useSoftTabs\", val);\n    };\n    this.getUseSoftTabs = function() {\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n    };\n    this.setTabSize = function(tabSize) {\n        this.setOption(\"tabSize\", tabSize);\n    };\n    this.getTabSize = function() {\n        return this.$tabSize;\n    };\n    this.isTabStop = function(position) {\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n    };\n    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\n    };\n    this.getNavigateWithinSoftTabs = function() {\n        return this.$navigateWithinSoftTabs;\n    };\n\n    this.$overwrite = false;\n    this.setOverwrite = function(overwrite) {\n        this.setOption(\"overwrite\", overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.$overwrite;\n    };\n    this.toggleOverwrite = function() {\n        this.setOverwrite(!this.$overwrite);\n    };\n    this.addGutterDecoration = function(row, className) {\n        if (!this.$decorations[row])\n            this.$decorations[row] = \"\";\n        this.$decorations[row] += \" \" + className;\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.removeGutterDecoration = function(row, className) {\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.getBreakpoints = function() {\n        return this.$breakpoints;\n    };\n    this.setBreakpoints = function(rows) {\n        this.$breakpoints = [];\n        for (var i=0; i<rows.length; i++) {\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n        }\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoints = function() {\n        this.$breakpoints = [];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.setBreakpoint = function(row, className) {\n        if (className === undefined)\n            className = \"ace_breakpoint\";\n        if (className)\n            this.$breakpoints[row] = className;\n        else\n            delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoint = function(row) {\n        delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.addMarker = function(range, clazz, type, inFront) {\n        var id = this.$markerId++;\n\n        var marker = {\n            range : range,\n            type : type || \"line\",\n            renderer: typeof type == \"function\" ? type : null,\n            clazz : clazz,\n            inFront: !!inFront,\n            id: id\n        };\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return id;\n    };\n    this.addDynamicMarker = function(marker, inFront) {\n        if (!marker.update)\n            return;\n        var id = this.$markerId++;\n        marker.id = id;\n        marker.inFront = !!inFront;\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return marker;\n    };\n    this.removeMarker = function(markerId) {\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n        if (!marker)\n            return;\n\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n        delete (markers[markerId]);\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n    };\n    this.getMarkers = function(inFront) {\n        return inFront ? this.$frontMarkers : this.$backMarkers;\n    };\n\n    this.highlight = function(re) {\n        if (!this.$searchHighlight) {\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n            this.$searchHighlight = this.addDynamicMarker(highlight);\n        }\n        this.$searchHighlight.setRegexp(re);\n    };\n    this.highlightLines = function(startRow, endRow, clazz, inFront) {\n        if (typeof endRow != \"number\") {\n            clazz = endRow;\n            endRow = startRow;\n        }\n        if (!clazz)\n            clazz = \"ace_step\";\n\n        var range = new Range(startRow, 0, endRow, Infinity);\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n        return range;\n    };\n    this.setAnnotations = function(annotations) {\n        this.$annotations = annotations;\n        this._signal(\"changeAnnotation\", {});\n    };\n    this.getAnnotations = function() {\n        return this.$annotations || [];\n    };\n    this.clearAnnotations = function() {\n        this.setAnnotations([]);\n    };\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r?\\n)/m);\n        if (match) {\n            this.$autoNewLine = match[1];\n        } else {\n            this.$autoNewLine = \"\\n\";\n        }\n    };\n    this.getWordRange = function(row, column) {\n        var line = this.getLine(row);\n\n        var inToken = false;\n        if (column > 0)\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n\n        if (!inToken)\n            inToken = !!line.charAt(column).match(this.tokenRe);\n\n        if (inToken)\n            var re = this.tokenRe;\n        else if (/^\\s+$/.test(line.slice(column-1, column+1)))\n            var re = /\\s/;\n        else\n            var re = this.nonTokenRe;\n\n        var start = column;\n        if (start > 0) {\n            do {\n                start--;\n            }\n            while (start >= 0 && line.charAt(start).match(re));\n            start++;\n        }\n\n        var end = column;\n        while (end < line.length && line.charAt(end).match(re)) {\n            end++;\n        }\n\n        return new Range(row, start, row, end);\n    };\n    this.getAWordRange = function(row, column) {\n        var wordRange = this.getWordRange(row, column);\n        var line = this.getLine(wordRange.end.row);\n\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n            wordRange.end.column += 1;\n        }\n        return wordRange;\n    };\n    this.setNewLineMode = function(newLineMode) {\n        this.doc.setNewLineMode(newLineMode);\n    };\n    this.getNewLineMode = function() {\n        return this.doc.getNewLineMode();\n    };\n    this.setUseWorker = function(useWorker) { this.setOption(\"useWorker\", useWorker); };\n    this.getUseWorker = function() { return this.$useWorker; };\n    this.onReloadTokenizer = function(e) {\n        var rows = e.data;\n        this.bgTokenizer.start(rows.first);\n        this._signal(\"tokenizerUpdate\", e);\n    };\n\n    this.$modes = config.$modes;\n    this.$mode = null;\n    this.$modeId = null;\n    this.setMode = function(mode, cb) {\n        if (mode && typeof mode === \"object\") {\n            if (mode.getTokenizer)\n                return this.$onChangeMode(mode);\n            var options = mode;\n            var path = options.path;\n        } else {\n            path = mode || \"ace/mode/text\";\n        }\n        if (!this.$modes[\"ace/mode/text\"])\n            this.$modes[\"ace/mode/text\"] = new TextMode();\n\n        if (this.$modes[path] && !options) {\n            this.$onChangeMode(this.$modes[path]);\n            cb && cb();\n            return;\n        }\n        this.$modeId = path;\n        config.loadModule([\"mode\", path], function(m) {\n            if (this.$modeId !== path)\n                return cb && cb();\n            if (this.$modes[path] && !options) {\n                this.$onChangeMode(this.$modes[path]);\n            } else if (m && m.Mode) {\n                m = new m.Mode(options);\n                if (!options) {\n                    this.$modes[path] = m;\n                    m.$id = path;\n                }\n                this.$onChangeMode(m);\n            }\n            cb && cb();\n        }.bind(this));\n        if (!this.$mode)\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n    };\n\n    this.$onChangeMode = function(mode, $isPlaceholder) {\n        if (!$isPlaceholder)\n            this.$modeId = mode.$id;\n        if (this.$mode === mode) \n            return;\n\n        this.$mode = mode;\n\n        this.$stopWorker();\n\n        if (this.$useWorker)\n            this.$startWorker();\n\n        var tokenizer = mode.getTokenizer();\n\n        if(tokenizer.addEventListener !== undefined) {\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n            tokenizer.addEventListener(\"update\", onReloadTokenizer);\n        }\n\n        if (!this.bgTokenizer) {\n            this.bgTokenizer = new BackgroundTokenizer(tokenizer);\n            var _self = this;\n            this.bgTokenizer.addEventListener(\"update\", function(e) {\n                _self._signal(\"tokenizerUpdate\", e);\n            });\n        } else {\n            this.bgTokenizer.setTokenizer(tokenizer);\n        }\n\n        this.bgTokenizer.setDocument(this.getDocument());\n\n        this.tokenRe = mode.tokenRe;\n        this.nonTokenRe = mode.nonTokenRe;\n\n        \n        if (!$isPlaceholder) {\n            if (mode.attachToSession)\n                mode.attachToSession(this);\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n            this.$setFolding(mode.foldingRules);\n            this.bgTokenizer.start(0);\n            this._emit(\"changeMode\");\n        }\n    };\n\n    this.$stopWorker = function() {\n        if (this.$worker) {\n            this.$worker.terminate();\n            this.$worker = null;\n        }\n    };\n\n    this.$startWorker = function() {\n        try {\n            this.$worker = this.$mode.createWorker(this);\n        } catch (e) {\n            config.warn(\"Could not load worker\", e);\n            this.$worker = null;\n        }\n    };\n    this.getMode = function() {\n        return this.$mode;\n    };\n\n    this.$scrollTop = 0;\n    this.setScrollTop = function(scrollTop) {\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n            return;\n\n        this.$scrollTop = scrollTop;\n        this._signal(\"changeScrollTop\", scrollTop);\n    };\n    this.getScrollTop = function() {\n        return this.$scrollTop;\n    };\n\n    this.$scrollLeft = 0;\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n            return;\n\n        this.$scrollLeft = scrollLeft;\n        this._signal(\"changeScrollLeft\", scrollLeft);\n    };\n    this.getScrollLeft = function() {\n        return this.$scrollLeft;\n    };\n    this.getScreenWidth = function() {\n        this.$computeWidth();\n        if (this.lineWidgets) \n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n        return this.screenWidth;\n    };\n    \n    this.getLineWidgetMaxWidth = function() {\n        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;\n        var width = 0;\n        this.lineWidgets.forEach(function(w) {\n            if (w && w.screenWidth > width)\n                width = w.screenWidth;\n        });\n        return this.lineWidgetWidth = width;\n    };\n\n    this.$computeWidth = function(force) {\n        if (this.$modified || force) {\n            this.$modified = false;\n\n            if (this.$useWrapMode)\n                return this.screenWidth = this.$wrapLimit;\n\n            var lines = this.doc.getAllLines();\n            var cache = this.$rowLengthCache;\n            var longestScreenLine = 0;\n            var foldIndex = 0;\n            var foldLine = this.$foldData[foldIndex];\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\n            var len = lines.length;\n\n            for (var i = 0; i < len; i++) {\n                if (i > foldStart) {\n                    i = foldLine.end.row + 1;\n                    if (i >= len)\n                        break;\n                    foldLine = this.$foldData[foldIndex++];\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n\n                if (cache[i] == null)\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n\n                if (cache[i] > longestScreenLine)\n                    longestScreenLine = cache[i];\n            }\n            this.screenWidth = longestScreenLine;\n        }\n    };\n    this.getLine = function(row) {\n        return this.doc.getLine(row);\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.doc.getLines(firstRow, lastRow);\n    };\n    this.getLength = function() {\n        return this.doc.getLength();\n    };\n    this.getTextRange = function(range) {\n        return this.doc.getTextRange(range || this.selection.getRange());\n    };\n    this.insert = function(position, text) {\n        return this.doc.insert(position, text);\n    };\n    this.remove = function(range) {\n        return this.doc.remove(range);\n    };\n    this.removeFullLines = function(firstRow, lastRow){\n        return this.doc.removeFullLines(firstRow, lastRow);\n    };\n    this.undoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = deltas.length - 1; i != -1; i--) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.revertDelta(delta);\n            } else if (delta.folds) {\n                this.addFolds(delta.folds);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionBefore)\n                this.selection.fromJSON(deltas.selectionBefore);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\n        }\n        this.$fromUndo = false;\n    };\n    this.redoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.applyDelta(delta);\n            }\n        }\n\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionAfter)\n                this.selection.fromJSON(deltas.selectionAfter);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\n        }\n        this.$fromUndo = false;\n    };\n    this.setUndoSelect = function(enable) {\n        this.$undoSelect = enable;\n    };\n\n    this.$getUndoSelection = function(deltas, isUndo) {\n        function isInsert(delta) {\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\n        }\n\n        var range, point;\n        var lastDeltaIsInsert;\n\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (!delta.start) continue; // skip folds\n            if (!range) {\n                if (isInsert(delta)) {\n                    range = Range.fromPoints(delta.start, delta.end);\n                    lastDeltaIsInsert = true;\n                } else {\n                    range = Range.fromPoints(delta.start, delta.start);\n                    lastDeltaIsInsert = false;\n                }\n                continue;\n            }\n            \n            if (isInsert(delta)) {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range.setStart(point);\n                }\n                point = delta.end;\n                if (range.compare(point.row, point.column) == 1) {\n                    range.setEnd(point);\n                }\n                lastDeltaIsInsert = true;\n            } else {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n                lastDeltaIsInsert = false;\n            }\n        }\n        return range;\n    };\n    this.replace = function(range, text) {\n        return this.doc.replace(range, text);\n    };\n    this.moveText = function(fromRange, toPosition, copy) {\n        var text = this.getTextRange(fromRange);\n        var folds = this.getFoldsInRange(fromRange);\n\n        var toRange = Range.fromPoints(toPosition, toPosition);\n        if (!copy) {\n            this.remove(fromRange);\n            var rowDiff = fromRange.start.row - fromRange.end.row;\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n            if (collDiff) {\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n                    toRange.start.column += collDiff;\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n                    toRange.end.column += collDiff;\n            }\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n                toRange.start.row += rowDiff;\n                toRange.end.row += rowDiff;\n            }\n        }\n\n        toRange.end = this.insert(toRange.start, text);\n        if (folds.length) {\n            var oldStart = fromRange.start;\n            var newStart = toRange.start;\n            var rowDiff = newStart.row - oldStart.row;\n            var collDiff = newStart.column - oldStart.column;\n            this.addFolds(folds.map(function(x) {\n                x = x.clone();\n                if (x.start.row == oldStart.row)\n                    x.start.column += collDiff;\n                if (x.end.row == oldStart.row)\n                    x.end.column += collDiff;\n                x.start.row += rowDiff;\n                x.end.row += rowDiff;\n                return x;\n            }));\n        }\n\n        return toRange;\n    };\n    this.indentRows = function(startRow, endRow, indentString) {\n        indentString = indentString.replace(/\\t/g, this.getTabString());\n        for (var row=startRow; row<=endRow; row++)\n            this.doc.insertInLine({row: row, column: 0}, indentString);\n    };\n    this.outdentRows = function (range) {\n        var rowRange = range.collapseRows();\n        var deleteRange = new Range(0, 0, 0, 0);\n        var size = this.getTabSize();\n\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n            var line = this.getLine(i);\n\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            for (var j = 0; j < size; ++j)\n                if (line.charAt(j) != ' ')\n                    break;\n            if (j < size && line.charAt(j) == '\\t') {\n                deleteRange.start.column = j;\n                deleteRange.end.column = j + 1;\n            } else {\n                deleteRange.start.column = 0;\n                deleteRange.end.column = j;\n            }\n            this.remove(deleteRange);\n        }\n    };\n\n    this.$moveLines = function(firstRow, lastRow, dir) {\n        firstRow = this.getRowFoldStart(firstRow);\n        lastRow = this.getRowFoldEnd(lastRow);\n        if (dir < 0) {\n            var row = this.getRowFoldStart(firstRow + dir);\n            if (row < 0) return 0;\n            var diff = row-firstRow;\n        } else if (dir > 0) {\n            var row = this.getRowFoldEnd(lastRow + dir);\n            if (row > this.doc.getLength()-1) return 0;\n            var diff = row-lastRow;\n        } else {\n            firstRow = this.$clipRowToDocument(firstRow);\n            lastRow = this.$clipRowToDocument(lastRow);\n            var diff = lastRow - firstRow + 1;\n        }\n\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n        var folds = this.getFoldsInRange(range).map(function(x){\n            x = x.clone();\n            x.start.row += diff;\n            x.end.row += diff;\n            return x;\n        });\n        \n        var lines = dir == 0\n            ? this.doc.getLines(firstRow, lastRow)\n            : this.doc.removeFullLines(firstRow, lastRow);\n        this.doc.insertFullLines(firstRow+diff, lines);\n        folds.length && this.addFolds(folds);\n        return diff;\n    };\n    this.moveLinesUp = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, -1);\n    };\n    this.moveLinesDown = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 1);\n    };\n    this.duplicateLines = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 0);\n    };\n\n\n    this.$clipRowToDocument = function(row) {\n        return Math.max(0, Math.min(row, this.doc.getLength()-1));\n    };\n\n    this.$clipColumnToRow = function(row, column) {\n        if (column < 0)\n            return 0;\n        return Math.min(this.doc.getLine(row).length, column);\n    };\n\n\n    this.$clipPositionToDocument = function(row, column) {\n        column = Math.max(0, column);\n\n        if (row < 0) {\n            row = 0;\n            column = 0;\n        } else {\n            var len = this.doc.getLength();\n            if (row >= len) {\n                row = len - 1;\n                column = this.doc.getLine(len-1).length;\n            } else {\n                column = Math.min(this.doc.getLine(row).length, column);\n            }\n        }\n\n        return {\n            row: row,\n            column: column\n        };\n    };\n\n    this.$clipRangeToDocument = function(range) {\n        if (range.start.row < 0) {\n            range.start.row = 0;\n            range.start.column = 0;\n        } else {\n            range.start.column = this.$clipColumnToRow(\n                range.start.row,\n                range.start.column\n            );\n        }\n\n        var len = this.doc.getLength() - 1;\n        if (range.end.row > len) {\n            range.end.row = len;\n            range.end.column = this.doc.getLine(len).length;\n        } else {\n            range.end.column = this.$clipColumnToRow(\n                range.end.row,\n                range.end.column\n            );\n        }\n        return range;\n    };\n    this.$wrapLimit = 80;\n    this.$useWrapMode = false;\n    this.$wrapLimitRange = {\n        min : null,\n        max : null\n    };\n    this.setUseWrapMode = function(useWrapMode) {\n        if (useWrapMode != this.$useWrapMode) {\n            this.$useWrapMode = useWrapMode;\n            this.$modified = true;\n            this.$resetRowCache(0);\n            if (useWrapMode) {\n                var len = this.getLength();\n                this.$wrapData = Array(len);\n                this.$updateWrapData(0, len - 1);\n            }\n\n            this._signal(\"changeWrapMode\");\n        }\n    };\n    this.getUseWrapMode = function() {\n        return this.$useWrapMode;\n    };\n    this.setWrapLimitRange = function(min, max) {\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n            this.$wrapLimitRange = { min: min, max: max };\n            this.$modified = true;\n            this.$bidiHandler.markAsDirty();\n            if (this.$useWrapMode)\n                this._signal(\"changeWrapMode\");\n        }\n    };\n    this.adjustWrapLimit = function(desiredLimit, $printMargin) {\n        var limits = this.$wrapLimitRange;\n        if (limits.max < 0)\n            limits = {min: $printMargin, max: $printMargin};\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n            this.$wrapLimit = wrapLimit;\n            this.$modified = true;\n            if (this.$useWrapMode) {\n                this.$updateWrapData(0, this.getLength() - 1);\n                this.$resetRowCache(0);\n                this._signal(\"changeWrapLimit\");\n            }\n            return true;\n        }\n        return false;\n    };\n\n    this.$constrainWrapLimit = function(wrapLimit, min, max) {\n        if (min)\n            wrapLimit = Math.max(min, wrapLimit);\n\n        if (max)\n            wrapLimit = Math.min(max, wrapLimit);\n\n        return wrapLimit;\n    };\n    this.getWrapLimit = function() {\n        return this.$wrapLimit;\n    };\n    this.setWrapLimit = function (limit) {\n        this.setWrapLimitRange(limit, limit);\n    };\n    this.getWrapLimitRange = function() {\n        return {\n            min : this.$wrapLimitRange.min,\n            max : this.$wrapLimitRange.max\n        };\n    };\n\n    this.$updateInternalDataOnChange = function(delta) {\n        var useWrapMode = this.$useWrapMode;\n        var action = delta.action;\n        var start = delta.start;\n        var end = delta.end;\n        var firstRow = start.row;\n        var lastRow = end.row;\n        var len = lastRow - firstRow;\n        var removedFolds = null;\n        \n        this.$updating = true;\n        if (len != 0) {\n            if (action === \"remove\") {\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n\n                var foldLines = this.$foldData;\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                var foldLine = this.getFoldLine(end.row);\n                var idx = 0;\n                if (foldLine) {\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n                    foldLine.shiftRow(-len);\n\n                    var foldLineBefore = this.getFoldLine(firstRow);\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\n                        foldLineBefore.merge(foldLine);\n                        foldLine = foldLineBefore;\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= end.row) {\n                        foldLine.shiftRow(-len);\n                    }\n                }\n\n                lastRow = firstRow;\n            } else {\n                var args = Array(len);\n                args.unshift(firstRow, 0);\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\n                arr.splice.apply(arr, args);\n                var foldLines = this.$foldData;\n                var foldLine = this.getFoldLine(firstRow);\n                var idx = 0;\n                if (foldLine) {\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\n                    if (cmp == 0) {\n                        foldLine = foldLine.split(start.row, start.column);\n                        if (foldLine) {\n                            foldLine.shiftRow(len);\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n                        }\n                    } else\n                    if (cmp == -1) {\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n                        foldLine.shiftRow(len);\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= firstRow) {\n                        foldLine.shiftRow(len);\n                    }\n                }\n            }\n        } else {\n            len = Math.abs(delta.start.column - delta.end.column);\n            if (action === \"remove\") {\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                len = -len;\n            }\n            var foldLine = this.getFoldLine(firstRow);\n            if (foldLine) {\n                foldLine.addRemoveChars(firstRow, start.column, len);\n            }\n        }\n\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n        }\n        this.$updating = false;\n\n        if (useWrapMode)\n            this.$updateWrapData(firstRow, lastRow);\n        else\n            this.$updateRowLengthCache(firstRow, lastRow);\n\n        return removedFolds;\n    };\n\n    this.$updateRowLengthCache = function(firstRow, lastRow, b) {\n        this.$rowLengthCache[firstRow] = null;\n        this.$rowLengthCache[lastRow] = null;\n    };\n\n    this.$updateWrapData = function(firstRow, lastRow) {\n        var lines = this.doc.getAllLines();\n        var tabSize = this.getTabSize();\n        var wrapData = this.$wrapData;\n        var wrapLimit = this.$wrapLimit;\n        var tokens;\n        var foldLine;\n\n        var row = firstRow;\n        lastRow = Math.min(lastRow, lines.length - 1);\n        while (row <= lastRow) {\n            foldLine = this.getFoldLine(row, foldLine);\n            if (!foldLine) {\n                tokens = this.$getDisplayTokens(lines[row]);\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row ++;\n            } else {\n                tokens = [];\n                foldLine.walk(function(placeholder, row, column, lastColumn) {\n                        var walkTokens;\n                        if (placeholder != null) {\n                            walkTokens = this.$getDisplayTokens(\n                                            placeholder, tokens.length);\n                            walkTokens[0] = PLACEHOLDER_START;\n                            for (var i = 1; i < walkTokens.length; i++) {\n                                walkTokens[i] = PLACEHOLDER_BODY;\n                            }\n                        } else {\n                            walkTokens = this.$getDisplayTokens(\n                                lines[row].substring(lastColumn, column),\n                                tokens.length);\n                        }\n                        tokens = tokens.concat(walkTokens);\n                    }.bind(this),\n                    foldLine.end.row,\n                    lines[foldLine.end.row].length + 1\n                );\n\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row = foldLine.end.row + 1;\n            }\n        }\n    };\n    var CHAR = 1,\n        CHAR_EXT = 2,\n        PLACEHOLDER_START = 3,\n        PLACEHOLDER_BODY =  4,\n        PUNCTUATION = 9,\n        SPACE = 10,\n        TAB = 11,\n        TAB_SPACE = 12;\n\n\n    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {\n        if (tokens.length == 0) {\n            return [];\n        }\n\n        var splits = [];\n        var displayLength = tokens.length;\n        var lastSplit = 0, lastDocSplit = 0;\n\n        var isCode = this.$wrapAsCode;\n\n        var indentedSoftWrap = this.$indentedSoftWrap;\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\n\n        function getWrapIndent() {\n            var indentation = 0;\n            if (maxIndent === 0)\n                return indentation;\n            if (indentedSoftWrap) {\n                for (var i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    if (token == SPACE)\n                        indentation += 1;\n                    else if (token == TAB)\n                        indentation += tabSize;\n                    else if (token == TAB_SPACE)\n                        continue;\n                    else\n                        break;\n                }\n            }\n            if (isCode && indentedSoftWrap !== false)\n                indentation += tabSize;\n            return Math.min(indentation, maxIndent);\n        }\n        function addSplit(screenPos) {\n            var len = screenPos - lastSplit;\n            for (var i = lastSplit; i < screenPos; i++) {\n                var ch = tokens[i];\n                if (ch === 12 || ch === 2) len -= 1;\n            }\n\n            if (!splits.length) {\n                indent = getWrapIndent();\n                splits.indent = indent;\n            }\n            lastDocSplit += len;\n            splits.push(lastDocSplit);\n            lastSplit = screenPos;\n        }\n        var indent = 0;\n        while (displayLength - lastSplit > wrapLimit - indent) {\n            var split = lastSplit + wrapLimit - indent;\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n                addSplit(split);\n                continue;\n            }\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n                for (split; split != lastSplit - 1; split--) {\n                    if (tokens[split] == PLACEHOLDER_START) {\n                        break;\n                    }\n                }\n                if (split > lastSplit) {\n                    addSplit(split);\n                    continue;\n                }\n                split = lastSplit + wrapLimit;\n                for (split; split < tokens.length; split++) {\n                    if (tokens[split] != PLACEHOLDER_BODY) {\n                        break;\n                    }\n                }\n                if (split == tokens.length) {\n                    break;  // Breaks the while-loop.\n                }\n                addSplit(split);\n                continue;\n            }\n            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                split --;\n            }\n            if (isCode) {\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                    split --;\n                }\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\n                    split --;\n                }\n            } else {\n                while (split > minSplit && tokens[split] < SPACE) {\n                    split --;\n                }\n            }\n            if (split > minSplit) {\n                addSplit(++split);\n                continue;\n            }\n            split = lastSplit + wrapLimit;\n            if (tokens[split] == CHAR_EXT)\n                split--;\n            addSplit(split - indent);\n        }\n        return splits;\n    };\n    this.$getDisplayTokens = function(str, offset) {\n        var arr = [];\n        var tabSize;\n        offset = offset || 0;\n\n        for (var i = 0; i < str.length; i++) {\n            var c = str.charCodeAt(i);\n            if (c == 9) {\n                tabSize = this.getScreenTabSize(arr.length + offset);\n                arr.push(TAB);\n                for (var n = 1; n < tabSize; n++) {\n                    arr.push(TAB_SPACE);\n                }\n            }\n            else if (c == 32) {\n                arr.push(SPACE);\n            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {\n                arr.push(PUNCTUATION);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                arr.push(CHAR, CHAR_EXT);\n            } else {\n                arr.push(CHAR);\n            }\n        }\n        return arr;\n    };\n    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n        if (maxScreenColumn == 0)\n            return [0, 0];\n        if (maxScreenColumn == null)\n            maxScreenColumn = Infinity;\n        screenColumn = screenColumn || 0;\n\n        var c, column;\n        for (column = 0; column < str.length; column++) {\n            c = str.charCodeAt(column);\n            if (c == 9) {\n                screenColumn += this.getScreenTabSize(screenColumn);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                screenColumn += 2;\n            } else {\n                screenColumn += 1;\n            }\n            if (screenColumn > maxScreenColumn) {\n                break;\n            }\n        }\n\n        return [screenColumn, column];\n    };\n\n    this.lineWidgets = null;\n    this.getRowLength = function(row) {\n        if (this.lineWidgets)\n            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else \n            h = 0;\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1 + h;\n        } else {\n            return this.$wrapData[row].length + 1 + h;\n        }\n    };\n    this.getRowLineCount = function(row) {\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1;\n        } else {\n            return this.$wrapData[row].length + 1;\n        }\n    };\n\n    this.getRowWrapIndent = function(screenRow) {\n        if (this.$useWrapMode) {\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n            var splits = this.$wrapData[pos.row];\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\n        } else {\n            return 0;\n        }\n    };\n    this.getScreenLastRowColumn = function(screenRow) {\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n        return this.documentToScreenColumn(pos.row, pos.column);\n    };\n    this.getDocumentLastRowColumn = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.getScreenLastRowColumn(screenRow);\n    };\n    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n    };\n    this.getRowSplitData = function(row) {\n        if (!this.$useWrapMode) {\n            return undefined;\n        } else {\n            return this.$wrapData[row];\n        }\n    };\n    this.getScreenTabSize = function(screenColumn) {\n        return this.$tabSize - screenColumn % this.$tabSize;\n    };\n\n\n    this.screenToDocumentRow = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n    };\n\n\n    this.screenToDocumentColumn = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n    };\n    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {\n        if (screenRow < 0)\n            return {row: 0, column: 0};\n\n        var line;\n        var docRow = 0;\n        var docColumn = 0;\n        var column;\n        var row = 0;\n        var rowLength = 0;\n\n        var rowCache = this.$screenRowCache;\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var docRow = this.$docRowCache[i];\n            var doCache = screenRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var maxRow = this.getLength() - 1;\n        var foldLine = this.getNextFoldLine(docRow);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (row <= screenRow) {\n            rowLength = this.getRowLength(docRow);\n            if (row + rowLength > screenRow || docRow >= maxRow) {\n                break;\n            } else {\n                row += rowLength;\n                docRow++;\n                if (docRow > foldStart) {\n                    docRow = foldLine.end.row+1;\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n            }\n\n            if (doCache) {\n                this.$docRowCache.push(docRow);\n                this.$screenRowCache.push(row);\n            }\n        }\n\n        if (foldLine && foldLine.start.row <= docRow) {\n            line = this.getFoldDisplayLine(foldLine);\n            docRow = foldLine.start.row;\n        } else if (row + rowLength <= screenRow || docRow > maxRow) {\n            return {\n                row: maxRow,\n                column: this.getLine(maxRow).length\n            };\n        } else {\n            line = this.getLine(docRow);\n            foldLine = null;\n        }\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\n        if (this.$useWrapMode) {\n            var splits = this.$wrapData[docRow];\n            if (splits) {\n                column = splits[splitIndex];\n                if(splitIndex > 0 && splits.length) {\n                    wrapIndent = splits.indent;\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n                    line = line.substring(docColumn);\n                }\n            }\n        }\n\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\n\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\n        if (this.$useWrapMode && docColumn >= column)\n            docColumn = column - 1;\n\n        if (foldLine)\n            return foldLine.idxToPosition(docColumn);\n\n        return {row: docRow, column: docColumn};\n    };\n    this.documentToScreenPosition = function(docRow, docColumn) {\n        if (typeof docColumn === \"undefined\")\n            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);\n        else\n            pos = this.$clipPositionToDocument(docRow, docColumn);\n\n        docRow = pos.row;\n        docColumn = pos.column;\n\n        var screenRow = 0;\n        var foldStartRow = null;\n        var fold = null;\n        fold = this.getFoldAt(docRow, docColumn, 1);\n        if (fold) {\n            docRow = fold.start.row;\n            docColumn = fold.start.column;\n        }\n\n        var rowEnd, row = 0;\n\n\n        var rowCache = this.$docRowCache;\n        var i = this.$getRowCacheIndex(rowCache, docRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var screenRow = this.$screenRowCache[i];\n            var doCache = docRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var foldLine = this.getNextFoldLine(row);\n        var foldStart = foldLine ?foldLine.start.row :Infinity;\n\n        while (row < docRow) {\n            if (row >= foldStart) {\n                rowEnd = foldLine.end.row + 1;\n                if (rowEnd > docRow)\n                    break;\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n                foldStart = foldLine ?foldLine.start.row :Infinity;\n            }\n            else {\n                rowEnd = row + 1;\n            }\n\n            screenRow += this.getRowLength(row);\n            row = rowEnd;\n\n            if (doCache) {\n                this.$docRowCache.push(row);\n                this.$screenRowCache.push(screenRow);\n            }\n        }\n        var textLine = \"\";\n        if (foldLine && row >= foldStart) {\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n            foldStartRow = foldLine.start.row;\n        } else {\n            textLine = this.getLine(docRow).substring(0, docColumn);\n            foldStartRow = docRow;\n        }\n        var wrapIndent = 0;\n        if (this.$useWrapMode) {\n            var wrapRow = this.$wrapData[foldStartRow];\n            if (wrapRow) {\n                var screenRowOffset = 0;\n                while (textLine.length >= wrapRow[screenRowOffset]) {\n                    screenRow ++;\n                    screenRowOffset++;\n                }\n                textLine = textLine.substring(\n                    wrapRow[screenRowOffset - 1] || 0, textLine.length\n                );\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\n            }\n        }\n\n        return {\n            row: screenRow,\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\n        };\n    };\n    this.documentToScreenColumn = function(row, docColumn) {\n        return this.documentToScreenPosition(row, docColumn).column;\n    };\n    this.documentToScreenRow = function(docRow, docColumn) {\n        return this.documentToScreenPosition(docRow, docColumn).row;\n    };\n    this.getScreenLength = function() {\n        var screenRows = 0;\n        var fold = null;\n        if (!this.$useWrapMode) {\n            screenRows = this.getLength();\n            var foldData = this.$foldData;\n            for (var i = 0; i < foldData.length; i++) {\n                fold = foldData[i];\n                screenRows -= fold.end.row - fold.start.row;\n            }\n        } else {\n            var lastRow = this.$wrapData.length;\n            var row = 0, i = 0;\n            var fold = this.$foldData[i++];\n            var foldStart = fold ? fold.start.row :Infinity;\n\n            while (row < lastRow) {\n                var splits = this.$wrapData[row];\n                screenRows += splits ? splits.length + 1 : 1;\n                row ++;\n                if (row > foldStart) {\n                    row = fold.end.row+1;\n                    fold = this.$foldData[i++];\n                    foldStart = fold ?fold.start.row :Infinity;\n                }\n            }\n        }\n        if (this.lineWidgets)\n            screenRows += this.$getWidgetScreenLength();\n\n        return screenRows;\n    };\n    this.$setFontMetrics = function(fm) {\n        if (!this.$enableVarChar) return;\n        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n            if (maxScreenColumn === 0)\n                return [0, 0];\n            if (!maxScreenColumn)\n                maxScreenColumn = Infinity;\n            screenColumn = screenColumn || 0;\n            \n            var c, column;\n            for (column = 0; column < str.length; column++) {\n                c = str.charAt(column);\n                if (c === \"\\t\") {\n                    screenColumn += this.getScreenTabSize(screenColumn);\n                } else {\n                    screenColumn += fm.getCharacterWidth(c);\n                }\n                if (screenColumn > maxScreenColumn) {\n                    break;\n                }\n            }\n            \n            return [screenColumn, column];\n        };\n    };\n    \n    this.destroy = function() {\n        if (this.bgTokenizer) {\n            this.bgTokenizer.setDocument(null);\n            this.bgTokenizer = null;\n        }\n        this.$stopWorker();\n    };\n\n    this.isFullWidth = isFullWidth;\n    function isFullWidth(c) {\n        if (c < 0x1100)\n            return false;\n        return c >= 0x1100 && c <= 0x115F ||\n               c >= 0x11A3 && c <= 0x11A7 ||\n               c >= 0x11FA && c <= 0x11FF ||\n               c >= 0x2329 && c <= 0x232A ||\n               c >= 0x2E80 && c <= 0x2E99 ||\n               c >= 0x2E9B && c <= 0x2EF3 ||\n               c >= 0x2F00 && c <= 0x2FD5 ||\n               c >= 0x2FF0 && c <= 0x2FFB ||\n               c >= 0x3000 && c <= 0x303E ||\n               c >= 0x3041 && c <= 0x3096 ||\n               c >= 0x3099 && c <= 0x30FF ||\n               c >= 0x3105 && c <= 0x312D ||\n               c >= 0x3131 && c <= 0x318E ||\n               c >= 0x3190 && c <= 0x31BA ||\n               c >= 0x31C0 && c <= 0x31E3 ||\n               c >= 0x31F0 && c <= 0x321E ||\n               c >= 0x3220 && c <= 0x3247 ||\n               c >= 0x3250 && c <= 0x32FE ||\n               c >= 0x3300 && c <= 0x4DBF ||\n               c >= 0x4E00 && c <= 0xA48C ||\n               c >= 0xA490 && c <= 0xA4C6 ||\n               c >= 0xA960 && c <= 0xA97C ||\n               c >= 0xAC00 && c <= 0xD7A3 ||\n               c >= 0xD7B0 && c <= 0xD7C6 ||\n               c >= 0xD7CB && c <= 0xD7FB ||\n               c >= 0xF900 && c <= 0xFAFF ||\n               c >= 0xFE10 && c <= 0xFE19 ||\n               c >= 0xFE30 && c <= 0xFE52 ||\n               c >= 0xFE54 && c <= 0xFE66 ||\n               c >= 0xFE68 && c <= 0xFE6B ||\n               c >= 0xFF01 && c <= 0xFF60 ||\n               c >= 0xFFE0 && c <= 0xFFE6;\n    }\n\n}).call(EditSession.prototype);\n\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\n\n\nconfig.defineOptions(EditSession.prototype, \"session\", {\n    wrap: {\n        set: function(value) {\n            if (!value || value == \"off\")\n                value = false;\n            else if (value == \"free\")\n                value = true;\n            else if (value == \"printMargin\")\n                value = -1;\n            else if (typeof value == \"string\")\n                value = parseInt(value, 10) || false;\n\n            if (this.$wrap == value)\n                return;\n            this.$wrap = value;\n            if (!value) {\n                this.setUseWrapMode(false);\n            } else {\n                var col = typeof value == \"number\" ? value : null;\n                this.setWrapLimitRange(col, col);\n                this.setUseWrapMode(true);\n            }\n        },\n        get: function() {\n            if (this.getUseWrapMode()) {\n                if (this.$wrap == -1)\n                    return \"printMargin\";\n                if (!this.getWrapLimitRange().min)\n                    return \"free\";\n                return this.$wrap;\n            }\n            return \"off\";\n        },\n        handlesSet: true\n    },    \n    wrapMethod: {\n        set: function(val) {\n            val = val == \"auto\"\n                ? this.$mode.type != \"text\"\n                : val != \"text\";\n            if (val != this.$wrapAsCode) {\n                this.$wrapAsCode = val;\n                if (this.$useWrapMode) {\n                    this.$useWrapMode = false;\n                    this.setUseWrapMode(true);\n                }\n            }\n        },\n        initialValue: \"auto\"\n    },\n    indentedSoftWrap: {\n        set: function() {\n            if (this.$useWrapMode) {\n                this.$useWrapMode = false;\n                this.setUseWrapMode(true);\n            }\n        },\n        initialValue: true \n    },\n    firstLineNumber: {\n        set: function() {this._signal(\"changeBreakpoint\");},\n        initialValue: 1\n    },\n    useWorker: {\n        set: function(useWorker) {\n            this.$useWorker = useWorker;\n\n            this.$stopWorker();\n            if (useWorker)\n                this.$startWorker();\n        },\n        initialValue: true\n    },\n    useSoftTabs: {initialValue: true},\n    tabSize: {\n        set: function(tabSize) {\n            tabSize = parseInt(tabSize);\n            if (isNaN(tabSize) || this.$tabSize === tabSize) return;\n\n            this.$modified = true;\n            this.$rowLengthCache = [];\n            this.$tabSize = tabSize;\n            this._signal(\"changeTabSize\");\n        },\n        initialValue: 4,\n        handlesSet: true\n    },\n    navigateWithinSoftTabs: {initialValue: false},\n    foldStyle: {\n        set: function(val) {this.setFoldStyle(val);},\n        handlesSet: true\n    },\n    overwrite: {\n        set: function(val) {this._signal(\"changeOverwrite\");},\n        initialValue: false\n    },\n    newLineMode: {\n        set: function(val) {this.doc.setNewLineMode(val);},\n        get: function() {return this.doc.getNewLineMode();},\n        handlesSet: true\n    },\n    mode: {\n        set: function(val) { this.setMode(val); },\n        get: function() { return this.$modeId; },\n        handlesSet: true\n    }\n});\n\nexports.EditSession = EditSession;\n});\n\nace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar Search = function() {\n    this.$options = {};\n};\n\n(function() {\n    this.set = function(options) {\n        oop.mixin(this.$options, options);\n        return this;\n    };\n    this.getOptions = function() {\n        return lang.copyObject(this.$options);\n    };\n    this.setOptions = function(options) {\n        this.$options = options;\n    };\n    this.find = function(session) {\n        var options = this.$options;\n        var iterator = this.$matchIterator(session, options);\n        if (!iterator)\n            return false;\n\n        var firstRange = null;\n        iterator.forEach(function(sr, sc, er, ec) {\n            firstRange = new Range(sr, sc, er, ec);\n            if (sc == ec && options.start && options.start.start\n                && options.skipCurrent != false && firstRange.isEqual(options.start)\n            ) {\n                firstRange = null;\n                return false;\n            }\n            \n            return true;\n        });\n\n        return firstRange;\n    };\n    this.findAll = function(session) {\n        var options = this.$options;\n        if (!options.needle)\n            return [];\n        this.$assembleRegExp(options);\n\n        var range = options.range;\n        var lines = range\n            ? session.getLines(range.start.row, range.end.row)\n            : session.doc.getAllLines();\n\n        var ranges = [];\n        var re = options.re;\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var maxRow = lines.length - len;\n            var prevRange;\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n                for (var j = 0; j < len; j++)\n                    if (lines[row + j].search(re[j]) == -1)\n                        continue outer;\n                \n                var startLine = lines[row];\n                var line = lines[row + len - 1];\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n                var endIndex = line.match(re[len - 1])[0].length;\n                \n                if (prevRange && prevRange.end.row === row &&\n                    prevRange.end.column > startIndex\n                ) {\n                    continue;\n                }\n                ranges.push(prevRange = new Range(\n                    row, startIndex, row + len - 1, endIndex\n                ));\n                if (len > 2)\n                    row = row + len - 2;\n            }\n        } else {\n            for (var i = 0; i < lines.length; i++) {\n                var matches = lang.getMatchOffsets(lines[i], re);\n                for (var j = 0; j < matches.length; j++) {\n                    var match = matches[j];\n                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n                }\n            }\n        }\n\n        if (range) {\n            var startColumn = range.start.column;\n            var endColumn = range.start.column;\n            var i = 0, j = ranges.length - 1;\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)\n                i++;\n\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)\n                j--;\n            \n            ranges = ranges.slice(i, j + 1);\n            for (i = 0, j = ranges.length; i < j; i++) {\n                ranges[i].start.row += range.start.row;\n                ranges[i].end.row += range.start.row;\n            }\n        }\n\n        return ranges;\n    };\n    this.replace = function(input, replacement) {\n        var options = this.$options;\n\n        var re = this.$assembleRegExp(options);\n        if (options.$isMultiLine)\n            return replacement;\n\n        if (!re)\n            return;\n\n        var match = re.exec(input);\n        if (!match || match[0].length != input.length)\n            return null;\n        \n        replacement = input.replace(re, replacement);\n        if (options.preserveCase) {\n            replacement = replacement.split(\"\");\n            for (var i = Math.min(input.length, input.length); i--; ) {\n                var ch = input[i];\n                if (ch && ch.toLowerCase() != ch)\n                    replacement[i] = replacement[i].toUpperCase();\n                else\n                    replacement[i] = replacement[i].toLowerCase();\n            }\n            replacement = replacement.join(\"\");\n        }\n        \n        return replacement;\n    };\n\n    this.$assembleRegExp = function(options, $disableFakeMultiline) {\n        if (options.needle instanceof RegExp)\n            return options.re = options.needle;\n\n        var needle = options.needle;\n\n        if (!options.needle)\n            return options.re = false;\n\n        if (!options.regExp)\n            needle = lang.escapeRegExp(needle);\n\n        if (options.wholeWord)\n            needle = addWordBoundary(needle, options);\n\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n        if (options.$isMultiLine)\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n\n        try {\n            var re = new RegExp(needle, modifier);\n        } catch(e) {\n            re = false;\n        }\n        return options.re = re;\n    };\n\n    this.$assembleMultilineRegExp = function(needle, modifier) {\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n        var re = [];\n        for (var i = 0; i < parts.length; i++) try {\n            re.push(new RegExp(parts[i], modifier));\n        } catch(e) {\n            return false;\n        }\n        return re;\n    };\n\n    this.$matchIterator = function(session, options) {\n        var re = this.$assembleRegExp(options);\n        if (!re)\n            return false;\n        var backwards = options.backwards == true;\n        var skipCurrent = options.skipCurrent != false;\n\n        var range = options.range;\n        var start = options.start;\n        if (!start)\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n         \n        if (start.start)\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n\n        var firstRow = range ? range.start.row : 0;\n        var lastRow = range ? range.end.row : session.getLength() - 1;\n        \n        if (backwards) {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row--; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n            };\n        }\n        else {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row = row + 1; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n            };\n        }\n        \n        if (options.$isMultiLine) {\n            var len = re.length;\n            var forEachInLine = function(row, offset, callback) {\n                var startRow = backwards ? row - len + 1 : row;\n                if (startRow < 0) return;\n                var line = session.getLine(startRow);\n                var startIndex = line.search(re[0]);\n                if (!backwards && startIndex < offset || startIndex === -1) return;\n                for (var i = 1; i < len; i++) {\n                    line = session.getLine(startRow + i);\n                    if (line.search(re[i]) == -1)\n                        return;\n                }\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (backwards && endIndex > offset) return;\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\n                    return true;\n            };\n        }\n        else if (backwards) {\n            var forEachInLine = function(row, endIndex, callback) {\n                var line = session.getLine(row);\n                var matches = [];\n                var m, last = 0;\n                re.lastIndex = 0;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (!length) {\n                        if (last >= line.length) break;\n                        re.lastIndex = last += 1;\n                    }\n                    if (m.index + length > endIndex)\n                        break;\n                    matches.push(m.index, length);\n                }\n                for (var i = matches.length - 1; i >= 0; i -= 2) {\n                    var column = matches[i - 1];\n                    var length = matches[i];\n                    if (callback(row, column, row, column + length))\n                        return true;\n                }\n            };\n        }\n        else {\n            var forEachInLine = function(row, startIndex, callback) {\n                var line = session.getLine(row);\n                var last;\n                var m;\n                re.lastIndex = startIndex;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (callback(row, last, row,last + length))\n                        return true;\n                    if (!length) {\n                        re.lastIndex = last += 1;\n                        if (last >= line.length) return false;\n                    }\n                }\n            };\n        }\n        return {forEach: forEach};\n    };\n\n}).call(Search.prototype);\n\nfunction addWordBoundary(needle, options) {\n    function wordBoundary(c) {\n        if (/\\w/.test(c) || options.regExp) return \"\\\\b\";\n        return \"\";\n    }\n    return wordBoundary(needle[0]) + needle\n        + wordBoundary(needle[needle.length - 1]);\n}\n\nexports.Search = Search;\n});\n\nace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil = require(\"../lib/keys\");\nvar useragent = require(\"../lib/useragent\");\nvar KEY_MODS = keyUtil.KEY_MODS;\n\nfunction HashHandler(config, platform) {\n    this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n    this.commands = {};\n    this.commandKeyBinding = {};\n    this.addCommands(config);\n    this.$singleCommand = true;\n}\n\nfunction MultiHashHandler(config, platform) {\n    HashHandler.call(this, config, platform);\n    this.$singleCommand = false;\n}\n\nMultiHashHandler.prototype = HashHandler.prototype;\n\n(function() {\n    \n\n    this.addCommand = function(command) {\n        if (this.commands[command.name])\n            this.removeCommand(command);\n\n        this.commands[command.name] = command;\n\n        if (command.bindKey)\n            this._buildKeyHash(command);\n    };\n\n    this.removeCommand = function(command, keepCommand) {\n        var name = command && (typeof command === 'string' ? command : command.name);\n        command = this.commands[name];\n        if (!keepCommand)\n            delete this.commands[name];\n        var ckb = this.commandKeyBinding;\n        for (var keyId in ckb) {\n            var cmdGroup = ckb[keyId];\n            if (cmdGroup == command) {\n                delete ckb[keyId];\n            } else if (Array.isArray(cmdGroup)) {\n                var i = cmdGroup.indexOf(command);\n                if (i != -1) {\n                    cmdGroup.splice(i, 1);\n                    if (cmdGroup.length == 1)\n                        ckb[keyId] = cmdGroup[0];\n                }\n            }\n        }\n    };\n\n    this.bindKey = function(key, command, position) {\n        if (typeof key == \"object\" && key) {\n            if (position == undefined)\n                position = key.position;\n            key = key[this.platform];\n        }\n        if (!key)\n            return;\n        if (typeof command == \"function\")\n            return this.addCommand({exec: command, bindKey: key, name: command.name || key});\n        \n        key.split(\"|\").forEach(function(keyPart) {\n            var chain = \"\";\n            if (keyPart.indexOf(\" \") != -1) {\n                var parts = keyPart.split(/\\s+/);\n                keyPart = parts.pop();\n                parts.forEach(function(keyPart) {\n                    var binding = this.parseKeys(keyPart);\n                    var id = KEY_MODS[binding.hashId] + binding.key;\n                    chain += (chain ? \" \" : \"\") + id;\n                    this._addCommandToBinding(chain, \"chainKeys\");\n                }, this);\n                chain += \" \";\n            }\n            var binding = this.parseKeys(keyPart);\n            var id = KEY_MODS[binding.hashId] + binding.key;\n            this._addCommandToBinding(chain + id, command, position);\n        }, this);\n    };\n    \n    function getPosition(command) {\n        return typeof command == \"object\" && command.bindKey\n            && command.bindKey.position \n            || (command.isDefault ? -100 : 0);\n    }\n    this._addCommandToBinding = function(keyId, command, position) {\n        var ckb = this.commandKeyBinding, i;\n        if (!command) {\n            delete ckb[keyId];\n        } else if (!ckb[keyId] || this.$singleCommand) {\n            ckb[keyId] = command;\n        } else {\n            if (!Array.isArray(ckb[keyId])) {\n                ckb[keyId] = [ckb[keyId]];\n            } else if ((i = ckb[keyId].indexOf(command)) != -1) {\n                ckb[keyId].splice(i, 1);\n            }\n            \n            if (typeof position != \"number\") {\n                position = getPosition(command);\n            }\n\n            var commands = ckb[keyId];\n            for (i = 0; i < commands.length; i++) {\n                var other = commands[i];\n                var otherPos = getPosition(other);\n                if (otherPos > position)\n                    break;\n            }\n            commands.splice(i, 0, command);\n        }\n    };\n\n    this.addCommands = function(commands) {\n        commands && Object.keys(commands).forEach(function(name) {\n            var command = commands[name];\n            if (!command)\n                return;\n            \n            if (typeof command === \"string\")\n                return this.bindKey(command, name);\n\n            if (typeof command === \"function\")\n                command = { exec: command };\n\n            if (typeof command !== \"object\")\n                return;\n\n            if (!command.name)\n                command.name = name;\n\n            this.addCommand(command);\n        }, this);\n    };\n\n    this.removeCommands = function(commands) {\n        Object.keys(commands).forEach(function(name) {\n            this.removeCommand(commands[name]);\n        }, this);\n    };\n\n    this.bindKeys = function(keyList) {\n        Object.keys(keyList).forEach(function(key) {\n            this.bindKey(key, keyList[key]);\n        }, this);\n    };\n\n    this._buildKeyHash = function(command) {\n        this.bindKey(command.bindKey, command);\n    };\n    this.parseKeys = function(keys) {\n        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function(x){return x;});\n        var key = parts.pop();\n\n        var keyCode = keyUtil[key];\n        if (keyUtil.FUNCTION_KEYS[keyCode])\n            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n        else if (!parts.length)\n            return {key: key, hashId: -1};\n        else if (parts.length == 1 && parts[0] == \"shift\")\n            return {key: key.toUpperCase(), hashId: -1};\n\n        var hashId = 0;\n        for (var i = parts.length; i--;) {\n            var modifier = keyUtil.KEY_MODS[parts[i]];\n            if (modifier == null) {\n                if (typeof console != \"undefined\")\n                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n                return false;\n            }\n            hashId |= modifier;\n        }\n        return {key: key, hashId: hashId};\n    };\n\n    this.findKeyCommand = function findKeyCommand(hashId, keyString) {\n        var key = KEY_MODS[hashId] + keyString;\n        return this.commandKeyBinding[key];\n    };\n\n    this.handleKeyboard = function(data, hashId, keyString, keyCode) {\n        if (keyCode < 0) return;\n        var key = KEY_MODS[hashId] + keyString;\n        var command = this.commandKeyBinding[key];\n        if (data.$keyChain) {\n            data.$keyChain += \" \" + key;\n            command = this.commandKeyBinding[data.$keyChain] || command;\n        }\n        \n        if (command) {\n            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n                data.$keyChain = data.$keyChain || key;\n                return {command: \"null\"};\n            }\n        }\n        \n        if (data.$keyChain) {\n            if ((!hashId || hashId == 4) && keyString.length == 1)\n                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input\n            else if (hashId == -1 || keyCode > 0)\n                data.$keyChain = \"\"; // reset keyChain\n        }\n        return {command: command};\n    };\n    \n    this.getStatusText = function(editor, data) {\n        return data.$keyChain || \"\";\n    };\n\n}).call(HashHandler.prototype);\n\nexports.HashHandler = HashHandler;\nexports.MultiHashHandler = MultiHashHandler;\n});\n\nace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar MultiHashHandler = require(\"../keyboard/hash_handler\").MultiHashHandler;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CommandManager = function(platform, commands) {\n    MultiHashHandler.call(this, commands, platform);\n    this.byName = this.commands;\n    this.setDefaultHandler(\"exec\", function(e) {\n        return e.command.exec(e.editor, e.args || {});\n    });\n};\n\noop.inherits(CommandManager, MultiHashHandler);\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.exec = function(command, editor, args) {\n        if (Array.isArray(command)) {\n            for (var i = command.length; i--; ) {\n                if (this.exec(command[i], editor, args)) return true;\n            }\n            return false;\n        }\n\n        if (typeof command === \"string\")\n            command = this.commands[command];\n\n        if (!command)\n            return false;\n\n        if (editor && editor.$readOnly && !command.readOnly)\n            return false;\n\n        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))\n            return false;\n\n        var e = {editor: editor, command: command, args: args};\n        e.returnValue = this._emit(\"exec\", e);\n        this._signal(\"afterExec\", e);\n\n        return e.returnValue === false ? false : true;\n    };\n\n    this.toggleRecording = function(editor) {\n        if (this.$inReplay)\n            return;\n\n        editor && editor._emit(\"changeStatus\");\n        if (this.recording) {\n            this.macro.pop();\n            this.removeEventListener(\"exec\", this.$addCommandToMacro);\n\n            if (!this.macro.length)\n                this.macro = this.oldMacro;\n\n            return this.recording = false;\n        }\n        if (!this.$addCommandToMacro) {\n            this.$addCommandToMacro = function(e) {\n                this.macro.push([e.command, e.args]);\n            }.bind(this);\n        }\n\n        this.oldMacro = this.macro;\n        this.macro = [];\n        this.on(\"exec\", this.$addCommandToMacro);\n        return this.recording = true;\n    };\n\n    this.replay = function(editor) {\n        if (this.$inReplay || !this.macro)\n            return;\n\n        if (this.recording)\n            return this.toggleRecording(editor);\n\n        try {\n            this.$inReplay = true;\n            this.macro.forEach(function(x) {\n                if (typeof x == \"string\")\n                    this.exec(x, editor);\n                else\n                    this.exec(x[0], editor, x[1]);\n            }, this);\n        } finally {\n            this.$inReplay = false;\n        }\n    };\n\n    this.trimMacro = function(m) {\n        return m.map(function(x){\n            if (typeof x[0] != \"string\")\n                x[0] = x[0].name;\n            if (!x[1])\n                x = x[0];\n            return x;\n        });\n    };\n\n}).call(CommandManager.prototype);\n\nexports.CommandManager = CommandManager;\n\n});\n\nace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\nvar config = require(\"../config\");\nvar Range = require(\"../range\").Range;\n\nfunction bindKey(win, mac) {\n    return {win: win, mac: mac};\n}\nexports.commands = [{\n    name: \"showSettingsMenu\",\n    bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/settings_menu\", function(module) {\n            module.init(editor);\n            editor.showSettingsMenu();\n        });\n    },\n    readOnly: true\n}, {\n    name: \"goToNextError\",\n    bindKey: bindKey(\"Alt-E\", \"F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, 1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"goToPreviousError\",\n    bindKey: bindKey(\"Alt-Shift-E\", \"Shift-F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, -1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selectall\",\n    description: \"Select all\",\n    bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n    exec: function(editor) { editor.selectAll(); },\n    readOnly: true\n}, {\n    name: \"centerselection\",\n    description: \"Center selection\",\n    bindKey: bindKey(null, \"Ctrl-L\"),\n    exec: function(editor) { editor.centerSelection(); },\n    readOnly: true\n}, {\n    name: \"gotoline\",\n    description: \"Go to line...\",\n    bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n    exec: function(editor, line) {\n        if (typeof line === \"number\" && !isNaN(line))\n            editor.gotoLine(line);\n        editor.prompt({ $type: \"gotoLine\" });\n    },\n    readOnly: true\n}, {\n    name: \"fold\",\n    bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n    exec: function(editor) { editor.session.toggleFold(false); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfold\",\n    bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n    exec: function(editor) { editor.session.toggleFold(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleFoldWidget\",\n    bindKey: bindKey(\"F2\", \"F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleParentFoldWidget\",\n    bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldall\",\n    description: \"Fold all\",\n    bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n    exec: function(editor) { editor.session.foldAll(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldOther\",\n    description: \"Fold other\",\n    bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n    exec: function(editor) { \n        editor.session.foldAll();\n        editor.session.unfold(editor.selection.getAllRanges());\n    },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfoldall\",\n    description: \"Unfold all\",\n    bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n    exec: function(editor) { editor.session.unfold(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findnext\",\n    description: \"Find next\",\n    bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n    exec: function(editor) { editor.findNext(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findprevious\",\n    description: \"Find previous\",\n    bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n    exec: function(editor) { editor.findPrevious(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"selectOrFindNext\",\n    description: \"Select or find next\",\n    bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n    exec: function(editor) {\n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findNext(); \n    },\n    readOnly: true\n}, {\n    name: \"selectOrFindPrevious\",\n    description: \"Select or find previous\",\n    bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n    exec: function(editor) { \n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findPrevious();\n    },\n    readOnly: true\n}, {\n    name: \"find\",\n    description: \"Find\",\n    bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor);});\n    },\n    readOnly: true\n}, {\n    name: \"overwrite\",\n    description: \"Overwrite\",\n    bindKey: \"Insert\",\n    exec: function(editor) { editor.toggleOverwrite(); },\n    readOnly: true\n}, {\n    name: \"selecttostart\",\n    description: \"Select to start\",\n    bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Home|Command-Shift-Up\"),\n    exec: function(editor) { editor.getSelection().selectFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotostart\",\n    description: \"Go to start\",\n    bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n    exec: function(editor) { editor.navigateFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectup\",\n    description: \"Select up\",\n    bindKey: bindKey(\"Shift-Up\", \"Shift-Up|Ctrl-Shift-P\"),\n    exec: function(editor) { editor.getSelection().selectUp(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golineup\",\n    description: \"Go line up\",\n    bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n    exec: function(editor, args) { editor.navigateUp(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttoend\",\n    description: \"Select to end\",\n    bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-End|Command-Shift-Down\"),\n    exec: function(editor) { editor.getSelection().selectFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotoend\",\n    description: \"Go to end\",\n    bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n    exec: function(editor) { editor.navigateFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectdown\",\n    description: \"Select down\",\n    bindKey: bindKey(\"Shift-Down\", \"Shift-Down|Ctrl-Shift-N\"),\n    exec: function(editor) { editor.getSelection().selectDown(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golinedown\",\n    description: \"Go line down\",\n    bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n    exec: function(editor, args) { editor.navigateDown(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordleft\",\n    description: \"Select word left\",\n    bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n    exec: function(editor) { editor.getSelection().selectWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordleft\",\n    description: \"Go to word left\",\n    bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n    exec: function(editor) { editor.navigateWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolinestart\",\n    description: \"Select to line start\",\n    bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left|Ctrl-Shift-A\"),\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolinestart\",\n    description: \"Go to line start\",\n    bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n    exec: function(editor) { editor.navigateLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectleft\",\n    description: \"Select left\",\n    bindKey: bindKey(\"Shift-Left\", \"Shift-Left|Ctrl-Shift-B\"),\n    exec: function(editor) { editor.getSelection().selectLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoleft\",\n    description: \"Go to left\",\n    bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n    exec: function(editor, args) { editor.navigateLeft(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordright\",\n    description: \"Select word right\",\n    bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordright\",\n    description: \"Go to word right\",\n    bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n    exec: function(editor) { editor.navigateWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolineend\",\n    description: \"Select to line end\",\n    bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right|Shift-End|Ctrl-Shift-E\"),\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolineend\",\n    description: \"Go to line end\",\n    bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n    exec: function(editor) { editor.navigateLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectright\",\n    description: \"Select right\",\n    bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoright\",\n    description: \"Go to right\",\n    bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n    exec: function(editor, args) { editor.navigateRight(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectpagedown\",\n    description: \"Select page down\",\n    bindKey: \"Shift-PageDown\",\n    exec: function(editor) { editor.selectPageDown(); },\n    readOnly: true\n}, {\n    name: \"pagedown\",\n    description: \"Page down\",\n    bindKey: bindKey(null, \"Option-PageDown\"),\n    exec: function(editor) { editor.scrollPageDown(); },\n    readOnly: true\n}, {\n    name: \"gotopagedown\",\n    description: \"Go to page down\",\n    bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n    exec: function(editor) { editor.gotoPageDown(); },\n    readOnly: true\n}, {\n    name: \"selectpageup\",\n    description: \"Select page up\",\n    bindKey: \"Shift-PageUp\",\n    exec: function(editor) { editor.selectPageUp(); },\n    readOnly: true\n}, {\n    name: \"pageup\",\n    description: \"Page up\",\n    bindKey: bindKey(null, \"Option-PageUp\"),\n    exec: function(editor) { editor.scrollPageUp(); },\n    readOnly: true\n}, {\n    name: \"gotopageup\",\n    description: \"Go to page up\",\n    bindKey: \"PageUp\",\n    exec: function(editor) { editor.gotoPageUp(); },\n    readOnly: true\n}, {\n    name: \"scrollup\",\n    description: \"Scroll up\",\n    bindKey: bindKey(\"Ctrl-Up\", null),\n    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"scrolldown\",\n    description: \"Scroll down\",\n    bindKey: bindKey(\"Ctrl-Down\", null),\n    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"selectlinestart\",\n    description: \"Select line start\",\n    bindKey: \"Shift-Home\",\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectlineend\",\n    description: \"Select line end\",\n    bindKey: \"Shift-End\",\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"togglerecording\",\n    description: \"Toggle recording\",\n    bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n    exec: function(editor) { editor.commands.toggleRecording(editor); },\n    readOnly: true\n}, {\n    name: \"replaymacro\",\n    description: \"Replay macro\",\n    bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n    exec: function(editor) { editor.commands.replay(editor); },\n    readOnly: true\n}, {\n    name: \"jumptomatching\",\n    description: \"Jump to matching\",\n    bindKey: bindKey(\"Ctrl-P\", \"Ctrl-P\"),\n    exec: function(editor) { editor.jumpToMatching(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selecttomatching\",\n    description: \"Select to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-P\", \"Ctrl-Shift-P\"),\n    exec: function(editor) { editor.jumpToMatching(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"expandToMatching\",\n    description: \"Expand to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-M\", \"Ctrl-Shift-M\"),\n    exec: function(editor) { editor.jumpToMatching(true, true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"passKeysToBrowser\",\n    description: \"Pass keys to browser\",\n    bindKey: bindKey(null, null),\n    exec: function() {},\n    passEvent: true,\n    readOnly: true\n}, {\n    name: \"copy\",\n    description: \"Copy\",\n    exec: function(editor) {\n    },\n    readOnly: true\n},\n{\n    name: \"cut\",\n    description: \"Cut\",\n    exec: function(editor) {\n        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();\n        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();\n        editor._emit(\"cut\", range);\n\n        if (!range.isEmpty())\n            editor.session.remove(range);\n        editor.clearSelection();\n    },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"paste\",\n    description: \"Paste\",\n    exec: function(editor, args) {\n        editor.$handlePaste(args);\n    },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removeline\",\n    description: \"Remove line\",\n    bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n    exec: function(editor) { editor.removeLines(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"duplicateSelection\",\n    description: \"Duplicate selection\",\n    bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n    exec: function(editor) { editor.duplicateSelection(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"sortlines\",\n    description: \"Sort lines\",\n    bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n    exec: function(editor) { editor.sortLines(); },\n    scrollIntoView: \"selection\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"togglecomment\",\n    description: \"Toggle comment\",\n    bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n    exec: function(editor) { editor.toggleCommentLines(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"toggleBlockComment\",\n    description: \"Toggle block comment\",\n    bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n    exec: function(editor) { editor.toggleBlockComment(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"modifyNumberUp\",\n    description: \"Modify number up\",\n    bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n    exec: function(editor) { editor.modifyNumber(1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"modifyNumberDown\",\n    description: \"Modify number down\",\n    bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n    exec: function(editor) { editor.modifyNumber(-1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"replace\",\n    description: \"Replace\",\n    bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor, true);});\n    }\n}, {\n    name: \"undo\",\n    description: \"Undo\",\n    bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n    exec: function(editor) { editor.undo(); }\n}, {\n    name: \"redo\",\n    description: \"Redo\",\n    bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n    exec: function(editor) { editor.redo(); }\n}, {\n    name: \"copylinesup\",\n    description: \"Copy lines up\",\n    bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n    exec: function(editor) { editor.copyLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesup\",\n    description: \"Move lines up\",\n    bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n    exec: function(editor) { editor.moveLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"copylinesdown\",\n    description: \"Copy lines down\",\n    bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n    exec: function(editor) { editor.copyLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesdown\",\n    description: \"Move lines down\",\n    bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n    exec: function(editor) { editor.moveLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"del\",\n    description: \"Delete\",\n    bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n    exec: function(editor) { editor.remove(\"right\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"backspace\",\n    description: \"Backspace\",\n    bindKey: bindKey(\n        \"Shift-Backspace|Backspace\",\n        \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"\n    ),\n    exec: function(editor) { editor.remove(\"left\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"cut_or_delete\",\n    description: \"Cut or delete\",\n    bindKey: bindKey(\"Shift-Delete\", null),\n    exec: function(editor) { \n        if (editor.selection.isEmpty()) {\n            editor.remove(\"left\");\n        } else {\n            return false;\n        }\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestart\",\n    description: \"Remove to line start\",\n    bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n    exec: function(editor) { editor.removeToLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineend\",\n    description: \"Remove to line end\",\n    bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K|Command-Delete\"),\n    exec: function(editor) { editor.removeToLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestarthard\",\n    description: \"Remove to line start hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Backspace\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.start.column = 0;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineendhard\",\n    description: \"Remove to line end hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Delete\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.end.column = Number.MAX_VALUE;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordleft\",\n    description: \"Remove word left\",\n    bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n    exec: function(editor) { editor.removeWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordright\",\n    description: \"Remove word right\",\n    bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n    exec: function(editor) { editor.removeWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"outdent\",\n    description: \"Outdent\",\n    bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"indent\",\n    description: \"Indent\",\n    bindKey: bindKey(\"Tab\", \"Tab\"),\n    exec: function(editor) { editor.indent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockoutdent\",\n    description: \"Block outdent\",\n    bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockindent\",\n    description: \"Block indent\",\n    bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n    exec: function(editor) { editor.blockIndent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"insertstring\",\n    description: \"Insert string\",\n    exec: function(editor, str) { editor.insert(str); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"inserttext\",\n    description: \"Insert text\",\n    exec: function(editor, args) {\n        editor.insert(lang.stringRepeat(args.text  || \"\", args.times || 1));\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"splitline\",\n    description: \"Split line\",\n    bindKey: bindKey(null, \"Ctrl-O\"),\n    exec: function(editor) { editor.splitLine(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"transposeletters\",\n    description: \"Transpose letters\",\n    bindKey: bindKey(\"Alt-Shift-X\", \"Ctrl-T\"),\n    exec: function(editor) { editor.transposeLetters(); },\n    multiSelectAction: function(editor) {editor.transposeSelections(1); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"touppercase\",\n    description: \"To uppercase\",\n    bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n    exec: function(editor) { editor.toUpperCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"tolowercase\",\n    description: \"To lowercase\",\n    bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n    exec: function(editor) { editor.toLowerCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"expandtoline\",\n    description: \"Expand to line\",\n    bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n\n        range.start.column = range.end.column = 0;\n        range.end.row++;\n        editor.selection.setRange(range, false);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"joinlines\",\n    description: \"Join lines\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var isBackwards = editor.selection.isBackwards();\n        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;\n        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n        var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n        var insertLine = editor.session.doc.getLine(selectionStart.row);\n\n        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n            if (curLine.length !== 0) {\n                curLine = \" \" + curLine;\n            }\n            insertLine += curLine;\n        }\n\n        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n            insertLine += editor.session.doc.getNewLineCharacter();\n        }\n\n        editor.clearSelection();\n        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n\n        if (selectedCount > 0) {\n            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n        } else {\n            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n        }\n    },\n    multiSelectAction: \"forEach\",\n    readOnly: true\n}, {\n    name: \"invertSelection\",\n    description: \"Invert selection\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var endRow = editor.session.doc.getLength() - 1;\n        var endCol = editor.session.doc.getLine(endRow).length;\n        var ranges = editor.selection.rangeList.ranges;\n        var newRanges = [];\n        if (ranges.length < 1) {\n            ranges = [editor.selection.getRange()];\n        }\n\n        for (var i = 0; i < ranges.length; i++) {\n            if (i == (ranges.length - 1)) {\n                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n                }\n            }\n\n            if (i === 0) {\n                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n                }\n            } else {\n                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));\n            }\n        }\n\n        editor.exitMultiSelectMode();\n        editor.clearSelection();\n\n        for(var i = 0; i < newRanges.length; i++) {\n            editor.selection.addRange(newRanges[i], false);\n        }\n    },\n    readOnly: true,\n    scrollIntoView: \"none\"\n}, {\n    name: \"openCommandPallete\",\n    description: \"Open command pallete\",\n    bindKey: bindKey(\"F1\", \"F1\"),\n    exec: function(editor) {\n        editor.prompt({ $type: \"commands\" });\n    },\n    readOnly: true\n}, {\n    name: \"modeSelect\",\n    description: \"Change language mode...\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        editor.prompt({ $type: \"modes\" });\n    },\n    readOnly: true\n}];\n\n});\n\nace.define(\"ace/clipboard\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nmodule.exports = { lineMode: false };\n\n});\n\nace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\",\"ace/clipboard\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar useragent = require(\"./lib/useragent\");\nvar TextInput = require(\"./keyboard/textinput\").TextInput;\nvar MouseHandler = require(\"./mouse/mouse_handler\").MouseHandler;\nvar FoldHandler = require(\"./mouse/fold_handler\").FoldHandler;\nvar KeyBinding = require(\"./keyboard/keybinding\").KeyBinding;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Search = require(\"./search\").Search;\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar CommandManager = require(\"./commands/command_manager\").CommandManager;\nvar defaultCommands = require(\"./commands/default_commands\").commands;\nvar config = require(\"./config\");\nvar TokenIterator = require(\"./token_iterator\").TokenIterator;\n\nvar clipboard = require(\"./clipboard\");\nvar Editor = function(renderer, session, options) {\n    var container = renderer.getContainerElement();\n    this.container = container;\n    this.renderer = renderer;\n    this.id = \"editor\" + (++Editor.$uid);\n\n    this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n    if (typeof document == \"object\") {\n        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);\n        this.renderer.textarea = this.textInput.getElement();\n        this.$mouseHandler = new MouseHandler(this);\n        new FoldHandler(this);\n    }\n\n    this.keyBinding = new KeyBinding(this);\n\n    this.$search = new Search().set({\n        wrap: true\n    });\n\n    this.$historyTracker = this.$historyTracker.bind(this);\n    this.commands.on(\"exec\", this.$historyTracker);\n\n    this.$initOperationListeners();\n    \n    this._$emitInputEvent = lang.delayedCall(function() {\n        this._signal(\"input\", {});\n        if (this.session && this.session.bgTokenizer)\n            this.session.bgTokenizer.scheduleStart();\n    }.bind(this));\n    \n    this.on(\"change\", function(_, _self) {\n        _self._$emitInputEvent.schedule(31);\n    });\n\n    this.setSession(session || options && options.session || new EditSession(\"\"));\n    config.resetOptions(this);\n    if (options)\n        this.setOptions(options);\n    config._signal(\"editor\", this);\n};\n\nEditor.$uid = 0;\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$initOperationListeners = function() {\n        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n\n        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));\n        this.on(\"change\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.docChanged = true;\n        }.bind(this), true);\n        \n        this.on(\"changeSelection\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.selectionChanged = true;\n        }.bind(this), true);\n    };\n\n    this.curOp = null;\n    this.prevOp = {};\n    this.startOperation = function(commandEvent) {\n        if (this.curOp) {\n            if (!commandEvent || this.curOp.command)\n                return;\n            this.prevOp = this.curOp;\n        }\n        if (!commandEvent) {\n            this.previousCommand = null;\n            commandEvent = {};\n        }\n\n        this.$opResetTimer.schedule();\n        this.curOp = this.session.curOp = {\n            command: commandEvent.command || {},\n            args: commandEvent.args,\n            scrollTop: this.renderer.scrollTop\n        };\n        this.curOp.selectionBefore = this.selection.toJSON();\n    };\n\n    this.endOperation = function(e) {\n        if (this.curOp) {\n            if (e && e.returnValue === false)\n                return (this.curOp = null);\n            if (e == true && this.curOp.command && this.curOp.command.name == \"mouse\")\n                return;\n            this._signal(\"beforeEndOperation\");\n            if (!this.curOp) return;\n            var command = this.curOp.command;\n            var scrollIntoView = command && command.scrollIntoView;\n            if (scrollIntoView) {\n                switch (scrollIntoView) {\n                    case \"center-animate\":\n                        scrollIntoView = \"animate\";\n                    case \"center\":\n                        this.renderer.scrollCursorIntoView(null, 0.5);\n                        break;\n                    case \"animate\":\n                    case \"cursor\":\n                        this.renderer.scrollCursorIntoView();\n                        break;\n                    case \"selectionPart\":\n                        var range = this.selection.getRange();\n                        var config = this.renderer.layerConfig;\n                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                if (scrollIntoView == \"animate\")\n                    this.renderer.animateScrolling(this.curOp.scrollTop);\n            }\n            var sel = this.selection.toJSON();\n            this.curOp.selectionAfter = sel;\n            this.$lastSel = this.selection.toJSON();\n            this.session.getUndoManager().addSelection(sel);\n            this.prevOp = this.curOp;\n            this.curOp = null;\n        }\n    };\n    this.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\n    this.$historyTracker = function(e) {\n        if (!this.$mergeUndoDeltas)\n            return;\n\n        var prev = this.prevOp;\n        var mergeableCommands = this.$mergeableCommands;\n        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n        if (e.command.name == \"insertstring\") {\n            var text = e.args;\n            if (this.mergeNextCommand === undefined)\n                this.mergeNextCommand = true;\n\n            shouldMerge = shouldMerge\n                && this.mergeNextCommand // previous command allows to coalesce with\n                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n\n            this.mergeNextCommand = true;\n        } else {\n            shouldMerge = shouldMerge\n                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n        }\n\n        if (\n            this.$mergeUndoDeltas != \"always\"\n            && Date.now() - this.sequenceStartTime > 2000\n        ) {\n            shouldMerge = false; // the sequence is too long\n        }\n\n        if (shouldMerge)\n            this.session.mergeUndoDeltas = true;\n        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n            this.sequenceStartTime = Date.now();\n    };\n    this.setKeyboardHandler = function(keyboardHandler, cb) {\n        if (keyboardHandler && typeof keyboardHandler === \"string\" && keyboardHandler != \"ace\") {\n            this.$keybindingId = keyboardHandler;\n            var _self = this;\n            config.loadModule([\"keybinding\", keyboardHandler], function(module) {\n                if (_self.$keybindingId == keyboardHandler)\n                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n                cb && cb();\n            });\n        } else {\n            this.$keybindingId = null;\n            this.keyBinding.setKeyboardHandler(keyboardHandler);\n            cb && cb();\n        }\n    };\n    this.getKeyboardHandler = function() {\n        return this.keyBinding.getKeyboardHandler();\n    };\n    this.setSession = function(session) {\n        if (this.session == session)\n            return;\n        if (this.curOp) this.endOperation();\n        this.curOp = {};\n\n        var oldSession = this.session;\n        if (oldSession) {\n            this.session.off(\"change\", this.$onDocumentChange);\n            this.session.off(\"changeMode\", this.$onChangeMode);\n            this.session.off(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.session.off(\"changeTabSize\", this.$onChangeTabSize);\n            this.session.off(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.session.off(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.session.off(\"changeFold\", this.$onChangeFold);\n            this.session.off(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.session.off(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.session.off(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.session.off(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.session.off(\"changeOverwrite\", this.$onCursorChange);\n            this.session.off(\"changeScrollTop\", this.$onScrollTopChange);\n            this.session.off(\"changeScrollLeft\", this.$onScrollLeftChange);\n\n            var selection = this.session.getSelection();\n            selection.off(\"changeCursor\", this.$onCursorChange);\n            selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n\n        this.session = session;\n        if (session) {\n            this.$onDocumentChange = this.onDocumentChange.bind(this);\n            session.on(\"change\", this.$onDocumentChange);\n            this.renderer.setSession(session);\n    \n            this.$onChangeMode = this.onChangeMode.bind(this);\n            session.on(\"changeMode\", this.$onChangeMode);\n    \n            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n            session.on(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n    \n            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n            session.on(\"changeTabSize\", this.$onChangeTabSize);\n    \n            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n            session.on(\"changeWrapLimit\", this.$onChangeWrapLimit);\n    \n            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n            session.on(\"changeWrapMode\", this.$onChangeWrapMode);\n    \n            this.$onChangeFold = this.onChangeFold.bind(this);\n            session.on(\"changeFold\", this.$onChangeFold);\n    \n            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n            this.session.on(\"changeFrontMarker\", this.$onChangeFrontMarker);\n    \n            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n            this.session.on(\"changeBackMarker\", this.$onChangeBackMarker);\n    \n            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n            this.session.on(\"changeBreakpoint\", this.$onChangeBreakpoint);\n    \n            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n            this.session.on(\"changeAnnotation\", this.$onChangeAnnotation);\n    \n            this.$onCursorChange = this.onCursorChange.bind(this);\n            this.session.on(\"changeOverwrite\", this.$onCursorChange);\n    \n            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n            this.session.on(\"changeScrollTop\", this.$onScrollTopChange);\n    \n            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n            this.session.on(\"changeScrollLeft\", this.$onScrollLeftChange);\n    \n            this.selection = session.getSelection();\n            this.selection.on(\"changeCursor\", this.$onCursorChange);\n    \n            this.$onSelectionChange = this.onSelectionChange.bind(this);\n            this.selection.on(\"changeSelection\", this.$onSelectionChange);\n    \n            this.onChangeMode();\n    \n            this.onCursorChange();\n    \n            this.onScrollTopChange();\n            this.onScrollLeftChange();\n            this.onSelectionChange();\n            this.onChangeFrontMarker();\n            this.onChangeBackMarker();\n            this.onChangeBreakpoint();\n            this.onChangeAnnotation();\n            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n            this.renderer.updateFull();\n        } else {\n            this.selection = null;\n            this.renderer.setSession(session);\n        }\n\n        this._signal(\"changeSession\", {\n            session: session,\n            oldSession: oldSession\n        });\n        \n        this.curOp = null;\n        \n        oldSession && oldSession._signal(\"changeEditor\", {oldEditor: this});\n        session && session._signal(\"changeEditor\", {editor: this});\n        \n        if (session && session.bgTokenizer)\n            session.bgTokenizer.scheduleStart();\n    };\n    this.getSession = function() {\n        return this.session;\n    };\n    this.setValue = function(val, cursorPos) {\n        this.session.doc.setValue(val);\n\n        if (!cursorPos)\n            this.selectAll();\n        else if (cursorPos == 1)\n            this.navigateFileEnd();\n        else if (cursorPos == -1)\n            this.navigateFileStart();\n\n        return val;\n    };\n    this.getValue = function() {\n        return this.session.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.resize = function(force) {\n        this.renderer.onResize(force);\n    };\n    this.setTheme = function(theme, cb) {\n        this.renderer.setTheme(theme, cb);\n    };\n    this.getTheme = function() {\n        return this.renderer.getTheme();\n    };\n    this.setStyle = function(style) {\n        this.renderer.setStyle(style);\n    };\n    this.unsetStyle = function(style) {\n        this.renderer.unsetStyle(style);\n    };\n    this.getFontSize = function () {\n        return this.getOption(\"fontSize\") ||\n           dom.computedStyle(this.container).fontSize;\n    };\n    this.setFontSize = function(size) {\n        this.setOption(\"fontSize\", size);\n    };\n\n    this.$highlightBrackets = function() {\n        if (this.session.$bracketHighlight) {\n            this.session.removeMarker(this.session.$bracketHighlight);\n            this.session.$bracketHighlight = null;\n        }\n\n        if (this.$highlightPending) {\n            return;\n        }\n        var self = this;\n        this.$highlightPending = true;\n        setTimeout(function() {\n            self.$highlightPending = false;\n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            var pos = session.findMatchingBracket(self.getCursorPosition());\n            if (pos) {\n                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);\n            } else if (session.$mode.getMatching) {\n                var range = session.$mode.getMatching(self.session);\n            }\n            if (range)\n                session.$bracketHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n        }, 50);\n    };\n    this.$highlightTags = function() {\n        if (this.$highlightTagPending)\n            return;\n        var self = this;\n        this.$highlightTagPending = true;\n        setTimeout(function() {\n            self.$highlightTagPending = false;\n            \n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            \n            var pos = self.getCursorPosition();\n            var iterator = new TokenIterator(self.session, pos.row, pos.column);\n            var token = iterator.getCurrentToken();\n            \n            if (!token || !/\\b(?:tag-open|tag-name)/.test(token.type)) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            if (token.type.indexOf(\"tag-open\") != -1) {\n                token = iterator.stepForward();\n                if (!token)\n                    return;\n            }\n            \n            var tag = token.value;\n            var depth = 0;\n            var prevToken = iterator.stepBackward();\n            \n            if (prevToken.value == '<'){\n                do {\n                    prevToken = token;\n                    token = iterator.stepForward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<'){\n                            depth++;\n                        } else if (prevToken.value === '</'){\n                            depth--;\n                        }\n                    }\n                    \n                } while (token && depth >= 0);\n            } else {\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                        } else if (prevToken.value === '</') {\n                            depth--;\n                        }\n                    }\n                } while (prevToken && depth <= 0);\n                iterator.stepForward();\n            }\n            \n            if (!token) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            var row = iterator.getCurrentTokenRow();\n            var column = iterator.getCurrentTokenColumn();\n            var range = new Range(row, column, row, column+token.value.length);\n            var sbm = session.$backMarkers[session.$tagHighlight];\n            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n            }\n            \n            if (!session.$tagHighlight)\n                session.$tagHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n        }, 50);\n    };\n    this.focus = function() {\n        var _self = this;\n        setTimeout(function() {\n            if (!_self.isFocused())\n                _self.textInput.focus();\n        });\n        this.textInput.focus();\n    };\n    this.isFocused = function() {\n        return this.textInput.isFocused();\n    };\n    this.blur = function() {\n        this.textInput.blur();\n    };\n    this.onFocus = function(e) {\n        if (this.$isFocused)\n            return;\n        this.$isFocused = true;\n        this.renderer.showCursor();\n        this.renderer.visualizeFocus();\n        this._emit(\"focus\", e);\n    };\n    this.onBlur = function(e) {\n        if (!this.$isFocused)\n            return;\n        this.$isFocused = false;\n        this.renderer.hideCursor();\n        this.renderer.visualizeBlur();\n        this._emit(\"blur\", e);\n    };\n\n    this.$cursorChange = function() {\n        this.renderer.updateCursor();\n    };\n    this.onDocumentChange = function(delta) {\n        var wrap = this.session.$useWrapMode;\n        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);\n        this.renderer.updateLines(delta.start.row, lastRow, wrap);\n\n        this._signal(\"change\", delta);\n        this.$cursorChange();\n        this.$updateHighlightActiveLine();\n    };\n\n    this.onTokenizerUpdate = function(e) {\n        var rows = e.data;\n        this.renderer.updateLines(rows.first, rows.last);\n    };\n\n\n    this.onScrollTopChange = function() {\n        this.renderer.scrollToY(this.session.getScrollTop());\n    };\n\n    this.onScrollLeftChange = function() {\n        this.renderer.scrollToX(this.session.getScrollLeft());\n    };\n    this.onCursorChange = function() {\n        this.$cursorChange();\n\n        this.$highlightBrackets();\n        this.$highlightTags();\n        this.$updateHighlightActiveLine();\n        this._signal(\"changeSelection\");\n    };\n\n    this.$updateHighlightActiveLine = function() {\n        var session = this.getSession();\n\n        var highlight;\n        if (this.$highlightActiveLine) {\n            if (this.$selectionStyle != \"line\" || !this.selection.isMultiLine())\n                highlight = this.getCursorPosition();\n            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())\n                highlight = false;\n            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n                highlight = false;\n        }\n\n        if (session.$highlightLineMarker && !highlight) {\n            session.removeMarker(session.$highlightLineMarker.id);\n            session.$highlightLineMarker = null;\n        } else if (!session.$highlightLineMarker && highlight) {\n            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n            session.$highlightLineMarker = range;\n        } else if (highlight) {\n            session.$highlightLineMarker.start.row = highlight.row;\n            session.$highlightLineMarker.end.row = highlight.row;\n            session.$highlightLineMarker.start.column = highlight.column;\n            session._signal(\"changeBackMarker\");\n        }\n    };\n\n    this.onSelectionChange = function(e) {\n        var session = this.session;\n\n        if (session.$selectionMarker) {\n            session.removeMarker(session.$selectionMarker);\n        }\n        session.$selectionMarker = null;\n\n        if (!this.selection.isEmpty()) {\n            var range = this.selection.getRange();\n            var style = this.getSelectionStyle();\n            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n        } else {\n            this.$updateHighlightActiveLine();\n        }\n\n        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n        this.session.highlight(re);\n\n        this._signal(\"changeSelection\");\n    };\n\n    this.$getSelectionHighLightRegexp = function() {\n        var session = this.session;\n\n        var selection = this.getSelectionRange();\n        if (selection.isEmpty() || selection.isMultiLine())\n            return;\n\n        var startColumn = selection.start.column;\n        var endColumn = selection.end.column;\n        var line = session.getLine(selection.start.row);\n        \n        var needle = line.substring(startColumn, endColumn);\n        if (needle.length > 5000 || !/[\\w\\d]/.test(needle))\n            return;\n\n        var re = this.$search.$assembleRegExp({\n            wholeWord: true,\n            caseSensitive: true,\n            needle: needle\n        });\n        \n        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);\n        if (!re.test(wordWithBoundary))\n            return;\n        \n        return re;\n    };\n\n\n    this.onChangeFrontMarker = function() {\n        this.renderer.updateFrontMarkers();\n    };\n\n    this.onChangeBackMarker = function() {\n        this.renderer.updateBackMarkers();\n    };\n\n\n    this.onChangeBreakpoint = function() {\n        this.renderer.updateBreakpoints();\n    };\n\n    this.onChangeAnnotation = function() {\n        this.renderer.setAnnotations(this.session.getAnnotations());\n    };\n\n\n    this.onChangeMode = function(e) {\n        this.renderer.updateText();\n        this._emit(\"changeMode\", e);\n    };\n\n\n    this.onChangeWrapLimit = function() {\n        this.renderer.updateFull();\n    };\n\n    this.onChangeWrapMode = function() {\n        this.renderer.onResize(true);\n    };\n\n\n    this.onChangeFold = function() {\n        this.$updateHighlightActiveLine();\n        this.renderer.updateFull();\n    };\n    this.getSelectedText = function() {\n        return this.session.getTextRange(this.getSelectionRange());\n    };\n    this.getCopyText = function() {\n        var text = this.getSelectedText();\n        var nl = this.session.doc.getNewLineCharacter();\n        var copyLine= false;\n        if (!text && this.$copyWithEmptySelection) {\n            copyLine = true;\n            var ranges = this.selection.getAllRanges();\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (i && ranges[i - 1].start.row == range.start.row)\n                    continue;\n                text += this.session.getLine(range.start.row) + nl;\n            }\n        }\n        var e = {text: text};\n        this._signal(\"copy\", e);\n        clipboard.lineMode = copyLine ? e.text : \"\";\n        return e.text;\n    };\n    this.onCopy = function() {\n        this.commands.exec(\"copy\", this);\n    };\n    this.onCut = function() {\n        this.commands.exec(\"cut\", this);\n    };\n    this.onPaste = function(text, event) {\n        var e = {text: text, event: event};\n        this.commands.exec(\"paste\", this, e);\n    };\n    \n    this.$handlePaste = function(e) {\n        if (typeof e == \"string\") \n            e = {text: e};\n        this._signal(\"paste\", e);\n        var text = e.text;\n\n        var lineMode = text == clipboard.lineMode;\n        var session = this.session;\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {\n            if (lineMode)\n                session.insert({ row: this.selection.lead.row, column: 0 }, text);\n            else\n                this.insert(text);\n        } else if (lineMode) {\n            this.selection.rangeList.ranges.forEach(function(range) {\n                session.insert({ row: range.start.row, column: 0 }, text);\n            });\n        } else {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var ranges = this.selection.rangeList.ranges;\n    \n            if (lines.length > ranges.length || lines.length < 2 || !lines[1])\n                return this.commands.exec(\"insertstring\", this, text);\n    \n            for (var i = ranges.length; i--;) {\n                var range = ranges[i];\n                if (!range.isEmpty())\n                    session.remove(range);\n    \n                session.insert(range.start, lines[i]);\n            }\n        }\n    };\n\n    this.execCommand = function(command, args) {\n        return this.commands.exec(command, this, args);\n    };\n    this.insert = function(text, pasted) {\n        var session = this.session;\n        var mode = session.getMode();\n        var cursor = this.getCursorPosition();\n\n        if (this.getBehavioursEnabled() && !pasted) {\n            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n            if (transform) {\n                if (text !== transform.text) {\n                    if (!this.inVirtualSelectionMode) {\n                        this.session.mergeUndoDeltas = false;\n                        this.mergeNextCommand = false;\n                    }\n                }\n                text = transform.text;\n\n            }\n        }\n        \n        if (text == \"\\t\")\n            text = this.session.getTabString();\n        if (!this.selection.isEmpty()) {\n            var range = this.getSelectionRange();\n            cursor = this.session.remove(range);\n            this.clearSelection();\n        }\n        else if (this.session.getOverwrite() && text.indexOf(\"\\n\") == -1) {\n            var range = new Range.fromPoints(cursor, cursor);\n            range.end.column += text.length;\n            this.session.remove(range);\n        }\n\n        if (text == \"\\n\" || text == \"\\r\\n\") {\n            var line = session.getLine(cursor.row);\n            if (cursor.column > line.search(/\\S|$/)) {\n                var d = line.substr(cursor.column).search(/\\S|$/);\n                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n            }\n        }\n        this.clearSelection();\n\n        var start = cursor.column;\n        var lineState = session.getState(cursor.row);\n        var line = session.getLine(cursor.row);\n        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n        var end = session.insert(cursor, text);\n\n        if (transform && transform.selection) {\n            if (transform.selection.length == 2) { // Transform relative to the current column\n                this.selection.setSelectionRange(\n                    new Range(cursor.row, start + transform.selection[0],\n                              cursor.row, start + transform.selection[1]));\n            } else { // Transform relative to the current row.\n                this.selection.setSelectionRange(\n                    new Range(cursor.row + transform.selection[0],\n                              transform.selection[1],\n                              cursor.row + transform.selection[2],\n                              transform.selection[3]));\n            }\n        }\n\n        if (session.getDocument().isNewLine(text)) {\n            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n\n            session.insert({row: cursor.row+1, column: 0}, lineIndent);\n        }\n        if (shouldOutdent)\n            mode.autoOutdent(lineState, session, cursor.row);\n    };\n\n    this.onTextInput = function(text, composition) {\n        if (!composition)\n            return this.keyBinding.onTextInput(text);\n        \n        this.startOperation({command: { name: \"insertstring\" }});\n        var applyComposition = this.applyComposition.bind(this, text, composition);\n        if (this.selection.rangeCount)\n            this.forEachSelection(applyComposition);\n        else\n            applyComposition();\n        this.endOperation();\n    };\n    \n    this.applyComposition = function(text, composition) {\n        if (composition.extendLeft || composition.extendRight) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.extendLeft;\n            r.end.column += composition.extendRight;\n            this.selection.setRange(r);\n            if (!text && !r.isEmpty())\n                this.remove();\n        }\n        if (text || !this.selection.isEmpty())\n            this.insert(text, true);\n        if (composition.restoreStart || composition.restoreEnd) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.restoreStart;\n            r.end.column -= composition.restoreEnd;\n            this.selection.setRange(r);\n        }\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        this.keyBinding.onCommandKey(e, hashId, keyCode);\n    };\n    this.setOverwrite = function(overwrite) {\n        this.session.setOverwrite(overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.session.getOverwrite();\n    };\n    this.toggleOverwrite = function() {\n        this.session.toggleOverwrite();\n    };\n    this.setScrollSpeed = function(speed) {\n        this.setOption(\"scrollSpeed\", speed);\n    };\n    this.getScrollSpeed = function() {\n        return this.getOption(\"scrollSpeed\");\n    };\n    this.setDragDelay = function(dragDelay) {\n        this.setOption(\"dragDelay\", dragDelay);\n    };\n    this.getDragDelay = function() {\n        return this.getOption(\"dragDelay\");\n    };\n    this.setSelectionStyle = function(val) {\n        this.setOption(\"selectionStyle\", val);\n    };\n    this.getSelectionStyle = function() {\n        return this.getOption(\"selectionStyle\");\n    };\n    this.setHighlightActiveLine = function(shouldHighlight) {\n        this.setOption(\"highlightActiveLine\", shouldHighlight);\n    };\n    this.getHighlightActiveLine = function() {\n        return this.getOption(\"highlightActiveLine\");\n    };\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    this.setHighlightSelectedWord = function(shouldHighlight) {\n        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n    };\n    this.getHighlightSelectedWord = function() {\n        return this.$highlightSelectedWord;\n    };\n\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.renderer.setAnimatedScroll(shouldAnimate);\n    };\n\n    this.getAnimatedScroll = function(){\n        return this.renderer.getAnimatedScroll();\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.renderer.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.renderer.getShowInvisibles();\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.renderer.setDisplayIndentGuides(display);\n    };\n\n    this.getDisplayIndentGuides = function() {\n        return this.renderer.getDisplayIndentGuides();\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.renderer.setShowPrintMargin(showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.renderer.getShowPrintMargin();\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.renderer.setPrintMarginColumn(showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.renderer.getPrintMarginColumn();\n    };\n    this.setReadOnly = function(readOnly) {\n        this.setOption(\"readOnly\", readOnly);\n    };\n    this.getReadOnly = function() {\n        return this.getOption(\"readOnly\");\n    };\n    this.setBehavioursEnabled = function (enabled) {\n        this.setOption(\"behavioursEnabled\", enabled);\n    };\n    this.getBehavioursEnabled = function () {\n        return this.getOption(\"behavioursEnabled\");\n    };\n    this.setWrapBehavioursEnabled = function (enabled) {\n        this.setOption(\"wrapBehavioursEnabled\", enabled);\n    };\n    this.getWrapBehavioursEnabled = function () {\n        return this.getOption(\"wrapBehavioursEnabled\");\n    };\n    this.setShowFoldWidgets = function(show) {\n        this.setOption(\"showFoldWidgets\", show);\n\n    };\n    this.getShowFoldWidgets = function() {\n        return this.getOption(\"showFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(fade) {\n        this.setOption(\"fadeFoldWidgets\", fade);\n    };\n\n    this.getFadeFoldWidgets = function() {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    this.remove = function(dir) {\n        if (this.selection.isEmpty()){\n            if (dir == \"left\")\n                this.selection.selectLeft();\n            else\n                this.selection.selectRight();\n        }\n\n        var range = this.getSelectionRange();\n        if (this.getBehavioursEnabled()) {\n            var session = this.session;\n            var state = session.getState(range.start.row);\n            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n\n            if (range.end.column === 0) {\n                var text = session.getTextRange(range);\n                if (text[text.length - 1] == \"\\n\") {\n                    var line = session.getLine(range.end.row);\n                    if (/^\\s+$/.test(line)) {\n                        range.end.column = line.length;\n                    }\n                }\n            }\n            if (new_range)\n                range = new_range;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.removeWordRight = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordRight();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeWordLeft = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordLeft();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineStart = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineStart();\n        if (this.selection.isEmpty())\n            this.selection.selectLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineEnd = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineEnd();\n\n        var range = this.getSelectionRange();\n        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n            range.end.column = 0;\n            range.end.row++;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.splitLine = function() {\n        if (!this.selection.isEmpty()) {\n            this.session.remove(this.getSelectionRange());\n            this.clearSelection();\n        }\n\n        var cursor = this.getCursorPosition();\n        this.insert(\"\\n\");\n        this.moveCursorToPosition(cursor);\n    };\n    this.transposeLetters = function() {\n        if (!this.selection.isEmpty()) {\n            return;\n        }\n\n        var cursor = this.getCursorPosition();\n        var column = cursor.column;\n        if (column === 0)\n            return;\n\n        var line = this.session.getLine(cursor.row);\n        var swap, range;\n        if (column < line.length) {\n            swap = line.charAt(column) + line.charAt(column-1);\n            range = new Range(cursor.row, column-1, cursor.row, column+1);\n        }\n        else {\n            swap = line.charAt(column-1) + line.charAt(column-2);\n            range = new Range(cursor.row, column-2, cursor.row, column);\n        }\n        this.session.replace(range, swap);\n        this.session.selection.moveToPosition(range.end);\n    };\n    this.toLowerCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toLowerCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.toUpperCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toUpperCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.indent = function() {\n        var session = this.session;\n        var range = this.getSelectionRange();\n\n        if (range.start.row < range.end.row) {\n            var rows = this.$getSelectedRows();\n            session.indentRows(rows.first, rows.last, \"\\t\");\n            return;\n        } else if (range.start.column < range.end.column) {\n            var text = session.getTextRange(range);\n            if (!/^\\s+$/.test(text)) {\n                var rows = this.$getSelectedRows();\n                session.indentRows(rows.first, rows.last, \"\\t\");\n                return;\n            }\n        }\n        \n        var line = session.getLine(range.start.row);\n        var position = range.start;\n        var size = session.getTabSize();\n        var column = session.documentToScreenColumn(position.row, position.column);\n\n        if (this.session.getUseSoftTabs()) {\n            var count = (size - column % size);\n            var indentString = lang.stringRepeat(\" \", count);\n        } else {\n            var count = column % size;\n            while (line[range.start.column - 1] == \" \" && count) {\n                range.start.column--;\n                count--;\n            }\n            this.selection.setSelectionRange(range);\n            indentString = \"\\t\";\n        }\n        return this.insert(indentString);\n    };\n    this.blockIndent = function() {\n        var rows = this.$getSelectedRows();\n        this.session.indentRows(rows.first, rows.last, \"\\t\");\n    };\n    this.blockOutdent = function() {\n        var selection = this.session.getSelection();\n        this.session.outdentRows(selection.getRange());\n    };\n    this.sortLines = function() {\n        var rows = this.$getSelectedRows();\n        var session = this.session;\n\n        var lines = [];\n        for (var i = rows.first; i <= rows.last; i++)\n            lines.push(session.getLine(i));\n\n        lines.sort(function(a, b) {\n            if (a.toLowerCase() < b.toLowerCase()) return -1;\n            if (a.toLowerCase() > b.toLowerCase()) return 1;\n            return 0;\n        });\n\n        var deleteRange = new Range(0, 0, 0, 0);\n        for (var i = rows.first; i <= rows.last; i++) {\n            var line = session.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            deleteRange.end.column = line.length;\n            session.replace(deleteRange, lines[i-rows.first]);\n        }\n    };\n    this.toggleCommentLines = function() {\n        var state = this.session.getState(this.getCursorPosition().row);\n        var rows = this.$getSelectedRows();\n        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n    };\n\n    this.toggleBlockComment = function() {\n        var cursor = this.getCursorPosition();\n        var state = this.session.getState(cursor.row);\n        var range = this.getSelectionRange();\n        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n    };\n    this.getNumberAt = function(row, column) {\n        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n        _numberRx.lastIndex = 0;\n\n        var s = this.session.getLine(row);\n        while (_numberRx.lastIndex < column) {\n            var m = _numberRx.exec(s);\n            if(m.index <= column && m.index+m[0].length >= column){\n                var number = {\n                    value: m[0],\n                    start: m.index,\n                    end: m.index+m[0].length\n                };\n                return number;\n            }\n        }\n        return null;\n    };\n    this.modifyNumber = function(amount) {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        var charRange = new Range(row, column-1, row, column);\n\n        var c = this.session.getTextRange(charRange);\n        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n            var nr = this.getNumberAt(row, column);\n            if (nr) {\n                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n                var decimals = nr.start + nr.value.length - fp;\n\n                var t = parseFloat(nr.value);\n                t *= Math.pow(10, decimals);\n\n\n                if(fp !== nr.end && column < fp){\n                    amount *= Math.pow(10, nr.end - column - 1);\n                } else {\n                    amount *= Math.pow(10, nr.end - column);\n                }\n\n                t += amount;\n                t /= Math.pow(10, decimals);\n                var nnr = t.toFixed(decimals);\n                var replaceRange = new Range(row, nr.start, row, nr.end);\n                this.session.replace(replaceRange, nnr);\n                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));\n\n            }\n        } else {\n            this.toggleWord();\n        }\n    };\n\n    this.$toggleWordPairs = [\n        [\"first\", \"last\"],\n        [\"true\", \"false\"],\n        [\"yes\", \"no\"],\n        [\"width\", \"height\"],\n        [\"top\", \"bottom\"],\n        [\"right\", \"left\"],\n        [\"on\", \"off\"],\n        [\"x\", \"y\"],\n        [\"get\", \"set\"],\n        [\"max\", \"min\"],\n        [\"horizontal\", \"vertical\"],\n        [\"show\", \"hide\"],\n        [\"add\", \"remove\"],\n        [\"up\", \"down\"],\n        [\"before\", \"after\"],\n        [\"even\", \"odd\"],\n        [\"inside\", \"outside\"],\n        [\"next\", \"previous\"],\n        [\"increase\", \"decrease\"],\n        [\"attach\", \"detach\"],\n        [\"&&\", \"||\"],\n        [\"==\", \"!=\"]\n    ];\n\n    this.toggleWord = function () {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        this.selection.selectWord();\n        var currentState = this.getSelectedText();\n        var currWordStart = this.selection.getWordRange().start.column;\n        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\\s/);\n        var delta = column - currWordStart - 1;\n        if (delta < 0) delta = 0;\n        var curLength = 0, itLength = 0;\n        var that = this;\n        if (currentState.match(/[A-Za-z0-9_]+/)) {\n            wordParts.forEach(function (item, i) {\n                itLength = curLength + item.length;\n                if (delta >= curLength && delta <= itLength) {\n                    currentState = item;\n                    that.selection.clearSelection();\n                    that.moveCursorTo(row, curLength + currWordStart);\n                    that.selection.selectTo(row, itLength + currWordStart);\n                }\n                curLength = itLength;\n            });\n        }\n\n        var wordPairs = this.$toggleWordPairs;\n        var reg;\n        for (var i = 0; i < wordPairs.length; i++) {\n            var item = wordPairs[i];\n            for (var j = 0; j <= 1; j++) {\n                var negate = +!j;\n                var firstCondition = currentState.match(new RegExp('^\\\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\\\s?$', 'i'));\n                if (firstCondition) {\n                    var secondCondition = currentState.match(new RegExp('([_]|^|\\\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\\\s)', 'g'));\n                    if (secondCondition) {\n                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {\n                            var res = item[negate];\n                            if (result.toUpperCase() == result) {\n                                res = res.toUpperCase();\n                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {\n                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);\n                            }\n                            return res;\n                        });\n                        this.insert(reg);\n                        reg = \"\";\n                    }\n                }\n            }\n        }\n    };\n    this.removeLines = function() {\n        var rows = this.$getSelectedRows();\n        this.session.removeFullLines(rows.first, rows.last);\n        this.clearSelection();\n    };\n\n    this.duplicateSelection = function() {\n        var sel = this.selection;\n        var doc = this.session;\n        var range = sel.getRange();\n        var reverse = sel.isBackwards();\n        if (range.isEmpty()) {\n            var row = range.start.row;\n            doc.duplicateLines(row, row);\n        } else {\n            var point = reverse ? range.start : range.end;\n            var endPoint = doc.insert(point, doc.getTextRange(range), false);\n            range.start = point;\n            range.end = endPoint;\n\n            sel.setSelectionRange(range, reverse);\n        }\n    };\n    this.moveLinesDown = function() {\n        this.$moveLines(1, false);\n    };\n    this.moveLinesUp = function() {\n        this.$moveLines(-1, false);\n    };\n    this.moveText = function(range, toPosition, copy) {\n        return this.session.moveText(range, toPosition, copy);\n    };\n    this.copyLinesUp = function() {\n        this.$moveLines(-1, true);\n    };\n    this.copyLinesDown = function() {\n        this.$moveLines(1, true);\n    };\n    this.$moveLines = function(dir, copy) {\n        var rows, moved;\n        var selection = this.selection;\n        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n            var range = selection.toOrientedRange();\n            rows = this.$getSelectedRows(range);\n            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);\n            if (copy && dir == -1) moved = 0;\n            range.moveBy(moved, 0);\n            selection.fromOrientedRange(range);\n        } else {\n            var ranges = selection.rangeList.ranges;\n            selection.rangeList.detach(this.session);\n            this.inVirtualSelectionMode = true;\n            \n            var diff = 0;\n            var totalDiff = 0;\n            var l = ranges.length;\n            for (var i = 0; i < l; i++) {\n                var rangeIndex = i;\n                ranges[i].moveBy(diff, 0);\n                rows = this.$getSelectedRows(ranges[i]);\n                var first = rows.first;\n                var last = rows.last;\n                while (++i < l) {\n                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);\n                    var subRows = this.$getSelectedRows(ranges[i]);\n                    if (copy && subRows.first != last)\n                        break;\n                    else if (!copy && subRows.first > last + 1)\n                        break;\n                    last = subRows.last;\n                }\n                i--;\n                diff = this.session.$moveLines(first, last, copy ? 0 : dir);\n                if (copy && dir == -1) rangeIndex = i + 1;\n                while (rangeIndex <= i) {\n                    ranges[rangeIndex].moveBy(diff, 0);\n                    rangeIndex++;\n                }\n                if (!copy) diff = 0;\n                totalDiff += diff;\n            }\n            \n            selection.fromOrientedRange(selection.ranges[0]);\n            selection.rangeList.attach(this.session);\n            this.inVirtualSelectionMode = false;\n        }\n    };\n    this.$getSelectedRows = function(range) {\n        range = (range || this.getSelectionRange()).collapseRows();\n\n        return {\n            first: this.session.getRowFoldStart(range.start.row),\n            last: this.session.getRowFoldEnd(range.end.row)\n        };\n    };\n\n    this.onCompositionStart = function(compositionState) {\n        this.renderer.showComposition(compositionState);\n    };\n\n    this.onCompositionUpdate = function(text) {\n        this.renderer.setCompositionText(text);\n    };\n\n    this.onCompositionEnd = function() {\n        this.renderer.hideComposition();\n    };\n    this.getFirstVisibleRow = function() {\n        return this.renderer.getFirstVisibleRow();\n    };\n    this.getLastVisibleRow = function() {\n        return this.renderer.getLastVisibleRow();\n    };\n    this.isRowVisible = function(row) {\n        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n    };\n    this.isRowFullyVisible = function(row) {\n        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n    };\n    this.$getVisibleRowCount = function() {\n        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n    };\n\n    this.$moveByPage = function(dir, select) {\n        var renderer = this.renderer;\n        var config = this.renderer.layerConfig;\n        var rows = dir * Math.floor(config.height / config.lineHeight);\n\n        if (select === true) {\n            this.selection.$moveSelection(function(){\n                this.moveCursorBy(rows, 0);\n            });\n        } else if (select === false) {\n            this.selection.moveCursorBy(rows, 0);\n            this.selection.clearSelection();\n        }\n\n        var scrollTop = renderer.scrollTop;\n\n        renderer.scrollBy(0, rows * config.lineHeight);\n        if (select != null)\n            renderer.scrollCursorIntoView(null, 0.5);\n\n        renderer.animateScrolling(scrollTop);\n    };\n    this.selectPageDown = function() {\n        this.$moveByPage(1, true);\n    };\n    this.selectPageUp = function() {\n        this.$moveByPage(-1, true);\n    };\n    this.gotoPageDown = function() {\n       this.$moveByPage(1, false);\n    };\n    this.gotoPageUp = function() {\n        this.$moveByPage(-1, false);\n    };\n    this.scrollPageDown = function() {\n        this.$moveByPage(1);\n    };\n    this.scrollPageUp = function() {\n        this.$moveByPage(-1);\n    };\n    this.scrollToRow = function(row) {\n        this.renderer.scrollToRow(row);\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        this.renderer.scrollToLine(line, center, animate, callback);\n    };\n    this.centerSelection = function() {\n        var range = this.getSelectionRange();\n        var pos = {\n            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n        };\n        this.renderer.alignCursor(pos, 0.5);\n    };\n    this.getCursorPosition = function() {\n        return this.selection.getCursor();\n    };\n    this.getCursorPositionScreen = function() {\n        return this.session.documentToScreenPosition(this.getCursorPosition());\n    };\n    this.getSelectionRange = function() {\n        return this.selection.getRange();\n    };\n    this.selectAll = function() {\n        this.selection.selectAll();\n    };\n    this.clearSelection = function() {\n        this.selection.clearSelection();\n    };\n    this.moveCursorTo = function(row, column) {\n        this.selection.moveCursorTo(row, column);\n    };\n    this.moveCursorToPosition = function(pos) {\n        this.selection.moveCursorToPosition(pos);\n    };\n    this.jumpToMatching = function(select, expand) {\n        var cursor = this.getCursorPosition();\n        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n        var prevToken = iterator.getCurrentToken();\n        var token = prevToken || iterator.stepForward();\n\n        if (!token) return;\n        var matchType;\n        var found = false;\n        var depth = {};\n        var i = cursor.column - token.start;\n        var bracketType;\n        var brackets = {\n            \")\": \"(\",\n            \"(\": \"(\",\n            \"]\": \"[\",\n            \"[\": \"[\",\n            \"{\": \"{\",\n            \"}\": \"{\"\n        };\n        \n        do {\n            if (token.value.match(/[{}()\\[\\]]/g)) {\n                for (; i < token.value.length && !found; i++) {\n                    if (!brackets[token.value[i]]) {\n                        continue;\n                    }\n\n                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n\n                    if (isNaN(depth[bracketType])) {\n                        depth[bracketType] = 0;\n                    }\n\n                    switch (token.value[i]) {\n                        case '(':\n                        case '[':\n                        case '{':\n                            depth[bracketType]++;\n                            break;\n                        case ')':\n                        case ']':\n                        case '}':\n                            depth[bracketType]--;\n\n                            if (depth[bracketType] === -1) {\n                                matchType = 'bracket';\n                                found = true;\n                            }\n                        break;\n                    }\n                }\n            }\n            else if (token.type.indexOf('tag-name') !== -1) {\n                if (isNaN(depth[token.value])) {\n                    depth[token.value] = 0;\n                }\n                \n                if (prevToken.value === '<') {\n                    depth[token.value]++;\n                }\n                else if (prevToken.value === '</') {\n                    depth[token.value]--;\n                }\n                \n                if (depth[token.value] === -1) {\n                    matchType = 'tag';\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                prevToken = token;\n                token = iterator.stepForward();\n                i = 0;\n            }\n        } while (token && !found);\n        if (!matchType)\n            return;\n\n        var range, pos;\n        if (matchType === 'bracket') {\n            range = this.session.getBracketRange(cursor);\n            if (!range) {\n                range = new Range(\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1,\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1\n                );\n                pos = range.start;\n                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    range = this.session.getBracketRange(pos);\n            }\n        }\n        else if (matchType === 'tag') {\n            if (token && token.type.indexOf('tag-name') !== -1) \n                var tag = token.value;\n            else\n                return;\n\n            range = new Range(\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2,\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2\n            );\n            if (range.compare(cursor.row, cursor.column) === 0) {\n                found = false;\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (prevToken) {\n                        if (prevToken.type.indexOf('tag-close') !== -1) {\n                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n                        }\n\n                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                            if (prevToken.value === '<') {\n                                depth[tag]++;\n                            }\n                            else if (prevToken.value === '</') {\n                                depth[tag]--;\n                            }\n                            \n                            if (depth[tag] === 0)\n                                found = true;\n                        }\n                    }\n                } while (prevToken && !found);\n            }\n            if (token && token.type.indexOf('tag-name')) {\n                pos = range.start;\n                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    pos = range.end;\n            }\n        }\n\n        pos = range && range.cursor || pos;\n        if (pos) {\n            if (select) {\n                if (range && expand) {\n                    this.selection.setRange(range);\n                } else if (range && range.isEqual(this.getSelectionRange())) {\n                    this.clearSelection();\n                } else {\n                    this.selection.selectTo(pos.row, pos.column);\n                }\n            } else {\n                this.selection.moveTo(pos.row, pos.column);\n            }\n        }\n    };\n    this.gotoLine = function(lineNumber, column, animate) {\n        this.selection.clearSelection();\n        this.session.unfold({row: lineNumber - 1, column: column || 0});\n        this.exitMultiSelectMode && this.exitMultiSelectMode();\n        this.moveCursorTo(lineNumber - 1, column || 0);\n\n        if (!this.isRowFullyVisible(lineNumber - 1))\n            this.scrollToLine(lineNumber - 1, true, animate);\n    };\n    this.navigateTo = function(row, column) {\n        this.selection.moveTo(row, column);\n    };\n    this.navigateUp = function(times) {\n        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n            var selectionStart = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionStart);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(-times || -1, 0);\n    };\n    this.navigateDown = function(times) {\n        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n            var selectionEnd = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionEnd);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(times || 1, 0);\n    };\n    this.navigateLeft = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionStart = this.getSelectionRange().start;\n            this.moveCursorToPosition(selectionStart);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorLeft();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateRight = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionEnd = this.getSelectionRange().end;\n            this.moveCursorToPosition(selectionEnd);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorRight();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateLineStart = function() {\n        this.selection.moveCursorLineStart();\n        this.clearSelection();\n    };\n    this.navigateLineEnd = function() {\n        this.selection.moveCursorLineEnd();\n        this.clearSelection();\n    };\n    this.navigateFileEnd = function() {\n        this.selection.moveCursorFileEnd();\n        this.clearSelection();\n    };\n    this.navigateFileStart = function() {\n        this.selection.moveCursorFileStart();\n        this.clearSelection();\n    };\n    this.navigateWordRight = function() {\n        this.selection.moveCursorWordRight();\n        this.clearSelection();\n    };\n    this.navigateWordLeft = function() {\n        this.selection.moveCursorWordLeft();\n        this.clearSelection();\n    };\n    this.replace = function(replacement, options) {\n        if (options)\n            this.$search.set(options);\n\n        var range = this.$search.find(this.session);\n        var replaced = 0;\n        if (!range)\n            return replaced;\n\n        if (this.$tryReplace(range, replacement)) {\n            replaced = 1;\n        }\n\n        this.selection.setSelectionRange(range);\n        this.renderer.scrollSelectionIntoView(range.start, range.end);\n\n        return replaced;\n    };\n    this.replaceAll = function(replacement, options) {\n        if (options) {\n            this.$search.set(options);\n        }\n\n        var ranges = this.$search.findAll(this.session);\n        var replaced = 0;\n        if (!ranges.length)\n            return replaced;\n\n        var selection = this.getSelectionRange();\n        this.selection.moveTo(0, 0);\n\n        for (var i = ranges.length - 1; i >= 0; --i) {\n            if(this.$tryReplace(ranges[i], replacement)) {\n                replaced++;\n            }\n        }\n\n        this.selection.setSelectionRange(selection);\n\n        return replaced;\n    };\n\n    this.$tryReplace = function(range, replacement) {\n        var input = this.session.getTextRange(range);\n        replacement = this.$search.replace(input, replacement);\n        if (replacement !== null) {\n            range.end = this.session.replace(range, replacement);\n            return range;\n        } else {\n            return null;\n        }\n    };\n    this.getLastSearchOptions = function() {\n        return this.$search.getOptions();\n    };\n    this.find = function(needle, options, animate) {\n        if (!options)\n            options = {};\n\n        if (typeof needle == \"string\" || needle instanceof RegExp)\n            options.needle = needle;\n        else if (typeof needle == \"object\")\n            oop.mixin(options, needle);\n\n        var range = this.selection.getRange();\n        if (options.needle == null) {\n            needle = this.session.getTextRange(range)\n                || this.$search.$options.needle;\n            if (!needle) {\n                range = this.session.getWordRange(range.start.row, range.start.column);\n                needle = this.session.getTextRange(range);\n            }\n            this.$search.set({needle: needle});\n        }\n\n        this.$search.set(options);\n        if (!options.start)\n            this.$search.set({start: range});\n\n        var newRange = this.$search.find(this.session);\n        if (options.preventScroll)\n            return newRange;\n        if (newRange) {\n            this.revealRange(newRange, animate);\n            return newRange;\n        }\n        if (options.backwards)\n            range.start = range.end;\n        else\n            range.end = range.start;\n        this.selection.setRange(range);\n    };\n    this.findNext = function(options, animate) {\n        this.find({skipCurrent: true, backwards: false}, options, animate);\n    };\n    this.findPrevious = function(options, animate) {\n        this.find(options, {skipCurrent: true, backwards: true}, animate);\n    };\n\n    this.revealRange = function(range, animate) {\n        this.session.unfold(range);\n        this.selection.setSelectionRange(range);\n\n        var scrollTop = this.renderer.scrollTop;\n        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n        if (animate !== false)\n            this.renderer.animateScrolling(scrollTop);\n    };\n    this.undo = function() {\n        this.session.getUndoManager().undo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.redo = function() {\n        this.session.getUndoManager().redo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.destroy = function() {\n        this.renderer.destroy();\n        this._signal(\"destroy\", this);\n        if (this.session) {\n            this.session.destroy();\n        }\n    };\n    this.setAutoScrollEditorIntoView = function(enable) {\n        if (!enable)\n            return;\n        var rect;\n        var self = this;\n        var shouldScroll = false;\n        if (!this.$scrollAnchor)\n            this.$scrollAnchor = document.createElement(\"div\");\n        var scrollAnchor = this.$scrollAnchor;\n        scrollAnchor.style.cssText = \"position:absolute\";\n        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n        var onChangeSelection = this.on(\"changeSelection\", function() {\n            shouldScroll = true;\n        });\n        var onBeforeRender = this.renderer.on(\"beforeRender\", function() {\n            if (shouldScroll)\n                rect = self.renderer.container.getBoundingClientRect();\n        });\n        var onAfterRender = this.renderer.on(\"afterRender\", function() {\n            if (shouldScroll && rect && (self.isFocused()\n                || self.searchBox && self.searchBox.isFocused())\n            ) {\n                var renderer = self.renderer;\n                var pos = renderer.$cursorLayer.$pixelPos;\n                var config = renderer.layerConfig;\n                var top = pos.top - config.offset;\n                if (pos.top >= 0 && top + rect.top < 0) {\n                    shouldScroll = true;\n                } else if (pos.top < config.height &&\n                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n                    shouldScroll = false;\n                } else {\n                    shouldScroll = null;\n                }\n                if (shouldScroll != null) {\n                    scrollAnchor.style.top = top + \"px\";\n                    scrollAnchor.style.left = pos.left + \"px\";\n                    scrollAnchor.style.height = config.lineHeight + \"px\";\n                    scrollAnchor.scrollIntoView(shouldScroll);\n                }\n                shouldScroll = rect = null;\n            }\n        });\n        this.setAutoScrollEditorIntoView = function(enable) {\n            if (enable)\n                return;\n            delete this.setAutoScrollEditorIntoView;\n            this.off(\"changeSelection\", onChangeSelection);\n            this.renderer.off(\"afterRender\", onAfterRender);\n            this.renderer.off(\"beforeRender\", onBeforeRender);\n        };\n    };\n\n\n    this.$resetCursorStyle = function() {\n        var style = this.$cursorStyle || \"ace\";\n        var cursorLayer = this.renderer.$cursorLayer;\n        if (!cursorLayer)\n            return;\n        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n    };\n    this.prompt = function(message, options, callback) {\n        var editor = this;\n        config.loadModule(\"./ext/prompt\", function (module) {\n            module.prompt(editor, message, options, callback);\n        });\n    };\n\n}).call(Editor.prototype);\n\n\n\nconfig.defineOptions(Editor.prototype, \"editor\", {\n    selectionStyle: {\n        set: function(style) {\n            this.onSelectionChange();\n            this._signal(\"changeSelectionStyle\", {data: style});\n        },\n        initialValue: \"line\"\n    },\n    highlightActiveLine: {\n        set: function() {this.$updateHighlightActiveLine();},\n        initialValue: true\n    },\n    highlightSelectedWord: {\n        set: function(shouldHighlight) {this.$onSelectionChange();},\n        initialValue: true\n    },\n    readOnly: {\n        set: function(readOnly) {\n            this.textInput.setReadOnly(readOnly);\n            this.$resetCursorStyle(); \n        },\n        initialValue: false\n    },\n    copyWithEmptySelection: {\n        set: function(value) {\n            this.textInput.setCopyWithEmptySelection(value);\n        },\n        initialValue: false\n    },\n    cursorStyle: {\n        set: function(val) { this.$resetCursorStyle(); },\n        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n        initialValue: \"ace\"\n    },\n    mergeUndoDeltas: {\n        values: [false, true, \"always\"],\n        initialValue: true\n    },\n    behavioursEnabled: {initialValue: true},\n    wrapBehavioursEnabled: {initialValue: true},\n    autoScrollEditorIntoView: {\n        set: function(val) {this.setAutoScrollEditorIntoView(val);}\n    },\n    keyboardHandler: {\n        set: function(val) { this.setKeyboardHandler(val); },\n        get: function() { return this.$keybindingId; },\n        handlesSet: true\n    },\n    value: {\n        set: function(val) { this.session.setValue(val); },\n        get: function() { return this.getValue(); },\n        handlesSet: true,\n        hidden: true\n    },\n    session: {\n        set: function(val) { this.setSession(val); },\n        get: function() { return this.session; },\n        handlesSet: true,\n        hidden: true\n    },\n    \n    showLineNumbers: {\n        set: function(show) {\n            this.renderer.$gutterLayer.setShowLineNumbers(show);\n            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);\n            if (show && this.$relativeLineNumbers)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        },\n        initialValue: true\n    },\n    relativeLineNumbers: {\n        set: function(value) {\n            if (this.$showLineNumbers && value)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        }\n    },\n\n    hScrollBarAlwaysVisible: \"renderer\",\n    vScrollBarAlwaysVisible: \"renderer\",\n    highlightGutterLine: \"renderer\",\n    animatedScroll: \"renderer\",\n    showInvisibles: \"renderer\",\n    showPrintMargin: \"renderer\",\n    printMarginColumn: \"renderer\",\n    printMargin: \"renderer\",\n    fadeFoldWidgets: \"renderer\",\n    showFoldWidgets: \"renderer\",\n    displayIndentGuides: \"renderer\",\n    showGutter: \"renderer\",\n    fontSize: \"renderer\",\n    fontFamily: \"renderer\",\n    maxLines: \"renderer\",\n    minLines: \"renderer\",\n    scrollPastEnd: \"renderer\",\n    fixedWidthGutter: \"renderer\",\n    theme: \"renderer\",\n    hasCssTransforms: \"renderer\",\n    maxPixelHeight: \"renderer\",\n    useTextareaForIME: \"renderer\",\n\n    scrollSpeed: \"$mouseHandler\",\n    dragDelay: \"$mouseHandler\",\n    dragEnabled: \"$mouseHandler\",\n    focusTimeout: \"$mouseHandler\",\n    tooltipFollowsMouse: \"$mouseHandler\",\n\n    firstLineNumber: \"session\",\n    overwrite: \"session\",\n    newLineMode: \"session\",\n    useWorker: \"session\",\n    useSoftTabs: \"session\",\n    navigateWithinSoftTabs: \"session\",\n    tabSize: \"session\",\n    wrap: \"session\",\n    indentedSoftWrap: \"session\",\n    foldStyle: \"session\",\n    mode: \"session\"\n});\n\n\nvar relativeNumberRenderer = {\n    getText: function(session, row) {\n        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? \"\\xb7\" : \"\"))) + \"\";\n    },\n    getWidth: function(session, lastLineNumber, config) {\n        return Math.max(\n            lastLineNumber.toString().length,\n            (config.lastRow + 1).toString().length,\n            2\n        ) * config.characterWidth;\n    },\n    update: function(e, editor) {\n        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);\n    },\n    attach: function(editor) {\n        editor.renderer.$gutterLayer.$renderer = this;\n        editor.on(\"changeSelection\", this.update);\n        this.update(null, editor);\n    },\n    detach: function(editor) {\n        if (editor.renderer.$gutterLayer.$renderer == this)\n            editor.renderer.$gutterLayer.$renderer = null;\n        editor.off(\"changeSelection\", this.update);\n        this.update(null, editor);\n    }\n};\n\nexports.Editor = Editor;\n});\n\nace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar UndoManager = function() {\n    this.$maxRev = 0;\n    this.$fromUndo = false;\n    this.reset();\n};\n\n(function() {\n    \n    this.addSession = function(session) {\n        this.$session = session;\n    };\n    this.add = function(delta, allowMerge, session) {\n        if (this.$fromUndo) return;\n        if (delta == this.$lastDelta) return;\n        if (allowMerge === false || !this.lastDeltas) {\n            this.lastDeltas = [];\n            this.$undoStack.push(this.lastDeltas);\n            delta.id = this.$rev = ++this.$maxRev;\n        }\n        if (delta.action == \"remove\" || delta.action == \"insert\")\n            this.$lastDelta = delta;\n        this.lastDeltas.push(delta);\n    };\n    \n    this.addSelection = function(selection, rev) {\n        this.selections.push({\n            value: selection,\n            rev: rev || this.$rev\n        });\n    };\n    \n    this.startNewGroup = function() {\n        this.lastDeltas = null;\n        return this.$rev;\n    };\n    \n    this.markIgnored = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id <= from)\n                break;\n            if (delta.id < to)\n                delta.ignore = true;\n        }\n        this.lastDeltas = null;\n    };\n    \n    this.getSelection = function(rev, after) {\n        var stack = this.selections;\n        for (var i = stack.length; i--;) {\n            var selection = stack[i];\n            if (selection.rev < rev) {\n                if (after)\n                    selection = stack[i + 1];\n                return selection;\n            }\n        }\n    };\n    \n    this.getRevision = function() {\n        return this.$rev;\n    };\n    \n    this.getDeltas = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        var end = null, start = 0;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id < to && !end)\n                end = i+1;\n            if (delta.id <= from) {\n                start = i + 1;\n                break;\n            }\n        }\n        return stack.slice(start, end);\n    };\n    \n    this.getChangedRanges = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n    \n    this.getChangedLines = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n    this.undo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        var stack = this.$undoStack;\n        \n        if (!rearrangeUndoStack(stack, stack.length))\n            return;\n        \n        if (!session)\n            session = this.$session;\n        \n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\n            this.$redoStack = [];\n        \n        this.$fromUndo = true;\n        \n        var deltaSet = stack.pop();\n        var undoSelectionRange = null;\n        if (deltaSet && deltaSet.length) {\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\n            this.$redoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        \n        this.$fromUndo = false;\n\n        return undoSelectionRange;\n    };\n    this.redo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        \n        if (!session)\n            session = this.$session;\n        \n        this.$fromUndo = true;\n        if (this.$redoStackBaseRev != this.$rev) {\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\n            rebaseRedoStack(this.$redoStack, diff);\n            this.$redoStackBaseRev = this.$rev;\n            this.$redoStack.forEach(function(x) {\n                x[0].id = ++this.$maxRev;\n            }, this);\n        }\n        var deltaSet = this.$redoStack.pop();\n        var redoSelectionRange = null;\n        \n        if (deltaSet) {\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\n            this.$undoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        \n        return redoSelectionRange;\n    };\n    \n    this.$syncRev = function() {\n        var stack = this.$undoStack;\n        var nextDelta = stack[stack.length - 1];\n        var id = nextDelta && nextDelta[0].id || 0;\n        this.$redoStackBaseRev = id;\n        this.$rev = id;\n    };\n    this.reset = function() {\n        this.lastDeltas = null;\n        this.$lastDelta = null;\n        this.$undoStack = [];\n        this.$redoStack = [];\n        this.$rev = 0;\n        this.mark = 0;\n        this.$redoStackBaseRev = this.$rev;\n        this.selections = [];\n    };\n    this.canUndo = function() {\n        return this.$undoStack.length > 0;\n    };\n    this.canRedo = function() {\n        return this.$redoStack.length > 0;\n    };\n    this.bookmark = function(rev) {\n        if (rev == undefined)\n            rev = this.$rev;\n        this.mark = rev;\n    };\n    this.isAtBookmark = function() {\n        return this.$rev === this.mark;\n    };\n    \n    this.toJSON = function() {\n        \n    };\n    \n    this.fromJSON = function() {\n        \n    };\n    \n    this.hasUndo = this.canUndo;\n    this.hasRedo = this.canRedo;\n    this.isClean = this.isAtBookmark;\n    this.markClean = this.bookmark;\n    \n    this.$prettyPrint = function(delta) {\n        if (delta) return stringifyDelta(delta);\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\n    };\n}).call(UndoManager.prototype);\n\nfunction rearrangeUndoStack(stack, pos) {\n    for (var i = pos; i--; ) {\n        var deltaSet = stack[i];\n        if (deltaSet && !deltaSet[0].ignore) {\n            while(i < pos - 1) {\n                var swapped = swapGroups(stack[i], stack[i + 1]);\n                stack[i] = swapped[0];\n                stack[i + 1] = swapped[1];\n                i++;\n            }\n            return true;\n        }\n    }\n}\n\nvar Range = require(\"./range\").Range;\nvar cmp = Range.comparePoints;\nvar comparePoints = Range.comparePoints;\n\nfunction $updateMarkers(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert) end = start;\n\n    for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = comparePoints(point, start);\n        if (cmp < 0) {\n            continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n            if (isInsert) {\n                if (point.bias == 1) {\n                    cmp = 1;\n                }\n                else {\n                    point.bias == -1;\n                    continue;\n                }\n            }\n        }\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\n        if (cmp2 > 0) {\n            point.row += rowShift;\n            point.column += point.row == end.row ? colShift : 0;\n            continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n            point.row = start.row;\n            point.column = start.column;\n            if (cmp2 === 0)\n                point.bias = 1;\n        }\n    }\n}\n\n\n\nfunction clonePos(pos) {\n    return {row: pos.row,column: pos.column};\n}\nfunction cloneDelta(d) {\n    return {\n        start: clonePos(d.start),\n        end: clonePos(d.end),\n        action: d.action,\n        lines: d.lines.slice()\n    };\n}\nfunction stringifyDelta(d) {\n    d = d || this;\n    if (Array.isArray(d)) {\n        return d.map(stringifyDelta).join(\"\\n\");\n    }\n    var type = \"\";\n    if (d.action) {\n        type = d.action == \"insert\" ? \"+\" : \"-\";\n        type += \"[\" + d.lines + \"]\";\n    } else if (d.value) {\n        if (Array.isArray(d.value)) {\n            type = d.value.map(stringifyRange).join(\"\\n\");\n        } else {\n            type = stringifyRange(d.value);\n        }\n    }\n    if (d.start) {\n        type += stringifyRange(d);\n    }\n    if (d.id || d.rev) {\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\n    }\n    return type;\n}\nfunction stringifyRange(r) {\n    return r.start.row + \":\" + r.start.column \n        + \"=>\" + r.end.row + \":\" + r.end.column;\n}\n\nfunction swap(d1, d2) {\n    var i1 = d1.action == \"insert\";\n    var i2 = d2.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    }\n    return [d2, d1];\n}\nfunction swapGroups(ds1, ds2) {\n    for (var i = ds1.length; i--; ) {\n        for (var j = 0; j < ds2.length; j++) {\n            if (!swap(ds1[i], ds2[j])) {\n                while (i < ds1.length) {\n                    while (j--) {\n                        swap(ds2[j], ds1[i]);\n                    }\n                    j = ds2.length;\n                    i++;\n                }                \n                return [ds1, ds2];\n            }\n        }\n    }\n    ds1.selectionBefore = ds2.selectionBefore = \n    ds1.selectionAfter = ds2.selectionAfter = null;\n    return [ds2, ds1];\n}\nfunction xform(d1, c1) {\n    var i1 = d1.action == \"insert\";\n    var i2 = c1.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d1.start, c1.start) < 0) {\n            shift(c1, d1, 1);\n        } else {\n            shift(d1, c1, 1);\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d1.start, c1.end) >= 0) {\n            shift(d1, c1, -1);\n        } else if (cmp(d1.start, c1.start) <= 0) {\n            shift(c1, d1, +1);\n        } else {\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\n            shift(c1, d1, +1);\n        }\n    } else if (!i1 && i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.start, d1.start) <= 0) {\n            shift(d1, c1, +1);\n        } else {\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\n            shift(d1, c1, +1);\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.end, d1.start) <= 0) {\n            shift(d1, c1, -1);\n        } else {\n            var before, after;\n            if (cmp(d1.start, c1.start) < 0) {\n                before = d1;\n                d1 = splitDelta(d1, c1.start);\n            }\n            if (cmp(d1.end, c1.end) > 0) {\n                after = splitDelta(d1, c1.end);\n            }\n\n            shiftPos(c1.end, d1.start, d1.end, -1);\n            if (after && !before) {\n                d1.lines = after.lines;\n                d1.start = after.start;\n                d1.end = after.end;\n                after = d1;\n            }\n\n            return [c1, before, after].filter(Boolean);\n        }\n    }\n    return [c1, d1];\n}\n    \nfunction shift(d1, d2, dir) {\n    shiftPos(d1.start, d2.start, d2.end, dir);\n    shiftPos(d1.end, d2.start, d2.end, dir);\n}\nfunction shiftPos(pos, start, end, dir) {\n    if (pos.row == (dir == 1 ? start : end).row) {\n        pos.column += dir * (end.column - start.column);\n    }\n    pos.row += dir * (end.row - start.row);\n}\nfunction splitDelta(c, pos) {\n    var lines = c.lines;\n    var end = c.end;\n    c.end = clonePos(pos);    \n    var rowsBefore = c.end.row - c.start.row;\n    var otherLines = lines.splice(rowsBefore, lines.length);\n    \n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\n    lines.push(otherLines[0].substring(0, col));\n    otherLines[0] = otherLines[0].substr(col)   ; \n    var rest = {\n        start: clonePos(pos),\n        end: end,\n        lines: otherLines,\n        action: c.action\n    };\n    return rest;\n}\n\nfunction moveDeltasByOne(redoStack, d) {\n    d = cloneDelta(d);\n    for (var j = redoStack.length; j--;) {\n        var deltaSet = redoStack[j];\n        for (var i = 0; i < deltaSet.length; i++) {\n            var x = deltaSet[i];\n            var xformed = xform(x, d);\n            d = xformed[0];\n            if (xformed.length != 2) {\n                if (xformed[2]) {\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\n                    i++;\n                } else if (!xformed[1]) {\n                    deltaSet.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (!deltaSet.length) {\n            redoStack.splice(j, 1); \n        }\n    }\n    return redoStack;\n}\nfunction rebaseRedoStack(redoStack, deltaSets) {\n    for (var i = 0; i < deltaSets.length; i++) {\n        var deltas = deltaSets[i];\n        for (var j = 0; j < deltas.length; j++) {\n            moveDeltasByOne(redoStack, deltas[j]);\n        }\n    }\n}\n\nexports.UndoManager = UndoManager;\n\n});\n\nace.define(\"ace/layer/lines\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Lines = function(element, canvasHeight) {\n    this.element = element;\n    this.canvasHeight = canvasHeight || 500000;\n    this.element.style.height = (this.canvasHeight * 2) + \"px\";\n    \n    this.cells = [];\n    this.cellCache = [];\n    this.$offsetCoefficient = 0;\n};\n\n(function() {\n    \n    this.moveContainer = function(config) {\n        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);\n    };    \n    \n    this.pageChanged = function(oldConfig, newConfig) {\n        return (\n            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==\n            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)\n        );\n    };\n    \n    this.computeLineTop = function(row, config, session) {\n        var screenTop = config.firstRowScreen * config.lineHeight;\n        var screenPage = Math.floor(screenTop / this.canvasHeight);\n        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;\n        return lineTop - (screenPage * this.canvasHeight);\n    };\n    \n    this.computeLineHeight = function(row, config, session) {\n        return config.lineHeight * session.getRowLength(row);\n    };\n    \n    this.getLength = function() {\n        return this.cells.length;\n    };\n    \n    this.get = function(index) {\n        return this.cells[index];\n    };\n    \n    this.shift = function() {\n        this.$cacheCell(this.cells.shift());\n    };\n    \n    this.pop = function() {\n        this.$cacheCell(this.cells.pop());\n    };\n    \n    this.push = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.push.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            this.element.appendChild(fragment);\n         } else {\n            this.cells.push(cell);\n            this.element.appendChild(cell.element);\n         }\n    };\n    \n    this.unshift = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.unshift.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            if (this.element.firstChild)\n                this.element.insertBefore(fragment, this.element.firstChild);\n            else\n                this.element.appendChild(fragment);\n         } else {\n            this.cells.unshift(cell);\n            this.element.insertAdjacentElement(\"afterbegin\", cell.element);\n         }\n    };\n    \n    this.last = function() {\n        if (this.cells.length)\n            return this.cells[this.cells.length-1];\n        else\n            return null;\n    };\n    \n    this.$cacheCell = function(cell) {\n        if (!cell)\n            return;\n            \n        cell.element.remove();\n        this.cellCache.push(cell);\n    };\n    \n    this.createCell = function(row, config, session, initElement) {\n        var cell = this.cellCache.pop();\n        if (!cell) {\n            var element = dom.createElement(\"div\");\n            if (initElement)\n                initElement(element);\n            \n            this.element.appendChild(element);\n            \n            cell = {\n                element: element,\n                text: \"\",\n                row: row\n            };\n        }\n        cell.row = row;\n        \n        return cell;\n    };\n    \n}).call(Lines.prototype);\n\nexports.Lines = Lines;\n\n});\n\nace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/layer/lines\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Lines = require(\"./lines\").Lines;\n\nvar Gutter = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_gutter-layer\";\n    parentEl.appendChild(this.element);\n    this.setShowFoldWidgets(this.$showFoldWidgets);\n    \n    this.gutterWidth = 0;\n\n    this.$annotations = [];\n    this.$updateAnnotations = this.$updateAnnotations.bind(this);\n    \n    this.$lines = new Lines(this.element);\n    this.$lines.$offsetCoefficient = 1;\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.removeEventListener(\"change\", this.$updateAnnotations);\n        this.session = session;\n        if (session)\n            session.on(\"change\", this.$updateAnnotations);\n    };\n\n    this.addGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n        this.session.addGutterDecoration(row, className);\n    };\n\n    this.removeGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n        this.session.removeGutterDecoration(row, className);\n    };\n\n    this.setAnnotations = function(annotations) {\n        this.$annotations = [];\n        for (var i = 0; i < annotations.length; i++) {\n            var annotation = annotations[i];\n            var row = annotation.row;\n            var rowInfo = this.$annotations[row];\n            if (!rowInfo)\n                rowInfo = this.$annotations[row] = {text: []};\n           \n            var annoText = annotation.text;\n            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n\n            if (rowInfo.text.indexOf(annoText) === -1)\n                rowInfo.text.push(annoText);\n\n            var type = annotation.type;\n            if (type == \"error\")\n                rowInfo.className = \" ace_error\";\n            else if (type == \"warning\" && rowInfo.className != \" ace_error\")\n                rowInfo.className = \" ace_warning\";\n            else if (type == \"info\" && (!rowInfo.className))\n                rowInfo.className = \" ace_info\";\n        }\n    };\n\n    this.$updateAnnotations = function (delta) {\n        if (!this.$annotations.length)\n            return;\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n        } else if (delta.action == 'remove') {\n            this.$annotations.splice(firstRow, len + 1, null);\n        } else {\n            var args = new Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.$annotations.splice.apply(this.$annotations, args);\n        }\n    };\n\n    this.update = function(config) {\n        this.config = config;\n        \n        var session = this.session;\n        var firstRow = config.firstRow;\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            session.getLength() - 1);\n            \n        this.oldLastRow = lastRow;\n        this.config = config;\n        \n        this.$lines.moveContainer(config);\n        this.$updateCursorRow();\n            \n        var fold = session.getNextFoldLine(firstRow);\n        var foldStart = fold ? fold.start.row : Infinity;\n\n        var cell = null;\n        var index = -1;\n        var row = firstRow;\n        \n        while (true) {\n            if (row > foldStart) {\n                row = fold.end.row + 1;\n                fold = session.getNextFoldLine(row, fold);\n                foldStart = fold ? fold.start.row : Infinity;\n            }\n            if (row > lastRow) {\n                while (this.$lines.getLength() > index + 1)\n                    this.$lines.pop();\n                    \n                break;\n            }\n\n            cell = this.$lines.get(++index);\n            if (cell) {\n                cell.row = row;\n            } else {\n                cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n                this.$lines.push(cell);\n            }\n\n            this.$renderCell(cell, config, fold, row);\n            row++;\n        }\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$updateGutterWidth = function(config) {\n        var session = this.session;\n        \n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        \n        var firstLineNumber = session.$firstLineNumber;\n        var lastLineText = this.$lines.last() ? this.$lines.last().text : \"\";\n        \n        if (this.$fixedWidth || session.$useWrapMode)\n            lastLineText = session.getLength() + firstLineNumber - 1;\n\n        var gutterWidth = gutterRenderer \n            ? gutterRenderer.getWidth(session, lastLineText, config)\n            : lastLineText.toString().length * config.characterWidth;\n        \n        var padding = this.$padding || this.$computePadding();\n        gutterWidth += padding.left + padding.right;\n        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n            this.gutterWidth = gutterWidth;\n            this.element.parentNode.style.width = \n            this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n            this._signal(\"changeGutterWidth\", gutterWidth);\n        }\n    };\n    \n    this.$updateCursorRow = function() {\n        if (!this.$highlightGutterLine)\n            return;\n            \n        var position = this.session.selection.getCursor();\n        if (this.$cursorRow === position.row)\n            return;\n        \n        this.$cursorRow = position.row;\n    };\n    \n    this.updateLineHighlight = function() {\n        if (!this.$highlightGutterLine)\n            return;\n        var row = this.session.selection.cursor.row;\n        this.$cursorRow = row;\n\n        if (this.$cursorCell && this.$cursorCell.row == row)\n            return;\n        if (this.$cursorCell)\n            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n        var cells = this.$lines.cells;\n        this.$cursorCell = null;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            if (cell.row >= this.$cursorRow) {\n                if (cell.row > this.$cursorRow) {\n                    var fold = this.session.getFoldLine(this.$cursorRow);\n                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)\n                        cell = cells[i - 1];\n                    else\n                        break;\n                }\n                cell.element.className = \"ace_gutter-active-line \" + cell.element.className;\n                this.$cursorCell = cell;\n                break;\n            }\n        }\n    };\n    \n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n        \n        this.$updateCursorRow();\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        \n        this.$lines.moveContainer(config);\n\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            this.session.getLength() - 1);\n        var oldLastRow = this.oldLastRow;\n        this.oldLastRow = lastRow;\n        \n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldLastRow > lastRow)\n            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (lastRow > oldLastRow) {\n            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));\n        }\n        \n        this.updateLineHighlight();\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$renderLines = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n            this.$renderCell(cell, config, foldLine, row);\n            fragment.push(cell);\n\n            row++;\n        }\n        return fragment;\n    };\n    \n    this.$renderCell = function(cell, config, fold, row) {\n        var element = cell.element;\n        \n        var session = this.session;\n        \n        var textNode = element.childNodes[0];\n        var foldWidget = element.childNodes[1];\n\n        var firstLineNumber = session.$firstLineNumber;\n        \n        var breakpoints = session.$breakpoints;\n        var decorations = session.$decorations;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;\n        \n        var className = \"ace_gutter-cell \";\n        if (this.$highlightGutterLine) {\n            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {\n                className += \"ace_gutter-active-line \";\n                if (this.$cursorCell != cell) {\n                    if (this.$cursorCell)\n                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n                    this.$cursorCell = cell;\n                }\n            }\n        }\n        \n        if (breakpoints[row])\n            className += breakpoints[row];\n        if (decorations[row])\n            className += decorations[row];\n        if (this.$annotations[row])\n            className += this.$annotations[row].className;\n        if (element.className != className)\n            element.className = className;\n\n        if (foldWidgets) {\n            var c = foldWidgets[row];\n            if (c == null)\n                c = foldWidgets[row] = session.getFoldWidget(row);\n        }\n\n        if (c) {\n            var className = \"ace_fold-widget ace_\" + c;\n            if (c == \"start\" && row == foldStart && row < fold.end.row)\n                className += \" ace_closed\";\n            else\n                className += \" ace_open\";\n            if (foldWidget.className != className)\n                foldWidget.className = className;\n\n            var foldHeight = config.lineHeight + \"px\";\n            dom.setStyle(foldWidget.style, \"height\", foldHeight);\n            dom.setStyle(foldWidget.style, \"display\", \"inline-block\");\n        } else {\n            if (foldWidget) {\n                dom.setStyle(foldWidget.style, \"display\", \"none\");\n            }\n        }\n        \n        var text = (gutterRenderer\n            ? gutterRenderer.getText(session, row)\n            : row + firstLineNumber).toString();\n            \n        if (text !== textNode.data) {\n            textNode.data = text;\n        }\n        \n        dom.setStyle(cell.element.style, \"height\", this.$lines.computeLineHeight(row, config, session) + \"px\");\n        dom.setStyle(cell.element.style, \"top\", this.$lines.computeLineTop(row, config, session) + \"px\");\n        \n        cell.text = text;\n        return cell;\n    };\n\n    this.$fixedWidth = false;\n    \n    this.$highlightGutterLine = true;\n    this.$renderer = \"\";\n    this.setHighlightGutterLine = function(highlightGutterLine) {\n        this.$highlightGutterLine = highlightGutterLine;\n    };\n    \n    this.$showLineNumbers = true;\n    this.$renderer = \"\";\n    this.setShowLineNumbers = function(show) {\n        this.$renderer = !show && {\n            getWidth: function() {return 0;},\n            getText: function() {return \"\";}\n        };\n    };\n    \n    this.getShowLineNumbers = function() {\n        return this.$showLineNumbers;\n    };\n    \n    this.$showFoldWidgets = true;\n    this.setShowFoldWidgets = function(show) {\n        if (show)\n            dom.addCssClass(this.element, \"ace_folding-enabled\");\n        else\n            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n\n        this.$showFoldWidgets = show;\n        this.$padding = null;\n    };\n    \n    this.getShowFoldWidgets = function() {\n        return this.$showFoldWidgets;\n    };\n\n    this.$computePadding = function() {\n        if (!this.element.firstChild)\n            return {left: 0, right: 0};\n        var style = dom.computedStyle(this.element.firstChild);\n        this.$padding = {};\n        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)\n            + (parseInt(style.paddingLeft) || 0) + 1;\n        this.$padding.right = (parseInt(style.borderRightWidth) || 0)\n            + (parseInt(style.paddingRight) || 0);\n        return this.$padding;\n    };\n\n    this.getRegion = function(point) {\n        var padding = this.$padding || this.$computePadding();\n        var rect = this.element.getBoundingClientRect();\n        if (point.x < padding.left + rect.left)\n            return \"markers\";\n        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n            return \"foldWidgets\";\n    };\n\n}).call(Gutter.prototype);\n\nfunction onCreateCell(element) {\n    var textNode = document.createTextNode('');\n    element.appendChild(textNode);\n    \n    var foldWidget = dom.createElement(\"span\");\n    element.appendChild(foldWidget);\n    \n    return element;\n}\n\nexports.Gutter = Gutter;\n\n});\n\nace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar dom = require(\"../lib/dom\");\n\nvar Marker = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_marker-layer\";\n    parentEl.appendChild(this.element);\n};\n\n(function() {\n\n    this.$padding = 0;\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n    this.setSession = function(session) {\n        this.session = session;\n    };\n    \n    this.setMarkers = function(markers) {\n        this.markers = markers;\n    };\n    \n    this.elt = function(className, css) {\n        var x = this.i != -1 && this.element.childNodes[this.i];\n        if (!x) {\n            x = document.createElement(\"div\");\n            this.element.appendChild(x);\n            this.i = -1;\n        } else {\n            this.i++;\n        }\n        x.style.cssText = css;\n        x.className = className;\n    };\n\n    this.update = function(config) {\n        if (!config) return;\n\n        this.config = config;\n\n        this.i = 0;\n        var html;\n        for (var key in this.markers) {\n            var marker = this.markers[key];\n\n            if (!marker.range) {\n                marker.update(html, this, this.session, config);\n                continue;\n            }\n\n            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n            if (range.isEmpty()) continue;\n\n            range = range.toScreenRange(this.session);\n            if (marker.renderer) {\n                var top = this.$getTop(range.start.row, config);\n                var left = this.$padding + range.start.column * config.characterWidth;\n                marker.renderer(html, range, left, top, config);\n            } else if (marker.type == \"fullLine\") {\n                this.drawFullLineMarker(html, range, marker.clazz, config);\n            } else if (marker.type == \"screenLine\") {\n                this.drawScreenLineMarker(html, range, marker.clazz, config);\n            } else if (range.isMultiLine()) {\n                if (marker.type == \"text\")\n                    this.drawTextMarker(html, range, marker.clazz, config);\n                else\n                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n            } else {\n                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\" + \" ace_br15\", config);\n            }\n        }\n        if (this.i !=-1) {\n            while (this.i < this.element.childElementCount)\n                this.element.removeChild(this.element.lastChild);\n        }\n    };\n\n    this.$getTop = function(row, layerConfig) {\n        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n    };\n\n    function getBorderClass(tl, tr, br, bl) {\n        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);\n    }\n    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {\n        var session = this.session;\n        var start = range.start.row;\n        var end = range.end.row;\n        var row = start;\n        var prev = 0; \n        var curr = 0;\n        var next = session.getScreenLastRowColumn(row);\n        var lineRange = new Range(row, range.start.column, row, curr);\n        for (; row <= end; row++) {\n            lineRange.start.row = lineRange.end.row = row;\n            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);\n            lineRange.end.column = next;\n            prev = curr;\n            curr = next;\n            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;\n            this.drawSingleLineMarker(stringBuilder, lineRange, \n                clazz + (row == start  ? \" ace_start\" : \"\") + \" ace_br\"\n                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),\n                layerConfig, row == end ? 0 : 1, extraStyle);\n        }\n    };\n    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var padding = this.$padding;\n        var height = config.lineHeight;\n        var top = this.$getTop(range.start.row, config);\n        var left = padding + range.start.column * config.characterWidth;\n        extraStyle = extraStyle || \"\";\n\n        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {\n           var range1 = range.clone();\n           range1.end.row = range1.start.row;\n           range1.end.column = this.session.getLine(range1.start.row).length;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br1 ace_start\", config, null, extraStyle);\n        } else {\n            this.elt(\n                clazz + \" ace_br1 ace_start\",\n                \"height:\"+ height+ \"px;\"+ \"right:0;\"+ \"top:\"+top+ \"px;left:\"+ left+ \"px;\" + (extraStyle || \"\")\n            );\n        }\n        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {\n           var range1 = range.clone();\n           range1.start.row = range1.end.row;\n           range1.start.column = 0;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br12\", config, null, extraStyle);\n        } else {\n            top = this.$getTop(range.end.row, config);\n            var width = range.end.column * config.characterWidth;\n\n            this.elt(\n                clazz + \" ace_br12\",\n                \"height:\"+ height+ \"px;\"+\n                \"width:\"+ width+ \"px;\"+\n                \"top:\"+ top+ \"px;\"+\n                \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n            );\n        }\n        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n        if (height <= 0)\n            return;\n        top = this.$getTop(range.start.row + 1, config);\n        \n        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);\n\n        this.elt(\n            clazz + (radiusClass ? \" ace_br\" + radiusClass : \"\"),\n            \"height:\"+ height+ \"px;\"+\n            \"right:0;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        if (this.session.$bidiHandler.isBidiRow(range.start.row))\n            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);\n        var height = config.lineHeight;\n        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n\n        var top = this.$getTop(range.start.row, config);\n        var left = this.$padding + range.start.column * config.characterWidth;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"width:\"+ width+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ left+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;\n        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);\n\n        selections.forEach(function(selection) {\n            this.elt(\n                clazz,\n                \"height:\" + height + \"px;\" +\n                \"width:\" + selection.width + (extraLength || 0) + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + (padding + selection.left) + \"px;\" + (extraStyle || \"\")\n            );\n        }, this);\n    };\n\n    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        if (range.start.row != range.end.row)\n            height += this.$getTop(range.end.row, config) - top;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n    \n    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n\n}).call(Marker.prototype);\n\nexports.Marker = Marker;\n\n});\n\nace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/layer/lines\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar Lines = require(\"./lines\").Lines;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar Text = function(parentEl) {\n    this.dom = dom; \n    this.element = this.dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_text-layer\";\n    parentEl.appendChild(this.element);\n    this.$updateEolChar = this.$updateEolChar.bind(this);\n    this.$lines = new Lines(this.element);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.EOF_CHAR = \"\\xB6\";\n    this.EOL_CHAR_LF = \"\\xAC\";\n    this.EOL_CHAR_CRLF = \"\\xa4\";\n    this.EOL_CHAR = this.EOL_CHAR_LF;\n    this.TAB_CHAR = \"\\u2014\"; //\"\\u21E5\";\n    this.SPACE_CHAR = \"\\xB7\";\n    this.$padding = 0;\n    this.MAX_LINE_LENGTH = 10000;\n\n    this.$updateEolChar = function() {\n        var doc = this.session.doc;\n        var unixMode = doc.getNewLineCharacter() == \"\\n\" && doc.getNewLineMode() != \"windows\";\n        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;\n        if (this.EOL_CHAR != EOL_CHAR) {\n            this.EOL_CHAR = EOL_CHAR;\n            return true;\n        }\n    };\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.element.style.margin = \"0 \" + padding + \"px\";\n    };\n\n    this.getLineHeight = function() {\n        return this.$fontMetrics.$characterSize.height || 0;\n    };\n\n    this.getCharacterWidth = function() {\n        return this.$fontMetrics.$characterSize.width || 0;\n    };\n    \n    this.$setFontMetrics = function(measure) {\n        this.$fontMetrics = measure;\n        this.$fontMetrics.on(\"changeCharacterSize\", function(e) {\n            this._signal(\"changeCharacterSize\", e);\n        }.bind(this));\n        this.$pollSizeChanges();\n    };\n\n    this.checkForSizeChanges = function() {\n        this.$fontMetrics.checkForSizeChanges();\n    };\n    this.$pollSizeChanges = function() {\n        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n    };\n    this.setSession = function(session) {\n        this.session = session;\n        if (session)\n            this.$computeTabString();\n    };\n\n    this.showInvisibles = false;\n    this.setShowInvisibles = function(showInvisibles) {\n        if (this.showInvisibles == showInvisibles)\n            return false;\n\n        this.showInvisibles = showInvisibles;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.displayIndentGuides = true;\n    this.setDisplayIndentGuides = function(display) {\n        if (this.displayIndentGuides == display)\n            return false;\n\n        this.displayIndentGuides = display;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.$tabStrings = [];\n    this.onChangeTabSize =\n    this.$computeTabString = function() {\n        var tabSize = this.session.getTabSize();\n        this.tabSize = tabSize;\n        var tabStr = this.$tabStrings = [0];\n        for (var i = 1; i < tabSize + 1; i++) {\n            if (this.showInvisibles) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_tab\";\n                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);\n                tabStr.push(span);\n            } else {\n                tabStr.push(this.dom.createTextNode(lang.stringRepeat(\" \", i), this.element));\n            }\n        }\n        if (this.displayIndentGuides) {\n            this.$indentGuideRe =  /\\s\\S| \\t|\\t |\\s$/;\n            var className = \"ace_indent-guide\";\n            var spaceClass = \"\";\n            var tabClass = \"\";\n            if (this.showInvisibles) {\n                className += \" ace_invisible\";\n                spaceClass = \" ace_invisible_space\";\n                tabClass = \" ace_invisible_tab\";\n                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);\n                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);\n            } else {\n                var spaceContent = lang.stringRepeat(\" \", this.tabSize);\n                var tabContent = spaceContent;\n            }\n\n            var span = this.dom.createElement(\"span\");\n            span.className = className + spaceClass;\n            span.textContent = spaceContent;\n            this.$tabStrings[\" \"] = span;\n            \n            var span = this.dom.createElement(\"span\");\n            span.className = className + tabClass;\n            span.textContent = tabContent;\n            this.$tabStrings[\"\\t\"] = span;\n        }\n    };\n\n    this.updateLines = function(config, firstRow, lastRow) {\n        if (this.config.lastRow != config.lastRow ||\n            this.config.firstRow != config.firstRow) {\n            return this.update(config);\n        }\n        \n        this.config = config;\n\n        var first = Math.max(firstRow, config.firstRow);\n        var last = Math.min(lastRow, config.lastRow);\n\n        var lineElements = this.element.childNodes;\n        var lineElementsIdx = 0;\n\n        for (var row = config.firstRow; row < first; row++) {\n            var foldLine = this.session.getFoldLine(row);\n            if (foldLine) {\n                if (foldLine.containsRow(first)) {\n                    first = foldLine.start.row;\n                    break;\n                } else {\n                    row = foldLine.end.row;\n                }\n            }\n            lineElementsIdx ++;\n        }\n\n        var heightChanged = false;\n        var row = first;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row :Infinity;\n            }\n            if (row > last)\n                break;\n\n            var lineElement = lineElements[lineElementsIdx++];\n            if (lineElement) {\n                this.dom.removeChildren(lineElement);\n                this.$renderLine(\n                    lineElement, row, row == foldStart ? foldLine : false\n                );\n                var height = (config.lineHeight * this.session.getRowLength(row)) + \"px\";\n                if (lineElement.style.height != height) {\n                    heightChanged = true;\n                    lineElement.style.height = height;\n                }\n            }\n            row++;\n        }\n        if (heightChanged) {\n            while (lineElementsIdx < this.$lines.cells.length) {\n                var cell = this.$lines.cells[lineElementsIdx++];\n                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + \"px\";\n            }\n        }\n    };\n\n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n            \n        this.$lines.moveContainer(config);\n        \n        var lastRow = config.lastRow;\n        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;\n\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n            return this.update(config);\n\n        if (config.lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldConfig.lastRow > config.lastRow)\n            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (config.lastRow > oldConfig.lastRow) {\n            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));\n        }\n    };\n\n    this.$renderLinesFragment = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var line = this.$lines.createCell(row, config, this.session);\n            \n            var lineEl = line.element;\n            this.dom.removeChildren(lineEl);\n            dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\");\n            dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\");\n            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);\n\n            if (this.$useLineGroups()) {\n                lineEl.className = \"ace_line_group\";\n            } else {\n                lineEl.className = \"ace_line\";\n            }\n            fragment.push(line);\n\n            row++;\n        }\n        return fragment;\n    };\n\n    this.update = function(config) {\n        this.$lines.moveContainer(config);\n        \n        this.config = config;\n\n        var firstRow = config.firstRow;\n        var lastRow = config.lastRow;\n\n        var lines = this.$lines;\n        while (lines.getLength())\n            lines.pop();\n            \n        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));\n    };\n\n    this.$textToken = {\n        \"text\": true,\n        \"rparen\": true,\n        \"lparen\": true\n    };\n\n    this.$renderToken = function(parent, screenColumn, token, value) {\n        var self = this;\n        var re = /(\\t)|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\uFEFF\\uFFF9-\\uFFFC]+)|(\\u3000)|([\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3001-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n        \n        var valueFragment = this.dom.createFragment(this.element);\n\n        var m;\n        var i = 0;\n        while (m = re.exec(value)) {\n            var tab = m[1];\n            var simpleSpace = m[2];\n            var controlCharacter = m[3];\n            var cjkSpace = m[4];\n            var cjk = m[5];\n            \n            if (!self.showInvisibles && simpleSpace)\n                continue;\n\n            var before = i != m.index ? value.slice(i, m.index) : \"\";\n\n            i = m.index + m[0].length;\n            \n            if (before) {\n                valueFragment.appendChild(this.dom.createTextNode(before, this.element));\n            }\n                \n            if (tab) {\n                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);\n                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));\n                screenColumn += tabSize - 1;\n            } else if (simpleSpace) {\n                if (self.showInvisibles) {\n                    var span = this.dom.createElement(\"span\");\n                    span.className = \"ace_invisible ace_invisible_space\";\n                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);\n                    valueFragment.appendChild(span);\n                } else {\n                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));\n                }\n            } else if (controlCharacter) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_space ace_invalid\";\n                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);\n                valueFragment.appendChild(span);\n            } else if (cjkSpace) {\n                var space = self.showInvisibles ? self.SPACE_CHAR : \"\";\n                screenColumn += 1;\n                \n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = self.showInvisibles ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n                span.textContent = self.showInvisibles ? self.SPACE_CHAR : \"\";\n                valueFragment.appendChild(span);\n            } else if (cjk) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = \"ace_cjk\";\n                span.textContent = cjk;\n                valueFragment.appendChild(span);\n            }\n        }\n        \n        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));\n\n        if (!this.$textToken[token.type]) {\n            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n            var span = this.dom.createElement(\"span\");\n            if (token.type == \"fold\")\n                span.style.width = (token.value.length * this.config.characterWidth) + \"px\";\n                \n            span.className = classes;\n            span.appendChild(valueFragment);\n            \n            parent.appendChild(span);\n        }\n        else {\n            parent.appendChild(valueFragment);\n        }\n        \n        return screenColumn + value.length;\n    };\n\n    this.renderIndentGuide = function(parent, value, max) {\n        var cols = value.search(this.$indentGuideRe);\n        if (cols <= 0 || cols >= max)\n            return value;\n        if (value[0] == \" \") {\n            cols -= cols % this.tabSize;\n            var count = cols/this.tabSize;\n            for (var i=0; i<count; i++) {\n                parent.appendChild(this.$tabStrings[\" \"].cloneNode(true));\n            }\n            return value.substr(cols);\n        } else if (value[0] == \"\\t\") {\n            for (var i=0; i<cols; i++) {\n                parent.appendChild(this.$tabStrings[\"\\t\"].cloneNode(true));\n            }\n            return value.substr(cols);\n        }\n        return value;\n    };\n\n    this.$createLineElement = function(parent) {\n        var lineEl = this.dom.createElement(\"div\");\n        lineEl.className = \"ace_line\";\n        lineEl.style.height = this.config.lineHeight + \"px\";\n        \n        return lineEl;\n    };\n\n    this.$renderWrappedLine = function(parent, tokens, splits) {\n        var chars = 0;\n        var split = 0;\n        var splitChars = splits[0];\n        var screenColumn = 0;\n\n        var lineEl = this.$createLineElement();\n        parent.appendChild(lineEl);\n        \n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                chars = value.length;\n                value = this.renderIndentGuide(lineEl, value, splitChars);\n                if (!value)\n                    continue;\n                chars -= value.length;\n            }\n\n            if (chars + value.length < splitChars) {\n                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                chars += value.length;\n            } else {\n                while (chars + value.length >= splitChars) {\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn,\n                        token, value.substring(0, splitChars - chars)\n                    );\n                    value = value.substring(splitChars - chars);\n                    chars = splitChars;\n\n                    lineEl = this.$createLineElement();\n                    parent.appendChild(lineEl);\n\n                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(\"\\xa0\", splits.indent), this.element));\n\n                    split ++;\n                    screenColumn = 0;\n                    splitChars = splits[split] || Number.MAX_VALUE;\n                }\n                if (value.length != 0) {\n                    chars += value.length;\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn, token, value\n                    );\n                }\n            }\n        }\n    };\n\n    this.$renderSimpleLine = function(parent, tokens) {\n        var screenColumn = 0;\n        var token = tokens[0];\n        var value = token.value;\n        if (this.displayIndentGuides)\n            value = this.renderIndentGuide(parent, value);\n        if (value)\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        for (var i = 1; i < tokens.length; i++) {\n            token = tokens[i];\n            value = token.value;\n            if (screenColumn + value.length > this.MAX_LINE_LENGTH)\n                return this.$renderOverflowMessage(parent, screenColumn, token, value);\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        }\n    };\n    \n    this.$renderOverflowMessage = function(parent, screenColumn, token, value) {\n        this.$renderToken(parent, screenColumn, token,\n            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));\n            \n        var overflowEl = this.dom.createElement(\"span\");\n        overflowEl.className = \"ace_inline_button ace_keyword ace_toggle_wrap\";\n        overflowEl.style.position = \"absolute\";\n        overflowEl.style.right = \"0\";\n        overflowEl.textContent = \"<click to see more...>\";\n        \n        parent.appendChild(overflowEl);        \n    };\n    this.$renderLine = function(parent, row, foldLine) {\n        if (!foldLine && foldLine != false)\n            foldLine = this.session.getFoldLine(row);\n\n        if (foldLine)\n            var tokens = this.$getFoldLineTokens(row, foldLine);\n        else\n            var tokens = this.session.getTokens(row);\n\n        var lastLineEl = parent;\n        if (tokens.length) {\n            var splits = this.session.getRowSplitData(row);\n            if (splits && splits.length) {\n                this.$renderWrappedLine(parent, tokens, splits);\n                var lastLineEl = parent.lastChild;\n            } else {\n                var lastLineEl = parent;\n                if (this.$useLineGroups()) {\n                    lastLineEl = this.$createLineElement();\n                    parent.appendChild(lastLineEl);\n                }\n                this.$renderSimpleLine(lastLineEl, tokens);\n            }\n        } else if (this.$useLineGroups()) {\n            lastLineEl = this.$createLineElement();\n            parent.appendChild(lastLineEl);\n        }\n\n        if (this.showInvisibles && lastLineEl) {\n            if (foldLine)\n                row = foldLine.end.row;\n\n            var invisibleEl = this.dom.createElement(\"span\");\n            invisibleEl.className = \"ace_invisible ace_invisible_eol\";\n            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;\n            \n            lastLineEl.appendChild(invisibleEl);\n        }\n    };\n\n    this.$getFoldLineTokens = function(row, foldLine) {\n        var session = this.session;\n        var renderTokens = [];\n\n        function addTokens(tokens, from, to) {\n            var idx = 0, col = 0;\n            while ((col + tokens[idx].value.length) < from) {\n                col += tokens[idx].value.length;\n                idx++;\n\n                if (idx == tokens.length)\n                    return;\n            }\n            if (col != from) {\n                var value = tokens[idx].value.substring(from - col);\n                if (value.length > (to - from))\n                    value = value.substring(0, to - from);\n\n                renderTokens.push({\n                    type: tokens[idx].type,\n                    value: value\n                });\n\n                col = from + value.length;\n                idx += 1;\n            }\n\n            while (col < to && idx < tokens.length) {\n                var value = tokens[idx].value;\n                if (value.length + col > to) {\n                    renderTokens.push({\n                        type: tokens[idx].type,\n                        value: value.substring(0, to - col)\n                    });\n                } else\n                    renderTokens.push(tokens[idx]);\n                col += value.length;\n                idx += 1;\n            }\n        }\n\n        var tokens = session.getTokens(row);\n        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {\n            if (placeholder != null) {\n                renderTokens.push({\n                    type: \"fold\",\n                    value: placeholder\n                });\n            } else {\n                if (isNewRow)\n                    tokens = session.getTokens(row);\n\n                if (tokens.length)\n                    addTokens(tokens, lastColumn, column);\n            }\n        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n\n        return renderTokens;\n    };\n\n    this.$useLineGroups = function() {\n        return this.session.getUseWrapMode();\n    };\n\n    this.destroy = function() {};\n}).call(Text.prototype);\n\nexports.Text = Text;\n\n});\n\nace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Cursor = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_cursor-layer\";\n    parentEl.appendChild(this.element);\n    \n    this.isVisible = false;\n    this.isBlinking = true;\n    this.blinkInterval = 1000;\n    this.smoothBlinking = false;\n\n    this.cursors = [];\n    this.cursor = this.addCursor();\n    dom.addCssClass(this.element, \"ace_hidden-cursors\");\n    this.$updateCursors = this.$updateOpacity.bind(this);\n};\n\n(function() {\n    \n    this.$updateOpacity = function(val) {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            dom.setStyle(cursors[i].style, \"opacity\", val ? \"\" : \"0\");\n    };\n\n    this.$startCssAnimation = function() {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            cursors[i].style.animationDuration = this.blinkInterval + \"ms\";\n\n        setTimeout(function() {\n            dom.addCssClass(this.element, \"ace_animate-blinking\");\n        }.bind(this));\n    };\n    \n    this.$stopCssAnimation = function() {\n        dom.removeCssClass(this.element, \"ace_animate-blinking\");\n    };\n\n    this.$padding = 0;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n\n    this.setSession = function(session) {\n        this.session = session;\n    };\n\n    this.setBlinking = function(blinking) {\n        if (blinking != this.isBlinking) {\n            this.isBlinking = blinking;\n            this.restartTimer();\n        }\n    };\n\n    this.setBlinkInterval = function(blinkInterval) {\n        if (blinkInterval != this.blinkInterval) {\n            this.blinkInterval = blinkInterval;\n            this.restartTimer();\n        }\n    };\n\n    this.setSmoothBlinking = function(smoothBlinking) {\n        if (smoothBlinking != this.smoothBlinking) {\n            this.smoothBlinking = smoothBlinking;\n            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n            this.$updateCursors(true);\n            this.restartTimer();\n        }\n    };\n\n    this.addCursor = function() {\n        var el = dom.createElement(\"div\");\n        el.className = \"ace_cursor\";\n        this.element.appendChild(el);\n        this.cursors.push(el);\n        return el;\n    };\n\n    this.removeCursor = function() {\n        if (this.cursors.length > 1) {\n            var el = this.cursors.pop();\n            el.parentNode.removeChild(el);\n            return el;\n        }\n    };\n\n    this.hideCursor = function() {\n        this.isVisible = false;\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.showCursor = function() {\n        this.isVisible = true;\n        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.restartTimer = function() {\n        var update = this.$updateCursors;\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n        this.$stopCssAnimation();\n\n        if (this.smoothBlinking) {\n            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n        }\n        \n        update(true);\n\n        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {\n            this.$stopCssAnimation();\n            return;\n        }\n\n        if (this.smoothBlinking) {\n            setTimeout(function(){\n                dom.addCssClass(this.element, \"ace_smooth-blinking\");\n            }.bind(this));\n        }\n        \n        if (dom.HAS_CSS_ANIMATION) {\n            this.$startCssAnimation();\n        } else {\n            var blink = function(){\n                this.timeoutId = setTimeout(function() {\n                    update(false);\n                }, 0.6 * this.blinkInterval);\n            }.bind(this);\n    \n            this.intervalId = setInterval(function() {\n                update(true);\n                blink();\n            }, this.blinkInterval);\n            blink();\n        }\n    };\n\n    this.getPixelPosition = function(position, onScreen) {\n        if (!this.config || !this.session)\n            return {left : 0, top : 0};\n\n        if (!position)\n            position = this.session.selection.getCursor();\n        var pos = this.session.documentToScreenPosition(position);\n        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : pos.column * this.config.characterWidth);\n\n        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n            this.config.lineHeight;\n\n        return {left : cursorLeft, top : cursorTop};\n    };\n\n    this.isCursorInView = function(pixelPos, config) {\n        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;\n    };\n\n    this.update = function(config) {\n        this.config = config;\n\n        var selections = this.session.$selectionMarkers;\n        var i = 0, cursorIndex = 0;\n\n        if (selections === undefined || selections.length === 0){\n            selections = [{cursor: null}];\n        }\n\n        for (var i = 0, n = selections.length; i < n; i++) {\n            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n            if ((pixelPos.top > config.height + config.offset ||\n                 pixelPos.top < 0) && i > 1) {\n                continue;\n            }\n\n            var element = this.cursors[cursorIndex++] || this.addCursor();\n            var style = element.style;\n            \n            if (!this.drawCursor) {\n                if (!this.isCursorInView(pixelPos, config)) {\n                    dom.setStyle(style, \"display\", \"none\");\n                } else {\n                    dom.setStyle(style, \"display\", \"block\");\n                    dom.translate(element, pixelPos.left, pixelPos.top);\n                    dom.setStyle(style, \"width\", Math.round(config.characterWidth) + \"px\");\n                    dom.setStyle(style, \"height\", config.lineHeight + \"px\");\n                }\n            } else {\n                this.drawCursor(element, pixelPos, config, selections[i], this.session);\n            }\n        }\n        while (this.cursors.length > cursorIndex)\n            this.removeCursor();\n\n        var overwrite = this.session.getOverwrite();\n        this.$setOverwrite(overwrite);\n        this.$pixelPos = pixelPos;\n        this.restartTimer();\n    };\n    \n    this.drawCursor = null;\n\n    this.$setOverwrite = function(overwrite) {\n        if (overwrite != this.overwrite) {\n            this.overwrite = overwrite;\n            if (overwrite)\n                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n            else\n                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n        }\n    };\n\n    this.destroy = function() {\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n    };\n\n}).call(Cursor.prototype);\n\nexports.Cursor = Cursor;\n\n});\n\nace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar MAX_SCROLL_H = 0x8000;\nvar ScrollBar = function(parent) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_scrollbar ace_scrollbar\" + this.classSuffix;\n\n    this.inner = dom.createElement(\"div\");\n    this.inner.className = \"ace_scrollbar-inner\";\n    this.element.appendChild(this.inner);\n\n    parent.appendChild(this.element);\n\n    this.setVisible(false);\n    this.skipEvent = false;\n\n    event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n    event.addListener(this.element, \"mousedown\", event.preventDefault);\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n\n    this.setVisible = function(isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n}).call(ScrollBar.prototype);\nvar VScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollTop = 0;\n    this.scrollHeight = 0;\n    renderer.$scrollbarWidth = \n    this.width = dom.scrollbarWidth(parent.ownerDocument);\n    this.inner.style.width =\n    this.element.style.width = (this.width || 15) + 5 + \"px\";\n    this.$minWidth = 0;\n};\n\noop.inherits(VScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-v';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollTop = this.element.scrollTop;\n            if (this.coeff != 1) {\n                var h = this.element.clientHeight / this.scrollHeight;\n                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);\n            }\n            this._emit(\"scroll\", {data: this.scrollTop});\n        }\n        this.skipEvent = false;\n    };\n    this.getWidth = function() {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    this.setHeight = function(height) {\n        this.element.style.height = height + \"px\";\n    };\n    this.setInnerHeight = \n    this.setScrollHeight = function(height) {\n        this.scrollHeight = height;\n        if (height > MAX_SCROLL_H) {\n            this.coeff = MAX_SCROLL_H / height;\n            height = MAX_SCROLL_H;\n        } else if (this.coeff != 1) {\n            this.coeff = 1;\n        }\n        this.inner.style.height = height + \"px\";\n    };\n    this.setScrollTop = function(scrollTop) {\n        if (this.scrollTop != scrollTop) {\n            this.skipEvent = true;\n            this.scrollTop = scrollTop;\n            this.element.scrollTop = scrollTop * this.coeff;\n        }\n    };\n\n}).call(VScrollBar.prototype);\nvar HScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollLeft = 0;\n    this.height = renderer.$scrollbarWidth;\n    this.inner.style.height =\n    this.element.style.height = (this.height || 15) + 5 + \"px\";\n};\n\noop.inherits(HScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-h';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollLeft = this.element.scrollLeft;\n            this._emit(\"scroll\", {data: this.scrollLeft});\n        }\n        this.skipEvent = false;\n    };\n    this.getHeight = function() {\n        return this.isVisible ? this.height : 0;\n    };\n    this.setWidth = function(width) {\n        this.element.style.width = width + \"px\";\n    };\n    this.setInnerWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.scrollLeft != scrollLeft) {\n            this.skipEvent = true;\n            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n        }\n    };\n\n}).call(HScrollBar.prototype);\n\n\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\n\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n});\n\nace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"./lib/event\");\n\n\nvar RenderLoop = function(onRender, win) {\n    this.onRender = onRender;\n    this.pending = false;\n    this.changes = 0;\n    this.$recursionLimit = 2;\n    this.window = win || window;\n    var _self = this;\n    this._flush = function(ts) {\n        _self.pending = false;\n        var changes = _self.changes;\n\n        if (changes) {\n            event.blockIdle(100);\n            _self.changes = 0;\n            _self.onRender(changes);\n        }\n        \n        if (_self.changes) {\n            if (_self.$recursionLimit-- < 0) return;\n            _self.schedule();\n        } else {\n            _self.$recursionLimit = 2;\n        }\n    };\n};\n\n(function() {\n\n    this.schedule = function(change) {\n        this.changes = this.changes | change;\n        if (this.changes && !this.pending) {\n            event.nextFrame(this._flush);\n            this.pending = true;\n        }\n    };\n\n    this.clear = function(change) {\n        var changes = this.changes;\n        this.changes = 0;\n        return changes;\n    };\n\n}).call(RenderLoop.prototype);\n\nexports.RenderLoop = RenderLoop;\n});\n\nace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CHAR_COUNT = 256;\nvar USE_OBSERVER = typeof ResizeObserver == \"function\";\nvar L = 200;\n\nvar FontMetrics = exports.FontMetrics = function(parentEl) {\n    this.el = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.el.style, true);\n    \n    this.$main = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$main.style);\n    \n    this.$measureNode = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$measureNode.style);\n    \n    \n    this.el.appendChild(this.$main);\n    this.el.appendChild(this.$measureNode);\n    parentEl.appendChild(this.el);\n    \n    this.$measureNode.innerHTML = lang.stringRepeat(\"X\", CHAR_COUNT);\n    \n    this.$characterSize = {width: 0, height: 0};\n    \n    \n    if (USE_OBSERVER)\n        this.$addObserver();\n    else\n        this.checkForSizeChanges();\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n        \n    this.$characterSize = {width: 0, height: 0};\n    \n    this.$setMeasureNodeStyles = function(style, isRoot) {\n        style.width = style.height = \"auto\";\n        style.left = style.top = \"0px\";\n        style.visibility = \"hidden\";\n        style.position = \"absolute\";\n        style.whiteSpace = \"pre\";\n\n        if (useragent.isIE < 8) {\n            style[\"font-family\"] = \"inherit\";\n        } else {\n            style.font = \"inherit\";\n        }\n        style.overflow = isRoot ? \"hidden\" : \"visible\";\n    };\n\n    this.checkForSizeChanges = function(size) {\n        if (size === undefined)\n            size = this.$measureSizes();\n        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n            this.$measureNode.style.fontWeight = \"bold\";\n            var boldSize = this.$measureSizes();\n            this.$measureNode.style.fontWeight = \"\";\n            this.$characterSize = size;\n            this.charSizes = Object.create(null);\n            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n            this._emit(\"changeCharacterSize\", {data: size});\n        }\n    };\n    \n    this.$addObserver = function() {\n        var self = this;\n        this.$observer = new window.ResizeObserver(function(e) {\n            var rect = e[0].contentRect;\n            self.checkForSizeChanges({\n                height: rect.height,\n                width: rect.width / CHAR_COUNT\n            });\n        });\n        this.$observer.observe(this.$measureNode);\n    };\n\n    this.$pollSizeChanges = function() {\n        if (this.$pollSizeChangesTimer || this.$observer)\n            return this.$pollSizeChangesTimer;\n        var self = this;\n        \n        return this.$pollSizeChangesTimer = event.onIdle(function cb() {\n            self.checkForSizeChanges();\n            event.onIdle(cb, 500);\n        }, 500);\n    };\n    \n    this.setPolling = function(val) {\n        if (val) {\n            this.$pollSizeChanges();\n        } else if (this.$pollSizeChangesTimer) {\n            clearInterval(this.$pollSizeChangesTimer);\n            this.$pollSizeChangesTimer = 0;\n        }\n    };\n\n    this.$measureSizes = function(node) {\n        var size = {\n            height: (node || this.$measureNode).clientHeight,\n            width: (node || this.$measureNode).clientWidth / CHAR_COUNT\n        };\n        if (size.width === 0 || size.height === 0)\n            return null;\n        return size;\n    };\n\n    this.$measureCharWidth = function(ch) {\n        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);\n        var rect = this.$main.getBoundingClientRect();\n        return rect.width / CHAR_COUNT;\n    };\n    \n    this.getCharacterWidth = function(ch) {\n        var w = this.charSizes[ch];\n        if (w === undefined) {\n            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n        }\n        return w;\n    };\n\n    this.destroy = function() {\n        clearInterval(this.$pollSizeChangesTimer);\n        if (this.$observer)\n            this.$observer.disconnect();\n        if (this.el && this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    };\n\n    \n    this.$getZoom = function getZoom(element) {\n        if (!element) return 1;\n        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);\n    };\n    this.$initTransformMeasureNodes = function() {\n        var t = function(t, l) {\n            return [\"div\", {\n                style: \"position: absolute;top:\" + t + \"px;left:\" + l + \"px;\"\n            }];\n        };\n        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);\n    };\n    this.transformCoordinates = function(clientPos, elPos) {\n        if (clientPos) {\n            var zoom = this.$getZoom(this.el);\n            clientPos = mul(1 / zoom, clientPos);\n        }\n        function solve(l1, l2, r) {\n            var det = l1[1] * l2[0] - l1[0] * l2[1];\n            return [\n                (-l2[1] * r[0] + l2[0] * r[1]) / det,\n                (+l1[1] * r[0] - l1[0] * r[1]) / det\n            ];\n        }\n        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }\n        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }\n        function mul(a, b) { return [a * b[0], a * b[1]]; }\n\n        if (!this.els)\n            this.$initTransformMeasureNodes();\n        \n        function p(el) {\n            var r = el.getBoundingClientRect();\n            return [r.left, r.top];\n        }\n\n        var a = p(this.els[0]);\n        var b = p(this.els[1]);\n        var c = p(this.els[2]);\n        var d = p(this.els[3]);\n\n        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));\n\n        var m1 = mul(1 + h[0], sub(b, a));\n        var m2 = mul(1 + h[1], sub(c, a));\n        \n        if (elPos) {\n            var x = elPos;\n            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;\n            var ut = add(mul(x[0], m1), mul(x[1], m2));\n            return  add(mul(1 / k / L, ut), a);\n        }\n        var u = sub(clientPos, a);\n        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);\n        return mul(L, f);\n    };\n    \n}).call(FontMetrics.prototype);\n\n});\n\nace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/config\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar config = require(\"./config\");\nvar GutterLayer = require(\"./layer/gutter\").Gutter;\nvar MarkerLayer = require(\"./layer/marker\").Marker;\nvar TextLayer = require(\"./layer/text\").Text;\nvar CursorLayer = require(\"./layer/cursor\").Cursor;\nvar HScrollBar = require(\"./scrollbar\").HScrollBar;\nvar VScrollBar = require(\"./scrollbar\").VScrollBar;\nvar RenderLoop = require(\"./renderloop\").RenderLoop;\nvar FontMetrics = require(\"./layer/font_metrics\").FontMetrics;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar editorCss = \"\\\n.ace_br1 {border-top-left-radius    : 3px;}\\\n.ace_br2 {border-top-right-radius   : 3px;}\\\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\\\n.ace_br4 {border-bottom-right-radius: 3px;}\\\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\\\n.ace_br8 {border-bottom-left-radius : 3px;}\\\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\\\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\\\n.ace_editor {\\\nposition: relative;\\\noverflow: hidden;\\\nfont: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\\\ndirection: ltr;\\\ntext-align: left;\\\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\\n}\\\n.ace_scroller {\\\nposition: absolute;\\\noverflow: hidden;\\\ntop: 0;\\\nbottom: 0;\\\nbackground-color: inherit;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncursor: text;\\\n}\\\n.ace_content {\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nmin-width: 100%;\\\ncontain: style size layout;\\\n}\\\n.ace_dragging .ace_scroller:before{\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\nbottom: 0;\\\ncontent: '';\\\nbackground: rgba(250, 250, 250, 0.01);\\\nz-index: 1000;\\\n}\\\n.ace_dragging.ace_dark .ace_scroller:before{\\\nbackground: rgba(0, 0, 0, 0.01);\\\n}\\\n.ace_selecting, .ace_selecting * {\\\ncursor: text !important;\\\n}\\\n.ace_gutter {\\\nposition: absolute;\\\noverflow : hidden;\\\nwidth: auto;\\\ntop: 0;\\\nbottom: 0;\\\nleft: 0;\\\ncursor: default;\\\nz-index: 4;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncontain: style size layout;\\\n}\\\n.ace_gutter-active-line {\\\nposition: absolute;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_scroller.ace_scroll-left {\\\nbox-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\\n}\\\n.ace_gutter-cell {\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\npadding-left: 19px;\\\npadding-right: 6px;\\\nbackground-repeat: no-repeat;\\\n}\\\n.ace_gutter-cell.ace_error {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_warning {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_dark .ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_scrollbar {\\\ncontain: strict;\\\nposition: absolute;\\\nright: 0;\\\nbottom: 0;\\\nz-index: 6;\\\n}\\\n.ace_scrollbar-inner {\\\nposition: absolute;\\\ncursor: text;\\\nleft: 0;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-v{\\\noverflow-x: hidden;\\\noverflow-y: scroll;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-h {\\\noverflow-x: scroll;\\\noverflow-y: hidden;\\\nleft: 0;\\\n}\\\n.ace_print-margin {\\\nposition: absolute;\\\nheight: 100%;\\\n}\\\n.ace_text-input {\\\nposition: absolute;\\\nz-index: 0;\\\nwidth: 0.5em;\\\nheight: 1em;\\\nopacity: 0;\\\nbackground: transparent;\\\n-moz-appearance: none;\\\nappearance: none;\\\nborder: none;\\\nresize: none;\\\noutline: none;\\\noverflow: hidden;\\\nfont: inherit;\\\npadding: 0 1px;\\\nmargin: 0 -1px;\\\ncontain: strict;\\\n-ms-user-select: text;\\\n-moz-user-select: text;\\\n-webkit-user-select: text;\\\nuser-select: text;\\\nwhite-space: pre!important;\\\n}\\\n.ace_text-input.ace_composition {\\\nbackground: transparent;\\\ncolor: inherit;\\\nz-index: 1000;\\\nopacity: 1;\\\n}\\\n.ace_composition_placeholder { color: transparent }\\\n.ace_composition_marker { \\\nborder-bottom: 1px solid;\\\nposition: absolute;\\\nborder-radius: 0;\\\nmargin-top: 1px;\\\n}\\\n[ace_nocontext=true] {\\\ntransform: none!important;\\\nfilter: none!important;\\\nperspective: none!important;\\\nclip-path: none!important;\\\nmask : none!important;\\\ncontain: none!important;\\\nperspective: none!important;\\\nmix-blend-mode: initial!important;\\\nz-index: auto;\\\n}\\\n.ace_layer {\\\nz-index: 1;\\\nposition: absolute;\\\noverflow: hidden;\\\nword-wrap: normal;\\\nwhite-space: pre;\\\nheight: 100%;\\\nwidth: 100%;\\\nbox-sizing: border-box;\\\npointer-events: none;\\\n}\\\n.ace_gutter-layer {\\\nposition: relative;\\\nwidth: auto;\\\ntext-align: right;\\\npointer-events: auto;\\\nheight: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer {\\\nfont: inherit !important;\\\nposition: absolute;\\\nheight: 1000000px;\\\nwidth: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\\\ncontain: style size layout;\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_hidpi .ace_text-layer,\\\n.ace_hidpi .ace_gutter-layer,\\\n.ace_hidpi .ace_content,\\\n.ace_hidpi .ace_gutter {\\\ncontain: strict;\\\nwill-change: transform;\\\n}\\\n.ace_hidpi .ace_text-layer > .ace_line, \\\n.ace_hidpi .ace_text-layer > .ace_line_group {\\\ncontain: strict;\\\n}\\\n.ace_cjk {\\\ndisplay: inline-block;\\\ntext-align: center;\\\n}\\\n.ace_cursor-layer {\\\nz-index: 4;\\\n}\\\n.ace_cursor {\\\nz-index: 4;\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nborder-left: 2px solid;\\\ntransform: translatez(0);\\\n}\\\n.ace_multiselect .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_slim-cursors .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_overwrite-cursors .ace_cursor {\\\nborder-left-width: 0;\\\nborder-bottom: 1px solid;\\\n}\\\n.ace_hidden-cursors .ace_cursor {\\\nopacity: 0.2;\\\n}\\\n.ace_smooth-blinking .ace_cursor {\\\ntransition: opacity 0.18s;\\\n}\\\n.ace_animate-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: step-end;\\\nanimation-name: blink-ace-animate;\\\nanimation-iteration-count: infinite;\\\n}\\\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: ease-in-out;\\\nanimation-name: blink-ace-animate-smooth;\\\n}\\\n@keyframes blink-ace-animate {\\\nfrom, to { opacity: 1; }\\\n60% { opacity: 0; }\\\n}\\\n@keyframes blink-ace-animate-smooth {\\\nfrom, to { opacity: 1; }\\\n45% { opacity: 1; }\\\n60% { opacity: 0; }\\\n85% { opacity: 0; }\\\n}\\\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\\nposition: absolute;\\\nz-index: 3;\\\n}\\\n.ace_marker-layer .ace_selection {\\\nposition: absolute;\\\nz-index: 5;\\\n}\\\n.ace_marker-layer .ace_bracket {\\\nposition: absolute;\\\nz-index: 6;\\\n}\\\n.ace_marker-layer .ace_active-line {\\\nposition: absolute;\\\nz-index: 2;\\\n}\\\n.ace_marker-layer .ace_selected-word {\\\nposition: absolute;\\\nz-index: 4;\\\nbox-sizing: border-box;\\\n}\\\n.ace_line .ace_fold {\\\nbox-sizing: border-box;\\\ndisplay: inline-block;\\\nheight: 11px;\\\nmargin-top: -2px;\\\nvertical-align: middle;\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\\nbackground-repeat: no-repeat, repeat-x;\\\nbackground-position: center center, top left;\\\ncolor: transparent;\\\nborder: 1px solid black;\\\nborder-radius: 2px;\\\ncursor: pointer;\\\npointer-events: auto;\\\n}\\\n.ace_dark .ace_fold {\\\n}\\\n.ace_fold:hover{\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_tooltip {\\\nbackground-color: #FFF;\\\nbackground-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\\\nborder: 1px solid gray;\\\nborder-radius: 1px;\\\nbox-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\\ncolor: black;\\\nmax-width: 100%;\\\npadding: 3px 4px;\\\nposition: fixed;\\\nz-index: 999999;\\\nbox-sizing: border-box;\\\ncursor: default;\\\nwhite-space: pre;\\\nword-wrap: break-word;\\\nline-height: normal;\\\nfont-style: normal;\\\nfont-weight: normal;\\\nletter-spacing: normal;\\\npointer-events: none;\\\n}\\\n.ace_folding-enabled > .ace_gutter-cell {\\\npadding-right: 13px;\\\n}\\\n.ace_fold-widget {\\\nbox-sizing: border-box;\\\nmargin: 0 -12px 0 1px;\\\ndisplay: none;\\\nwidth: 11px;\\\nvertical-align: top;\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: center;\\\nborder-radius: 3px;\\\nborder: 1px solid transparent;\\\ncursor: pointer;\\\n}\\\n.ace_folding-enabled .ace_fold-widget {\\\ndisplay: inline-block;   \\\n}\\\n.ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\\n}\\\n.ace_fold-widget:hover {\\\nborder: 1px solid rgba(0, 0, 0, 0.3);\\\nbackground-color: rgba(255, 255, 255, 0.2);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\\n}\\\n.ace_fold-widget:active {\\\nborder: 1px solid rgba(0, 0, 0, 0.4);\\\nbackground-color: rgba(0, 0, 0, 0.05);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\\n}\\\n.ace_dark .ace_fold-widget {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget:hover {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\nbackground-color: rgba(255, 255, 255, 0.1);\\\n}\\\n.ace_dark .ace_fold-widget:active {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\n}\\\n.ace_inline_button {\\\nborder: 1px solid lightgray;\\\ndisplay: inline-block;\\\nmargin: -1px 8px;\\\npadding: 0 5px;\\\npointer-events: auto;\\\ncursor: pointer;\\\n}\\\n.ace_inline_button:hover {\\\nborder-color: gray;\\\nbackground: rgba(200,200,200,0.2);\\\ndisplay: inline-block;\\\npointer-events: auto;\\\n}\\\n.ace_fold-widget.ace_invalid {\\\nbackground-color: #FFB4B4;\\\nborder-color: #DE5555;\\\n}\\\n.ace_fade-fold-widgets .ace_fold-widget {\\\ntransition: opacity 0.4s ease 0.05s;\\\nopacity: 0;\\\n}\\\n.ace_fade-fold-widgets:hover .ace_fold-widget {\\\ntransition: opacity 0.05s ease 0.05s;\\\nopacity:1;\\\n}\\\n.ace_underline {\\\ntext-decoration: underline;\\\n}\\\n.ace_bold {\\\nfont-weight: bold;\\\n}\\\n.ace_nobold .ace_bold {\\\nfont-weight: normal;\\\n}\\\n.ace_italic {\\\nfont-style: italic;\\\n}\\\n.ace_error-marker {\\\nbackground-color: rgba(255, 0, 0,0.2);\\\nposition: absolute;\\\nz-index: 9;\\\n}\\\n.ace_highlight-marker {\\\nbackground-color: rgba(255, 255, 0,0.2);\\\nposition: absolute;\\\nz-index: 8;\\\n}\\\n\";\n\nvar useragent = require(\"./lib/useragent\");\nvar HIDE_TEXTAREA = useragent.isIE;\n\ndom.importCssString(editorCss, \"ace_editor.css\");\n\nvar VirtualRenderer = function(container, theme) {\n    var _self = this;\n\n    this.container = container || dom.createElement(\"div\");\n\n    dom.addCssClass(this.container, \"ace_editor\");\n    if (dom.HI_DPI) dom.addCssClass(this.container, \"ace_hidpi\");\n\n    this.setTheme(theme);\n\n    this.$gutter = dom.createElement(\"div\");\n    this.$gutter.className = \"ace_gutter\";\n    this.container.appendChild(this.$gutter);\n    this.$gutter.setAttribute(\"aria-hidden\", true);\n\n    this.scroller = dom.createElement(\"div\");\n    this.scroller.className = \"ace_scroller\";\n    \n    this.container.appendChild(this.scroller);\n\n    this.content = dom.createElement(\"div\");\n    this.content.className = \"ace_content\";\n    this.scroller.appendChild(this.content);\n\n    this.$gutterLayer = new GutterLayer(this.$gutter);\n    this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n\n    this.$markerBack = new MarkerLayer(this.content);\n\n    var textLayer = this.$textLayer = new TextLayer(this.content);\n    this.canvas = textLayer.element;\n\n    this.$markerFront = new MarkerLayer(this.content);\n\n    this.$cursorLayer = new CursorLayer(this.content);\n    this.$horizScroll = false;\n    this.$vScroll = false;\n\n    this.scrollBar = \n    this.scrollBarV = new VScrollBar(this.container, this);\n    this.scrollBarH = new HScrollBar(this.container, this);\n    this.scrollBarV.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n    });\n    this.scrollBarH.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n    });\n\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this.cursorPos = {\n        row : 0,\n        column : 0\n    };\n\n    this.$fontMetrics = new FontMetrics(this.container);\n    this.$textLayer.$setFontMetrics(this.$fontMetrics);\n    this.$textLayer.addEventListener(\"changeCharacterSize\", function(e) {\n        _self.updateCharacterSize();\n        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n        _self._signal(\"changeCharacterSize\", e);\n    });\n\n    this.$size = {\n        width: 0,\n        height: 0,\n        scrollerHeight: 0,\n        scrollerWidth: 0,\n        $dirty: true\n    };\n\n    this.layerConfig = {\n        width : 1,\n        padding : 0,\n        firstRow : 0,\n        firstRowScreen: 0,\n        lastRow : 0,\n        lineHeight : 0,\n        characterWidth : 0,\n        minHeight : 1,\n        maxHeight : 1,\n        offset : 0,\n        height : 1,\n        gutterOffset: 1\n    };\n    \n    this.scrollMargin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.margin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.$keepTextAreaAtCursor = !useragent.isIOS;\n\n    this.$loop = new RenderLoop(\n        this.$renderChanges.bind(this),\n        this.container.ownerDocument.defaultView\n    );\n    this.$loop.schedule(this.CHANGE_FULL);\n\n    this.updateCharacterSize();\n    this.setPadding(4);\n    config.resetOptions(this);\n    config._emit(\"renderer\", this);\n};\n\n(function() {\n\n    this.CHANGE_CURSOR = 1;\n    this.CHANGE_MARKER = 2;\n    this.CHANGE_GUTTER = 4;\n    this.CHANGE_SCROLL = 8;\n    this.CHANGE_LINES = 16;\n    this.CHANGE_TEXT = 32;\n    this.CHANGE_SIZE = 64;\n    this.CHANGE_MARKER_BACK = 128;\n    this.CHANGE_MARKER_FRONT = 256;\n    this.CHANGE_FULL = 512;\n    this.CHANGE_H_SCROLL = 1024;\n\n    oop.implement(this, EventEmitter);\n\n    this.updateCharacterSize = function() {\n        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n        }\n\n        this.layerConfig.characterWidth =\n        this.characterWidth = this.$textLayer.getCharacterWidth();\n        this.layerConfig.lineHeight =\n        this.lineHeight = this.$textLayer.getLineHeight();\n        this.$updatePrintMargin();\n    };\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n            \n        this.session = session;\n        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n            session.setScrollTop(-this.scrollMargin.top);\n\n        this.$cursorLayer.setSession(session);\n        this.$markerBack.setSession(session);\n        this.$markerFront.setSession(session);\n        this.$gutterLayer.setSession(session);\n        this.$textLayer.setSession(session);\n        if (!session)\n            return;\n        \n        this.$loop.schedule(this.CHANGE_FULL);\n        this.session.$setFontMetrics(this.$fontMetrics);\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        \n        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n        this.onChangeNewLineMode();\n        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n    };\n    this.updateLines = function(firstRow, lastRow, force) {\n        if (lastRow === undefined)\n            lastRow = Infinity;\n\n        if (!this.$changedLines) {\n            this.$changedLines = {\n                firstRow: firstRow,\n                lastRow: lastRow\n            };\n        }\n        else {\n            if (this.$changedLines.firstRow > firstRow)\n                this.$changedLines.firstRow = firstRow;\n\n            if (this.$changedLines.lastRow < lastRow)\n                this.$changedLines.lastRow = lastRow;\n        }\n        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n            if (force)\n                this.$changedLines.lastRow = this.layerConfig.lastRow;\n            else\n                return;\n        }\n        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n            return;\n        this.$loop.schedule(this.CHANGE_LINES);\n    };\n\n    this.onChangeNewLineMode = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n        this.$textLayer.$updateEolChar();\n        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);\n    };\n    \n    this.onChangeTabSize = function() {\n        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n        this.$textLayer.onChangeTabSize();\n    };\n    this.updateText = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n    };\n    this.updateFull = function(force) {\n        if (force)\n            this.$renderChanges(this.CHANGE_FULL, true);\n        else\n            this.$loop.schedule(this.CHANGE_FULL);\n    };\n    this.updateFontSize = function() {\n        this.$textLayer.checkForSizeChanges();\n    };\n\n    this.$changes = 0;\n    this.$updateSizeAsync = function() {\n        if (this.$loop.pending)\n            this.$size.$dirty = true;\n        else\n            this.onResize();\n    };\n    this.onResize = function(force, gutterWidth, width, height) {\n        if (this.resizing > 2)\n            return;\n        else if (this.resizing > 0)\n            this.resizing++;\n        else\n            this.resizing = force ? 1 : 0;\n        var el = this.container;\n        if (!height)\n            height = el.clientHeight || el.scrollHeight;\n        if (!width)\n            width = el.clientWidth || el.scrollWidth;\n        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n\n        \n        if (!this.$size.scrollerHeight || (!width && !height))\n            return this.resizing = 0;\n\n        if (force)\n            this.$gutterLayer.$padding = null;\n\n        if (force)\n            this.$renderChanges(changes | this.$changes, true);\n        else\n            this.$loop.schedule(changes | this.$changes);\n\n        if (this.resizing)\n            this.resizing = 0;\n        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;\n    };\n    \n    this.$updateCachedSize = function(force, gutterWidth, width, height) {\n        height -= (this.$extraHeight || 0);\n        var changes = 0;\n        var size = this.$size;\n        var oldSize = {\n            width: size.width,\n            height: size.height,\n            scrollerHeight: size.scrollerHeight,\n            scrollerWidth: size.scrollerWidth\n        };\n        if (height && (force || size.height != height)) {\n            size.height = height;\n            changes |= this.CHANGE_SIZE;\n\n            size.scrollerHeight = size.height;\n            if (this.$horizScroll)\n                size.scrollerHeight -= this.scrollBarH.getHeight();\n            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n\n            changes = changes | this.CHANGE_SCROLL;\n        }\n\n        if (width && (force || size.width != width)) {\n            changes |= this.CHANGE_SIZE;\n            size.width = width;\n            \n            if (gutterWidth == null)\n                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n            \n            this.gutterWidth = gutterWidth;\n            \n            dom.setStyle(this.scrollBarH.element.style, \"left\", gutterWidth + \"px\");\n            dom.setStyle(this.scroller.style, \"left\", gutterWidth + this.margin.left + \"px\");\n            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);\n            dom.setStyle(this.$gutter.style, \"left\", this.margin.left + \"px\");\n            \n            var right = this.scrollBarV.getWidth() + \"px\";\n            dom.setStyle(this.scrollBarH.element.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"bottom\", this.scrollBarH.getHeight());\n\n            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {\n                changes |= this.CHANGE_FULL;\n            }\n        }\n        \n        size.$dirty = !width || !height;\n\n        if (changes)\n            this._signal(\"resize\", oldSize);\n\n        return changes;\n    };\n\n    this.onGutterResize = function(width) {\n        var gutterWidth = this.$showGutter ? width : 0;\n        if (gutterWidth != this.gutterWidth)\n            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n\n        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else if (this.$size.$dirty) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else {\n            this.$computeLayerConfig();\n        }\n    };\n    this.adjustWrapLimit = function() {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth);\n        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n    };\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.setOption(\"animatedScroll\", shouldAnimate);\n    };\n    this.getAnimatedScroll = function() {\n        return this.$animatedScroll;\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.setOption(\"showInvisibles\", showInvisibles);\n        this.session.$bidiHandler.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.getOption(\"showInvisibles\");\n    };\n    this.getDisplayIndentGuides = function() {\n        return this.getOption(\"displayIndentGuides\");\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.setOption(\"displayIndentGuides\", display);\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.setOption(\"showPrintMargin\", showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.getOption(\"showPrintMargin\");\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.setOption(\"printMarginColumn\", showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.getOption(\"printMarginColumn\");\n    };\n    this.getShowGutter = function(){\n        return this.getOption(\"showGutter\");\n    };\n    this.setShowGutter = function(show){\n        return this.setOption(\"showGutter\", show);\n    };\n\n    this.getFadeFoldWidgets = function(){\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(show) {\n        this.setOption(\"fadeFoldWidgets\", show);\n    };\n\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n\n    this.$updatePrintMargin = function() {\n        if (!this.$showPrintMargin && !this.$printMarginEl)\n            return;\n\n        if (!this.$printMarginEl) {\n            var containerEl = dom.createElement(\"div\");\n            containerEl.className = \"ace_layer ace_print-margin-layer\";\n            this.$printMarginEl = dom.createElement(\"div\");\n            this.$printMarginEl.className = \"ace_print-margin\";\n            containerEl.appendChild(this.$printMarginEl);\n            this.content.insertBefore(containerEl, this.content.firstChild);\n        }\n\n        var style = this.$printMarginEl.style;\n        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + \"px\";\n        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n        \n        if (this.session && this.session.$wrap == -1)\n            this.adjustWrapLimit();\n    };\n    this.getContainerElement = function() {\n        return this.container;\n    };\n    this.getMouseEventTarget = function() {\n        return this.scroller;\n    };\n    this.getTextAreaContainer = function() {\n        return this.container;\n    };\n    this.$moveTextAreaToCursor = function() {\n        var style = this.textarea.style;\n        if (!this.$keepTextAreaAtCursor) {\n            dom.translate(this.textarea, -100, 0);\n            return;\n        }\n        var pixelPos = this.$cursorLayer.$pixelPos;\n        if (!pixelPos)\n            return;\n        var composition = this.$composition;\n        if (composition && composition.markerRange)\n            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);\n        \n        var config = this.layerConfig;\n        var posTop = pixelPos.top;\n        var posLeft = pixelPos.left;\n        posTop -= config.offset;\n\n        var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;\n        if (posTop < 0 || posTop > config.height - h) {\n            dom.translate(this.textarea, 0, 0);\n            return;\n        }\n\n        var w = 1;\n        if (!composition) {\n            posTop += this.lineHeight;\n        }\n        else {\n            if (composition.useTextareaForIME) {\n                var val = this.textarea.value;\n                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);\n                h += 2;\n            }\n            else {\n                posTop += this.lineHeight + 2;\n            }\n        }\n        \n        posLeft -= this.scrollLeft;\n        if (posLeft > this.$size.scrollerWidth - w)\n            posLeft = this.$size.scrollerWidth - w;\n\n        posLeft += this.gutterWidth + this.margin.left;\n\n        dom.setStyle(style, \"height\", h + \"px\");\n        dom.setStyle(style, \"width\", w + \"px\");\n        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, this.$size.height - h));\n    };\n    this.getFirstVisibleRow = function() {\n        return this.layerConfig.firstRow;\n    };\n    this.getFirstFullyVisibleRow = function() {\n        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n    };\n    this.getLastFullyVisibleRow = function() {\n        var config = this.layerConfig;\n        var lastRow = config.lastRow;\n        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;\n        if (top - this.session.getScrollTop() > config.height - config.lineHeight)\n            return lastRow - 1;\n        return lastRow;\n    };\n    this.getLastVisibleRow = function() {\n        return this.layerConfig.lastRow;\n    };\n\n    this.$padding = null;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.$textLayer.setPadding(padding);\n        this.$cursorLayer.setPadding(padding);\n        this.$markerFront.setPadding(padding);\n        this.$markerBack.setPadding(padding);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.$updatePrintMargin();\n    };\n    \n    this.setScrollMargin = function(top, bottom, left, right) {\n        var sm = this.scrollMargin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        if (sm.top && this.scrollTop <= 0 && this.session)\n            this.session.setScrollTop(-sm.top);\n        this.updateFull();\n    };\n    \n    this.setMargin = function(top, bottom, left, right) {\n        var sm = this.margin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);\n        this.updateFull();\n    };\n    this.getHScrollBarAlwaysVisible = function() {\n        return this.$hScrollBarAlwaysVisible;\n    };\n    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    this.getVScrollBarAlwaysVisible = function() {\n        return this.$vScrollBarAlwaysVisible;\n    };\n    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n    };\n\n    this.$updateScrollBarV = function() {\n        var scrollHeight = this.layerConfig.maxHeight;\n        var scrollerHeight = this.$size.scrollerHeight;\n        if (!this.$maxLines && this.$scrollPastEnd) {\n            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n            if (this.scrollTop > scrollHeight - scrollerHeight) {\n                scrollHeight = this.scrollTop + scrollerHeight;\n                this.scrollBarV.scrollTop = null;\n            }\n        }\n        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n    };\n    this.$updateScrollBarH = function() {\n        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n    };\n    \n    this.$frozen = false;\n    this.freeze = function() {\n        this.$frozen = true;\n    };\n    \n    this.unfreeze = function() {\n        this.$frozen = false;\n    };\n\n    this.$renderChanges = function(changes, force) {\n        if (this.$changes) {\n            changes |= this.$changes;\n            this.$changes = 0;\n        }\n        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n            this.$changes |= changes;\n            return; \n        } \n        if (this.$size.$dirty) {\n            this.$changes |= changes;\n            return this.onResize(true);\n        }\n        if (!this.lineHeight) {\n            this.$textLayer.checkForSizeChanges();\n        }\n        \n        this._signal(\"beforeRender\");\n        \n        if (this.session && this.session.$bidiHandler)\n            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);\n\n        var config = this.layerConfig;\n        if (changes & this.CHANGE_FULL ||\n            changes & this.CHANGE_SIZE ||\n            changes & this.CHANGE_TEXT ||\n            changes & this.CHANGE_LINES ||\n            changes & this.CHANGE_SCROLL ||\n            changes & this.CHANGE_H_SCROLL\n        ) {\n            changes |= this.$computeLayerConfig() | this.$loop.clear();\n            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;\n                if (st > 0) {\n                    this.scrollTop = st;\n                    changes = changes | this.CHANGE_SCROLL;\n                    changes |= this.$computeLayerConfig() | this.$loop.clear();\n                }\n            }\n            config = this.layerConfig;\n            this.$updateScrollBarV();\n            if (changes & this.CHANGE_H_SCROLL)\n                this.$updateScrollBarH();\n            \n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            \n            var width = config.width + 2 * this.$padding + \"px\";\n            var height = config.minHeight + \"px\";\n            \n            dom.setStyle(this.content.style, \"width\", width);\n            dom.setStyle(this.content.style, \"height\", height);\n        }\n        if (changes & this.CHANGE_H_SCROLL) {\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller\" : \"ace_scroller ace_scroll-left\";\n        }\n        if (changes & this.CHANGE_FULL) {\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\");\n            return;\n        }\n        if (changes & this.CHANGE_SCROLL) {\n            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n                this.$textLayer.update(config);\n            else\n                this.$textLayer.scrollLines(config);\n\n            if (this.$showGutter) {\n                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)\n                    this.$gutterLayer.update(config);\n                else\n                    this.$gutterLayer.scrollLines(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\");\n            return;\n        }\n\n        if (changes & this.CHANGE_TEXT) {\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_LINES) {\n            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_CURSOR) {\n            if (this.$highlightGutterLine)\n                this.$gutterLayer.updateLineHighlight(config);\n        }\n\n        if (changes & this.CHANGE_CURSOR) {\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n            this.$markerFront.update(config);\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n            this.$markerBack.update(config);\n        }\n\n        this._signal(\"afterRender\");\n    };\n\n    \n    this.$autosize = function() {\n        var height = this.session.getScreenLength() * this.lineHeight;\n        var maxHeight = this.$maxLines * this.lineHeight;\n        var desiredHeight = Math.min(maxHeight, \n            Math.max((this.$minLines || 1) * this.lineHeight, height)\n        ) + this.scrollMargin.v + (this.$extraHeight || 0);\n        if (this.$horizScroll)\n            desiredHeight += this.scrollBarH.getHeight();\n        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)\n            desiredHeight = this.$maxPixelHeight;\n        \n        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;\n        var vScroll = !hideScrollbars && height > maxHeight;\n        \n        if (desiredHeight != this.desiredHeight ||\n            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n            if (vScroll != this.$vScroll) {\n                this.$vScroll = vScroll;\n                this.scrollBarV.setVisible(vScroll);\n            }\n            \n            var w = this.container.clientWidth;\n            this.container.style.height = desiredHeight + \"px\";\n            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n            this.desiredHeight = desiredHeight;\n            \n            this._signal(\"autosize\");\n        }\n    };\n    \n    this.$computeLayerConfig = function() {\n        var session = this.session;\n        var size = this.$size;\n        \n        var hideScrollbars = size.height <= 2 * this.lineHeight;\n        var screenLines = this.session.getScreenLength();\n        var maxHeight = screenLines * this.lineHeight;\n\n        var longestLine = this.$getLongestLine();\n        \n        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n\n        var hScrollChanged = this.$horizScroll !== horizScroll;\n        if (hScrollChanged) {\n            this.$horizScroll = horizScroll;\n            this.scrollBarH.setVisible(horizScroll);\n        }\n        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine\n        if (this.$maxLines && this.lineHeight > 1)\n            this.$autosize();\n\n        var minHeight = size.scrollerHeight + this.lineHeight;\n        \n        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n            : 0;\n        maxHeight += scrollPastEnd;\n        \n        var sm = this.scrollMargin;\n        this.session.setScrollTop(Math.max(-sm.top,\n            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));\n\n        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, \n            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));\n        \n        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);\n        var vScrollChanged = vScrollBefore !== vScroll;\n        if (vScrollChanged) {\n            this.$vScroll = vScroll;\n            this.scrollBarV.setVisible(vScroll);\n        }\n\n        var offset = this.scrollTop % this.lineHeight;\n        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n        var lastRow = firstRow + lineCount;\n        var firstRowScreen, firstRowHeight;\n        var lineHeight = this.lineHeight;\n        firstRow = session.screenToDocumentRow(firstRow, 0);\n        var foldLine = session.getFoldLine(firstRow);\n        if (foldLine) {\n            firstRow = foldLine.start.row;\n        }\n\n        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n\n        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n                                                firstRowHeight;\n\n        offset = this.scrollTop - firstRowScreen * lineHeight;\n\n        var changes = 0;\n        if (this.layerConfig.width != longestLine || hScrollChanged) \n            changes = this.CHANGE_H_SCROLL;\n        if (hScrollChanged || vScrollChanged) {\n            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n            this._signal(\"scrollbarVisibilityChanged\");\n            if (vScrollChanged)\n                longestLine = this.$getLongestLine();\n        }\n        \n        this.layerConfig = {\n            width : longestLine,\n            padding : this.$padding,\n            firstRow : firstRow,\n            firstRowScreen: firstRowScreen,\n            lastRow : lastRow,\n            lineHeight : lineHeight,\n            characterWidth : this.characterWidth,\n            minHeight : minHeight,\n            maxHeight : maxHeight,\n            offset : offset,\n            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,\n            height : this.$size.scrollerHeight\n        };\n\n        if (this.session.$bidiHandler)\n            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);\n\n        return changes;\n    };\n\n    this.$updateLines = function() {\n        if (!this.$changedLines) return;\n        var firstRow = this.$changedLines.firstRow;\n        var lastRow = this.$changedLines.lastRow;\n        this.$changedLines = null;\n\n        var layerConfig = this.layerConfig;\n\n        if (firstRow > layerConfig.lastRow + 1) { return; }\n        if (lastRow < layerConfig.firstRow) { return; }\n        if (lastRow === Infinity) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(layerConfig);\n            this.$textLayer.update(layerConfig);\n            return;\n        }\n        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n        return true;\n    };\n\n    this.$getLongestLine = function() {\n        var charCount = this.session.getScreenWidth();\n        if (this.showInvisibles && !this.session.$useWrapMode)\n            charCount += 1;\n            \n        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)\n            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;\n\n        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n    };\n    this.updateFrontMarkers = function() {\n        this.$markerFront.setMarkers(this.session.getMarkers(true));\n        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n    };\n    this.updateBackMarkers = function() {\n        this.$markerBack.setMarkers(this.session.getMarkers());\n        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n    };\n    this.addGutterDecoration = function(row, className){\n        this.$gutterLayer.addGutterDecoration(row, className);\n    };\n    this.removeGutterDecoration = function(row, className){\n        this.$gutterLayer.removeGutterDecoration(row, className);\n    };\n    this.updateBreakpoints = function(rows) {\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.setAnnotations = function(annotations) {\n        this.$gutterLayer.setAnnotations(annotations);\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.updateCursor = function() {\n        this.$loop.schedule(this.CHANGE_CURSOR);\n    };\n    this.hideCursor = function() {\n        this.$cursorLayer.hideCursor();\n    };\n    this.showCursor = function() {\n        this.$cursorLayer.showCursor();\n    };\n\n    this.scrollSelectionIntoView = function(anchor, lead, offset) {\n        this.scrollCursorIntoView(anchor, offset);\n        this.scrollCursorIntoView(lead, offset);\n    };\n    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {\n        if (this.$size.scrollerHeight === 0)\n            return;\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n\n        var left = pos.left;\n        var top = pos.top;\n        \n        var topMargin = $viewMargin && $viewMargin.top || 0;\n        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n        \n        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n        \n        if (scrollTop + topMargin > top) {\n            if (offset && scrollTop + topMargin > top + this.lineHeight)\n                top -= offset * this.$size.scrollerHeight;\n            if (top === 0)\n                top = -this.scrollMargin.top;\n            this.session.setScrollTop(top);\n        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {\n            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)\n                top += offset * this.$size.scrollerHeight;\n            this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);\n        }\n\n        var scrollLeft = this.scrollLeft;\n\n        if (scrollLeft > left) {\n            if (left < this.$padding + 2 * this.layerConfig.characterWidth)\n                left = -this.scrollMargin.left;\n            this.session.setScrollLeft(left);\n        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {\n            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));\n        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {\n            this.session.setScrollLeft(0);\n        }\n    };\n    this.getScrollTop = function() {\n        return this.session.getScrollTop();\n    };\n    this.getScrollLeft = function() {\n        return this.session.getScrollLeft();\n    };\n    this.getScrollTopRow = function() {\n        return this.scrollTop / this.lineHeight;\n    };\n    this.getScrollBottomRow = function() {\n        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n    };\n    this.scrollToRow = function(row) {\n        this.session.setScrollTop(row * this.lineHeight);\n    };\n\n    this.alignCursor = function(cursor, alignment) {\n        if (typeof cursor == \"number\")\n            cursor = {row: cursor, column: 0};\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var h = this.$size.scrollerHeight - this.lineHeight;\n        var offset = pos.top - h * (alignment || 0);\n\n        this.session.setScrollTop(offset);\n        return offset;\n    };\n\n    this.STEPS = 8;\n    this.$calcSteps = function(fromValue, toValue){\n        var i = 0;\n        var l = this.STEPS;\n        var steps = [];\n\n        var func  = function(t, x_min, dx) {\n            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n        };\n\n        for (i = 0; i < l; ++i)\n            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n\n        return steps;\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});\n        var offset = pos.top;\n        if (center)\n            offset -= this.$size.scrollerHeight / 2;\n\n        var initialScroll = this.scrollTop;\n        this.session.setScrollTop(offset);\n        if (animate !== false)\n            this.animateScrolling(initialScroll, callback);\n    };\n\n    this.animateScrolling = function(fromValue, callback) {\n        var toValue = this.scrollTop;\n        if (!this.$animatedScroll)\n            return;\n        var _self = this;\n        \n        if (fromValue == toValue)\n            return;\n        \n        if (this.$scrollAnimation) {\n            var oldSteps = this.$scrollAnimation.steps;\n            if (oldSteps.length) {\n                fromValue = oldSteps[0];\n                if (fromValue == toValue)\n                    return;\n            }\n        }\n        \n        var steps = _self.$calcSteps(fromValue, toValue);\n        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};\n\n        clearInterval(this.$timer);\n\n        _self.session.setScrollTop(steps.shift());\n        _self.session.$scrollTop = toValue;\n        this.$timer = setInterval(function() {\n            if (steps.length) {\n                _self.session.setScrollTop(steps.shift());\n                _self.session.$scrollTop = toValue;\n            } else if (toValue != null) {\n                _self.session.$scrollTop = -1;\n                _self.session.setScrollTop(toValue);\n                toValue = null;\n            } else {\n                _self.$timer = clearInterval(_self.$timer);\n                _self.$scrollAnimation = null;\n                callback && callback();\n            }\n        }, 10);\n    };\n    this.scrollToY = function(scrollTop) {\n        if (this.scrollTop !== scrollTop) {\n            this.$loop.schedule(this.CHANGE_SCROLL);\n            this.scrollTop = scrollTop;\n        }\n    };\n    this.scrollToX = function(scrollLeft) {\n        if (this.scrollLeft !== scrollLeft)\n            this.scrollLeft = scrollLeft;\n        this.$loop.schedule(this.CHANGE_H_SCROLL);\n    };\n    this.scrollTo = function(x, y) {\n        this.session.setScrollTop(y);\n        this.session.setScrollLeft(y);\n    };\n    this.scrollBy = function(deltaX, deltaY) {\n        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n    };\n    this.isScrollableBy = function(deltaX, deltaY) {\n        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n           return true;\n        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n           return true;\n        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n            return true;\n        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n            - this.layerConfig.width < -1 + this.scrollMargin.right)\n           return true;\n    };\n\n    this.pixelToScreenCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        \n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};\n    };\n\n    this.screenToTextCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n\n        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);\n    };\n    this.textToScreenCoordinates = function(row, column) {\n        var canvasPos = this.scroller.getBoundingClientRect();\n        var pos = this.session.documentToScreenPosition(row, column);\n\n        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)\n             ? this.session.$bidiHandler.getPosLeft(pos.column)\n             : Math.round(pos.column * this.characterWidth));\n        \n        var y = pos.row * this.lineHeight;\n\n        return {\n            pageX: canvasPos.left + x - this.scrollLeft,\n            pageY: canvasPos.top + y - this.scrollTop\n        };\n    };\n    this.visualizeFocus = function() {\n        dom.addCssClass(this.container, \"ace_focus\");\n    };\n    this.visualizeBlur = function() {\n        dom.removeCssClass(this.container, \"ace_focus\");\n    };\n    this.showComposition = function(composition) {\n        this.$composition = composition;\n        if (!composition.cssText) {\n            composition.cssText = this.textarea.style.cssText;\n            composition.keepTextAreaAtCursor = this.$keepTextAreaAtCursor;\n        }\n        composition.useTextareaForIME = this.$useTextareaForIME;\n        \n        if (this.$useTextareaForIME) {\n            this.$keepTextAreaAtCursor = true;\n            dom.addCssClass(this.textarea, \"ace_composition\");\n            this.textarea.style.cssText = \"\";\n            this.$moveTextAreaToCursor();\n            this.$cursorLayer.element.style.display = \"none\";\n        }\n        else {            \n            composition.markerId = this.session.addMarker(composition.markerRange, \"ace_composition_marker\", \"text\");\n        }\n    };\n    this.setCompositionText = function(text) {\n        var cursor = this.session.selection.cursor;\n        this.addToken(text, \"composition_placeholder\", cursor.row, cursor.column);\n        this.$moveTextAreaToCursor();\n    };\n    this.hideComposition = function() {\n        if (!this.$composition)\n            return;\n        \n        if (this.$composition.markerId)\n            this.session.removeMarker(this.$composition.markerId);\n\n        dom.removeCssClass(this.textarea, \"ace_composition\");\n        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;\n        this.textarea.style.cssText = this.$composition.cssText;\n        this.$composition = null;\n        this.$cursorLayer.element.style.display = \"\";\n    };\n    \n    this.addToken = function(text, type, row, column) {\n        var session = this.session;\n        session.bgTokenizer.lines[row] = null;\n        var newToken = {type: type, value: text};\n        var tokens = session.getTokens(row);\n        if (column == null) {\n            tokens.push(newToken);\n        } else {\n            var l = 0;\n            for (var i =0; i < tokens.length; i++) {\n                var token = tokens[i];\n                l += token.value.length;\n                if (column <= l) {\n                    var diff = token.value.length - (l - column);\n                    var before = token.value.slice(0, diff);\n                    var after = token.value.slice(diff);\n    \n                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});\n                    break;\n                }\n            }\n        }\n        this.updateLines(row, row);\n    };\n    this.setTheme = function(theme, cb) {\n        var _self = this;\n        this.$themeId = theme;\n        _self._dispatchEvent('themeChange',{theme:theme});\n\n        if (!theme || typeof theme == \"string\") {\n            var moduleName = theme || this.$options.theme.initialValue;\n            config.loadModule([\"theme\", moduleName], afterLoad);\n        } else {\n            afterLoad(theme);\n        }\n\n        function afterLoad(module) {\n            if (_self.$themeId != theme)\n                return cb && cb();\n            if (!module || !module.cssClass)\n                throw new Error(\"couldn't load module \" + theme + \" or it didn't call define\");\n            if (module.$id)\n                _self.$themeId = module.$id;\n            dom.importCssString(\n                module.cssText,\n                module.cssClass,\n                _self.container\n            );\n\n            if (_self.theme)\n                dom.removeCssClass(_self.container, _self.theme.cssClass);\n\n            var padding = \"padding\" in module ? module.padding \n                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n            if (_self.$padding && padding != _self.$padding)\n                _self.setPadding(padding);\n            _self.$theme = module.cssClass;\n\n            _self.theme = module;\n            dom.addCssClass(_self.container, module.cssClass);\n            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n            if (_self.$size) {\n                _self.$size.width = 0;\n                _self.$updateSizeAsync();\n            }\n\n            _self._dispatchEvent('themeLoaded', {theme:module});\n            cb && cb();\n        }\n    };\n    this.getTheme = function() {\n        return this.$themeId;\n    };\n    this.setStyle = function(style, include) {\n        dom.setCssClass(this.container, style, include !== false);\n    };\n    this.unsetStyle = function(style) {\n        dom.removeCssClass(this.container, style);\n    };\n    \n    this.setCursorStyle = function(style) {\n        dom.setStyle(this.scroller.style, \"cursor\", style);\n    };\n    this.setMouseCursor = function(cursorStyle) {\n        dom.setStyle(this.scroller.style, \"cursor\", cursorStyle);\n    };\n    \n    this.attachToShadowRoot = function() {\n        dom.importCssString(editorCss, \"ace_editor.css\", this.container);\n    };\n    this.destroy = function() {\n        this.$fontMetrics.destroy();\n        this.$cursorLayer.destroy();\n    };\n\n}).call(VirtualRenderer.prototype);\n\n\nconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n    animatedScroll: {initialValue: false},\n    showInvisibles: {\n        set: function(value) {\n            if (this.$textLayer.setShowInvisibles(value))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: false\n    },\n    showPrintMargin: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: true\n    },\n    printMarginColumn: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: 80\n    },\n    printMargin: {\n        set: function(val) {\n            if (typeof val == \"number\")\n                this.$printMarginColumn = val;\n            this.$showPrintMargin = !!val;\n            this.$updatePrintMargin();\n        },\n        get: function() {\n            return this.$showPrintMargin && this.$printMarginColumn; \n        }\n    },\n    showGutter: {\n        set: function(show){\n            this.$gutter.style.display = show ? \"block\" : \"none\";\n            this.$loop.schedule(this.CHANGE_FULL);\n            this.onGutterResize();\n        },\n        initialValue: true\n    },\n    fadeFoldWidgets: {\n        set: function(show) {\n            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n        },\n        initialValue: false\n    },\n    showFoldWidgets: {\n        set: function(show) {\n            this.$gutterLayer.setShowFoldWidgets(show);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    displayIndentGuides: {\n        set: function(show) {\n            if (this.$textLayer.setDisplayIndentGuides(show))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: true\n    },\n    highlightGutterLine: {\n        set: function(shouldHighlight) {\n            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    hScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    vScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    fontSize: {\n        set: function(size) {\n            if (typeof size == \"number\")\n                size = size + \"px\";\n            this.container.style.fontSize = size;\n            this.updateFontSize();\n        },\n        initialValue: 12\n    },\n    fontFamily: {\n        set: function(name) {\n            this.container.style.fontFamily = name;\n            this.updateFontSize();\n        }\n    },\n    maxLines: {\n        set: function(val) {\n            this.updateFull();\n        }\n    },\n    minLines: {\n        set: function(val) {\n            if (!(this.$minLines < 0x1ffffffffffff))\n                this.$minLines = 0;\n            this.updateFull();\n        }\n    },\n    maxPixelHeight: {\n        set: function(val) {\n            this.updateFull();\n        },\n        initialValue: 0\n    },\n    scrollPastEnd: {\n        set: function(val) {\n            val = +val || 0;\n            if (this.$scrollPastEnd == val)\n                return;\n            this.$scrollPastEnd = val;\n            this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: 0,\n        handlesSet: true\n    },\n    fixedWidthGutter: {\n        set: function(val) {\n            this.$gutterLayer.$fixedWidth = !!val;\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        }\n    },\n    theme: {\n        set: function(val) { this.setTheme(val); },\n        get: function() { return this.$themeId || this.theme; },\n        initialValue: \"./theme/textmate\",\n        handlesSet: true\n    },\n    hasCssTransforms: {\n    },\n    useTextareaForIME: {\n        initialValue: !useragent.isMobile && !useragent.isIE\n    }\n});\n\nexports.VirtualRenderer = VirtualRenderer;\n});\n\nace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar net = require(\"../lib/net\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar config = require(\"../config\");\n\nfunction $workerBlob(workerUrl) {\n    var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n    try {\n        return new Blob([script], {\"type\": \"application/javascript\"});\n    } catch (e) { // Backwards-compatibility\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n        var blobBuilder = new BlobBuilder();\n        blobBuilder.append(script);\n        return blobBuilder.getBlob(\"application/javascript\");\n    }\n}\n\nfunction createWorker(workerUrl) {\n    if (typeof Worker == \"undefined\")\n        return { postMessage: function() {}, terminate: function() {} };\n    if (config.get(\"loadWorkerFromBlob\")) {\n        var blob = $workerBlob(workerUrl);\n        var URL = window.URL || window.webkitURL;\n        var blobURL = URL.createObjectURL(blob);\n        return new Worker(blobURL);\n    }\n    return new Worker(workerUrl);\n}\n\nvar WorkerClient = function(worker) {\n    if (!worker.postMessage)\n        worker = this.$createWorkerFromOldConfig.apply(this, arguments);\n\n    this.$worker = worker;\n    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n\n    this.callbackId = 1;\n    this.callbacks = {};\n\n    this.$worker.onmessage = this.onMessage;\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {\n        if (require.nameToUrl && !require.toUrl)\n            require.toUrl = require.nameToUrl;\n\n        if (config.get(\"packaged\") || !require.toUrl) {\n            workerUrl = workerUrl || config.moduleUrl(mod, \"worker\");\n        } else {\n            var normalizePath = this.$normalizePath;\n            workerUrl = workerUrl || normalizePath(require.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n            var tlns = {};\n            topLevelNamespaces.forEach(function(ns) {\n                tlns[ns] = normalizePath(require.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n            });\n        }\n\n        this.$worker = createWorker(workerUrl);\n        if (importScripts) {\n            this.send(\"importScripts\", importScripts);\n        }\n        this.$worker.postMessage({\n            init : true,\n            tlns : tlns,\n            module : mod,\n            classname : classname\n        });\n        return this.$worker;\n    };\n\n    this.onMessage = function(e) {\n        var msg = e.data;\n        switch (msg.type) {\n            case \"event\":\n                this._signal(msg.name, {data: msg.data});\n                break;\n            case \"call\":\n                var callback = this.callbacks[msg.id];\n                if (callback) {\n                    callback(msg.data);\n                    delete this.callbacks[msg.id];\n                }\n                break;\n            case \"error\":\n                this.reportError(msg.data);\n                break;\n            case \"log\":\n                window.console && console.log && console.log.apply(console, msg.data);\n                break;\n        }\n    };\n    \n    this.reportError = function(err) {\n        window.console && console.error && console.error(err);\n    };\n\n    this.$normalizePath = function(path) {\n        return net.qualifyURL(path);\n    };\n\n    this.terminate = function() {\n        this._signal(\"terminate\", {});\n        this.deltaQueue = null;\n        this.$worker.terminate();\n        this.$worker = null;\n        if (this.$doc)\n            this.$doc.off(\"change\", this.changeListener);\n        this.$doc = null;\n    };\n\n    this.send = function(cmd, args) {\n        this.$worker.postMessage({command: cmd, args: args});\n    };\n\n    this.call = function(cmd, args, callback) {\n        if (callback) {\n            var id = this.callbackId++;\n            this.callbacks[id] = callback;\n            args.push(id);\n        }\n        this.send(cmd, args);\n    };\n\n    this.emit = function(event, data) {\n        try {\n            if (data.data && data.data.err)\n                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};\n            this.$worker.postMessage({event: event, data: {data: data.data}});\n        }\n        catch(ex) {\n            console.error(ex.stack);\n        }\n    };\n\n    this.attachToDocument = function(doc) {\n        if (this.$doc)\n            this.terminate();\n\n        this.$doc = doc;\n        this.call(\"setValue\", [doc.getValue()]);\n        doc.on(\"change\", this.changeListener);\n    };\n\n    this.changeListener = function(delta) {\n        if (!this.deltaQueue) {\n            this.deltaQueue = [];\n            setTimeout(this.$sendDeltaQueue, 0);\n        }\n        if (delta.action == \"insert\")\n            this.deltaQueue.push(delta.start, delta.lines);\n        else\n            this.deltaQueue.push(delta.start, delta.end);\n    };\n\n    this.$sendDeltaQueue = function() {\n        var q = this.deltaQueue;\n        if (!q) return;\n        this.deltaQueue = null;\n        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {\n            this.call(\"setValue\", [this.$doc.getValue()]);\n        } else\n            this.emit(\"change\", {data: q});\n    };\n\n}).call(WorkerClient.prototype);\n\n\nvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n    var main = null;\n    var emitSync = false;\n    var sender = Object.create(EventEmitter);\n\n    var messageBuffer = [];\n    var workerClient = new WorkerClient({\n        messageBuffer: messageBuffer,\n        terminate: function() {},\n        postMessage: function(e) {\n            messageBuffer.push(e);\n            if (!main) return;\n            if (emitSync)\n                setTimeout(processNext);\n            else\n                processNext();\n        }\n    });\n\n    workerClient.setEmitSync = function(val) { emitSync = val; };\n\n    var processNext = function() {\n        var msg = messageBuffer.shift();\n        if (msg.command)\n            main[msg.command].apply(main, msg.args);\n        else if (msg.event)\n            sender._signal(msg.event, msg.data);\n    };\n\n    sender.postMessage = function(msg) {\n        workerClient.onMessage({data: msg});\n    };\n    sender.callback = function(data, callbackId) {\n        this.postMessage({type: \"call\", id: callbackId, data: data});\n    };\n    sender.emit = function(name, data) {\n        this.postMessage({type: \"event\", name: name, data: data});\n    };\n\n    config.loadModule([\"worker\", mod], function(Main) {\n        main = new Main[classname](sender);\n        while (messageBuffer.length)\n            processNext();\n    });\n\n    return workerClient;\n};\n\nexports.UIWorkerClient = UIWorkerClient;\nexports.WorkerClient = WorkerClient;\nexports.createWorker = createWorker;\n\n\n});\n\nace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar oop = require(\"./lib/oop\");\n\nvar PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {\n    var _self = this;\n    this.length = length;\n    this.session = session;\n    this.doc = session.getDocument();\n    this.mainClass = mainClass;\n    this.othersClass = othersClass;\n    this.$onUpdate = this.onUpdate.bind(this);\n    this.doc.on(\"change\", this.$onUpdate);\n    this.$others = others;\n    \n    this.$onCursorChange = function() {\n        setTimeout(function() {\n            _self.onCursorChange();\n        });\n    };\n    \n    this.$pos = pos;\n    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};\n    this.$undoStackDepth = undoStack.length;\n    this.setup();\n\n    session.selection.on(\"changeCursor\", this.$onCursorChange);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setup = function() {\n        var _self = this;\n        var doc = this.doc;\n        var session = this.session;\n        \n        this.selectionBefore = session.selection.toJSON();\n        if (session.selection.inMultiSelectMode)\n            session.selection.toSingleRange();\n\n        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);\n        var pos = this.pos;\n        pos.$insertRight = true;\n        pos.detach();\n        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n        this.others = [];\n        this.$others.forEach(function(other) {\n            var anchor = doc.createAnchor(other.row, other.column);\n            anchor.$insertRight = true;\n            anchor.detach();\n            _self.others.push(anchor);\n        });\n        session.setUndoSelect(false);\n    };\n    this.showOtherMarkers = function() {\n        if (this.othersActive) return;\n        var session = this.session;\n        var _self = this;\n        this.othersActive = true;\n        this.others.forEach(function(anchor) {\n            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);\n        });\n    };\n    this.hideOtherMarkers = function() {\n        if (!this.othersActive) return;\n        this.othersActive = false;\n        for (var i = 0; i < this.others.length; i++) {\n            this.session.removeMarker(this.others[i].markerId);\n        }\n    };\n    this.onUpdate = function(delta) {\n        if (this.$updating)\n            return this.updateAnchors(delta);\n            \n        var range = delta;\n        if (range.start.row !== range.end.row) return;\n        if (range.start.row !== this.pos.row) return;\n        this.$updating = true;\n        var lengthDiff = delta.action === \"insert\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;\n        var distanceFromStart = range.start.column - this.pos.column;\n        \n        this.updateAnchors(delta);\n        \n        if (inMainRange)\n            this.length += lengthDiff;\n\n        if (inMainRange && !this.session.$fromUndo) {\n            if (delta.action === 'insert') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.insertMergedLines(newPos, delta.lines);\n                }\n            } else if (delta.action === 'remove') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n                }\n            }\n        }\n        \n        this.$updating = false;\n        this.updateMarkers();\n    };\n    \n    this.updateAnchors = function(delta) {\n        this.pos.onChange(delta);\n        for (var i = this.others.length; i--;)\n            this.others[i].onChange(delta);\n        this.updateMarkers();\n    };\n    \n    this.updateMarkers = function() {\n        if (this.$updating)\n            return;\n        var _self = this;\n        var session = this.session;\n        var updateMarker = function(pos, className) {\n            session.removeMarker(pos.markerId);\n            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);\n        };\n        updateMarker(this.pos, this.mainClass);\n        for (var i = this.others.length; i--;)\n            updateMarker(this.others[i], this.othersClass);\n    };\n\n    this.onCursorChange = function(event) {\n        if (this.$updating || !this.session) return;\n        var pos = this.session.selection.getCursor();\n        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n            this.showOtherMarkers();\n            this._emit(\"cursorEnter\", event);\n        } else {\n            this.hideOtherMarkers();\n            this._emit(\"cursorLeave\", event);\n        }\n    };    \n    this.detach = function() {\n        this.session.removeMarker(this.pos && this.pos.markerId);\n        this.hideOtherMarkers();\n        this.doc.removeEventListener(\"change\", this.$onUpdate);\n        this.session.selection.removeEventListener(\"changeCursor\", this.$onCursorChange);\n        this.session.setUndoSelect(true);\n        this.session = null;\n    };\n    this.cancel = function() {\n        if (this.$undoStackDepth === -1)\n            return;\n        var undoManager = this.session.getUndoManager();\n        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;\n        for (var i = 0; i < undosRequired; i++) {\n            undoManager.undo(this.session, true);\n        }\n        if (this.selectionBefore)\n            this.session.selection.fromJSON(this.selectionBefore);\n    };\n}).call(PlaceHolder.prototype);\n\n\nexports.PlaceHolder = PlaceHolder;\n});\n\nace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\n\nfunction onMouseDown(e) {\n    var ev = e.domEvent;\n    var alt = ev.altKey;\n    var shift = ev.shiftKey;\n    var ctrl = ev.ctrlKey;\n    var accel = e.getAccelKey();\n    var button = e.getButton();\n    \n    if (ctrl && useragent.isMac)\n        button = ev.button;\n\n    if (e.editor.inMultiSelectMode && button == 2) {\n        e.editor.textInput.onContextMenu(e.domEvent);\n        return;\n    }\n    \n    if (!ctrl && !alt && !accel) {\n        if (button === 0 && e.editor.inMultiSelectMode)\n            e.editor.exitMultiSelectMode();\n        return;\n    }\n    \n    if (button !== 0)\n        return;\n\n    var editor = e.editor;\n    var selection = editor.selection;\n    var isMultiSelect = editor.inMultiSelectMode;\n    var pos = e.getDocumentPosition();\n    var cursor = selection.getCursor();\n    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n\n    var mouseX = e.x, mouseY = e.y;\n    var onMouseSelection = function(e) {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    \n    var session = editor.session;\n    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n    var screenCursor = screenAnchor;\n    \n    var selectionMode;\n    if (editor.$mouseHandler.$enableJumpToDef) {\n        if (ctrl && alt || accel && alt)\n            selectionMode = shift ? \"block\" : \"add\";\n        else if (alt && editor.$blockSelectEnabled)\n            selectionMode = \"block\";\n    } else {\n        if (accel && !alt) {\n            selectionMode = \"add\";\n            if (!isMultiSelect && shift)\n                return;\n        } else if (alt && editor.$blockSelectEnabled) {\n            selectionMode = \"block\";\n        }\n    }\n    \n    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n        editor.$mouseHandler.cancelContextMenu();\n    }\n\n    if (selectionMode == \"add\") {\n        if (!isMultiSelect && inSelection)\n            return; // dragging\n\n        if (!isMultiSelect) {\n            var range = selection.toOrientedRange();\n            editor.addSelectionMarker(range);\n        }\n\n        var oldRange = selection.rangeList.rangeAtPoint(pos);\n        \n        editor.inVirtualSelectionMode = true;\n        \n        if (shift) {\n            oldRange = null;\n            range = selection.ranges[0] || range;\n            editor.removeSelectionMarker(range);\n        }\n        editor.once(\"mouseup\", function() {\n            var tmpSel = selection.toOrientedRange();\n\n            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n                selection.substractPoint(tmpSel.cursor);\n            else {\n                if (shift) {\n                    selection.substractPoint(range.cursor);\n                } else if (range) {\n                    editor.removeSelectionMarker(range);\n                    selection.addRange(range);\n                }\n                selection.addRange(tmpSel);\n            }\n            editor.inVirtualSelectionMode = false;\n        });\n\n    } else if (selectionMode == \"block\") {\n        e.stop();\n        editor.inVirtualSelectionMode = true;        \n        var initialRange;\n        var rectSel = [];\n        var blockSelect = function() {\n            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);\n\n            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n                return;\n            screenCursor = newCursor;\n            \n            editor.selection.moveToPosition(cursor);\n            editor.renderer.scrollCursorIntoView();\n\n            editor.removeSelectionMarkers(rectSel);\n            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n            rectSel.forEach(editor.addSelectionMarker, editor);\n            editor.updateSelectionMarkers();\n        };\n        if (isMultiSelect && !accel) {\n            selection.toSingleRange();\n        } else if (!isMultiSelect && accel) {\n            initialRange = selection.toOrientedRange();\n            editor.addSelectionMarker(initialRange);\n        }\n        \n        if (shift)\n            screenAnchor = session.documentToScreenPosition(selection.lead);            \n        else\n            selection.moveToPosition(pos);\n        \n        screenCursor = {row: -1, column: -1};\n\n        var onMouseSelectionEnd = function(e) {\n            blockSelect();\n            clearInterval(timerId);\n            editor.removeSelectionMarkers(rectSel);\n            if (!rectSel.length)\n                rectSel = [selection.toOrientedRange()];\n            if (initialRange) {\n                editor.removeSelectionMarker(initialRange);\n                selection.toSingleRange(initialRange);\n            }\n            for (var i = 0; i < rectSel.length; i++)\n                selection.addRange(rectSel[i]);\n            editor.inVirtualSelectionMode = false;\n            editor.$mouseHandler.$clickSelection = null;\n        };\n\n        var onSelectionInterval = blockSelect;\n\n        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n        var timerId = setInterval(function() {onSelectionInterval();}, 20);\n\n        return e.preventDefault();\n    }\n}\n\n\nexports.onMouseDown = onMouseDown;\n\n});\n\nace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(require, exports, module) {\nexports.defaultCommands = [{\n    name: \"addCursorAbove\",\n    description: \"Add cursor above\",\n    exec: function(editor) { editor.selectMoreLines(-1); },\n    bindKey: {win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelow\",\n    description: \"Add cursor below\",\n    exec: function(editor) { editor.selectMoreLines(1); },\n    bindKey: {win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorAboveSkipCurrent\",\n    description: \"Add cursor above (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelowSkipCurrent\",\n    description: \"Add cursor below (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreBefore\",\n    description: \"Select more before\",\n    exec: function(editor) { editor.selectMore(-1); },\n    bindKey: {win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreAfter\",\n    description: \"Select more after\",\n    exec: function(editor) { editor.selectMore(1); },\n    bindKey: {win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextBefore\",\n    description: \"Select next before\",\n    exec: function(editor) { editor.selectMore(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextAfter\",\n    description: \"Select next after\",\n    exec: function(editor) { editor.selectMore(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"splitIntoLines\",\n    description: \"Split into lines\",\n    exec: function(editor) { editor.multiSelect.splitIntoLines(); },\n    bindKey: {win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\"},\n    readOnly: true\n}, {\n    name: \"alignCursors\",\n    description: \"Align cursors\",\n    exec: function(editor) { editor.alignCursors(); },\n    bindKey: {win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\"},\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"findAll\",\n    description: \"Find all\",\n    exec: function(editor) { editor.findAll(); },\n    bindKey: {win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}];\nexports.multiSelectCommands = [{\n    name: \"singleSelection\",\n    description: \"Single selection\",\n    bindKey: \"esc\",\n    exec: function(editor) { editor.exitMultiSelectMode(); },\n    scrollIntoView: \"cursor\",\n    readOnly: true,\n    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}\n}];\n\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nexports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n});\n\nace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(require, exports, module) {\n\nvar RangeList = require(\"./range_list\").RangeList;\nvar Range = require(\"./range\").Range;\nvar Selection = require(\"./selection\").Selection;\nvar onMouseDown = require(\"./mouse/multi_select_handler\").onMouseDown;\nvar event = require(\"./lib/event\");\nvar lang = require(\"./lib/lang\");\nvar commands = require(\"./commands/multi_select_commands\");\nexports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\nvar Search = require(\"./search\").Search;\nvar search = new Search();\n\nfunction find(session, needle, dir) {\n    search.$options.wrap = true;\n    search.$options.needle = needle;\n    search.$options.backwards = dir == -1;\n    return search.find(session);\n}\nvar EditSession = require(\"./edit_session\").EditSession;\n(function() {\n    this.getSelectionMarkers = function() {\n        return this.$selectionMarkers;\n    };\n}).call(EditSession.prototype);\n(function() {\n    this.ranges = null;\n    this.rangeList = null;\n    this.addRange = function(range, $blockChangeEvents) {\n        if (!range)\n            return;\n\n        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n            var oldRange = this.toOrientedRange();\n            this.rangeList.add(oldRange);\n            this.rangeList.add(range);\n            if (this.rangeList.ranges.length != 2) {\n                this.rangeList.removeAll();\n                return $blockChangeEvents || this.fromOrientedRange(range);\n            }\n            this.rangeList.removeAll();\n            this.rangeList.add(oldRange);\n            this.$onAddRange(oldRange);\n        }\n\n        if (!range.cursor)\n            range.cursor = range.end;\n\n        var removed = this.rangeList.add(range);\n\n        this.$onAddRange(range);\n\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n            this._signal(\"multiSelect\");\n            this.inMultiSelectMode = true;\n            this.session.$undoSelect = false;\n            this.rangeList.attach(this.session);\n        }\n\n        return $blockChangeEvents || this.fromOrientedRange(range);\n    };\n\n    this.toSingleRange = function(range) {\n        range = range || this.ranges[0];\n        var removed = this.rangeList.removeAll();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        range && this.fromOrientedRange(range);\n    };\n    this.substractPoint = function(pos) {\n        var removed = this.rangeList.substractPoint(pos);\n        if (removed) {\n            this.$onRemoveRange(removed);\n            return removed[0];\n        }\n    };\n    this.mergeOverlappingRanges = function() {\n        var removed = this.rangeList.merge();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n    };\n\n    this.$onAddRange = function(range) {\n        this.rangeCount = this.rangeList.ranges.length;\n        this.ranges.unshift(range);\n        this._signal(\"addRange\", {range: range});\n    };\n\n    this.$onRemoveRange = function(removed) {\n        this.rangeCount = this.rangeList.ranges.length;\n        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n            var lastRange = this.rangeList.ranges.pop();\n            removed.push(lastRange);\n            this.rangeCount = 0;\n        }\n\n        for (var i = removed.length; i--; ) {\n            var index = this.ranges.indexOf(removed[i]);\n            this.ranges.splice(index, 1);\n        }\n\n        this._signal(\"removeRange\", {ranges: removed});\n\n        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n            this.inMultiSelectMode = false;\n            this._signal(\"singleSelect\");\n            this.session.$undoSelect = true;\n            this.rangeList.detach(this.session);\n        }\n\n        lastRange = lastRange || this.ranges[0];\n        if (lastRange && !lastRange.isEqual(this.getRange()))\n            this.fromOrientedRange(lastRange);\n    };\n    this.$initRangeList = function() {\n        if (this.rangeList)\n            return;\n\n        this.rangeList = new RangeList();\n        this.ranges = [];\n        this.rangeCount = 0;\n    };\n    this.getAllRanges = function() {\n        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n    };\n\n    this.splitIntoLines = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        } else {\n            var range = this.getRange();\n            var isBackwards = this.isBackwards();\n            var startRow = range.start.row;\n            var endRow = range.end.row;\n            if (startRow == endRow) {\n                if (isBackwards)\n                    var start = range.end, end = range.start;\n                else\n                    var start = range.start, end = range.end;\n                \n                this.addRange(Range.fromPoints(end, end));\n                this.addRange(Range.fromPoints(start, start));\n                return;\n            }\n\n            var rectSel = [];\n            var r = this.getLineRange(startRow, true);\n            r.start.column = range.start.column;\n            rectSel.push(r);\n\n            for (var i = startRow + 1; i < endRow; i++)\n                rectSel.push(this.getLineRange(i, true));\n\n            r = this.getLineRange(endRow, true);\n            r.end.column = range.end.column;\n            rectSel.push(r);\n\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.toggleBlockSelection = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        } else {\n            var cursor = this.session.documentToScreenPosition(this.cursor);\n            var anchor = this.session.documentToScreenPosition(this.anchor);\n\n            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {\n        var rectSel = [];\n\n        var xBackwards = screenCursor.column < screenAnchor.column;\n        if (xBackwards) {\n            var startColumn = screenCursor.column;\n            var endColumn = screenAnchor.column;\n            var startOffsetX = screenCursor.offsetX;\n            var endOffsetX = screenAnchor.offsetX;\n        } else {\n            var startColumn = screenAnchor.column;\n            var endColumn = screenCursor.column;\n            var startOffsetX = screenAnchor.offsetX;\n            var endOffsetX = screenCursor.offsetX;\n        }\n\n        var yBackwards = screenCursor.row < screenAnchor.row;\n        if (yBackwards) {\n            var startRow = screenCursor.row;\n            var endRow = screenAnchor.row;\n        } else {\n            var startRow = screenAnchor.row;\n            var endRow = screenCursor.row;\n        }\n\n        if (startColumn < 0)\n            startColumn = 0;\n        if (startRow < 0)\n            startRow = 0;\n\n        if (startRow == endRow)\n            includeEmptyLines = true;\n\n        var docEnd;\n        for (var row = startRow; row <= endRow; row++) {\n            var range = Range.fromPoints(\n                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),\n                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)\n            );\n            if (range.isEmpty()) {\n                if (docEnd && isSamePoint(range.end, docEnd))\n                    break;\n                docEnd = range.end;\n            }\n            range.cursor = xBackwards ? range.start : range.end;\n            rectSel.push(range);\n        }\n\n        if (yBackwards)\n            rectSel.reverse();\n\n        if (!includeEmptyLines) {\n            var end = rectSel.length - 1;\n            while (rectSel[end].isEmpty() && end > 0)\n                end--;\n            if (end > 0) {\n                var start = 0;\n                while (rectSel[start].isEmpty())\n                    start++;\n            }\n            for (var i = end; i >= start; i--) {\n                if (rectSel[i].isEmpty())\n                    rectSel.splice(i, 1);\n            }\n        }\n\n        return rectSel;\n    };\n}).call(Selection.prototype);\nvar Editor = require(\"./editor\").Editor;\n(function() {\n    this.updateSelectionMarkers = function() {\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.addSelectionMarker = function(orientedRange) {\n        if (!orientedRange.cursor)\n            orientedRange.cursor = orientedRange.end;\n\n        var style = this.getSelectionStyle();\n        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n\n        this.session.$selectionMarkers.push(orientedRange);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n        return orientedRange;\n    };\n    this.removeSelectionMarker = function(range) {\n        if (!range.marker)\n            return;\n        this.session.removeMarker(range.marker);\n        var index = this.session.$selectionMarkers.indexOf(range);\n        if (index != -1)\n            this.session.$selectionMarkers.splice(index, 1);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n    };\n\n    this.removeSelectionMarkers = function(ranges) {\n        var markerList = this.session.$selectionMarkers;\n        for (var i = ranges.length; i--; ) {\n            var range = ranges[i];\n            if (!range.marker)\n                continue;\n            this.session.removeMarker(range.marker);\n            var index = markerList.indexOf(range);\n            if (index != -1)\n                markerList.splice(index, 1);\n        }\n        this.session.selectionMarkerCount = markerList.length;\n    };\n\n    this.$onAddRange = function(e) {\n        this.addSelectionMarker(e.range);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onRemoveRange = function(e) {\n        this.removeSelectionMarkers(e.ranges);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onMultiSelect = function(e) {\n        if (this.inMultiSelectMode)\n            return;\n        this.inMultiSelectMode = true;\n\n        this.setStyle(\"ace_multiselect\");\n        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onSingleSelect = function(e) {\n        if (this.session.multiSelect.inVirtualMode)\n            return;\n        this.inMultiSelectMode = false;\n\n        this.unsetStyle(\"ace_multiselect\");\n        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n\n        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n        this._emit(\"changeSelection\");\n    };\n\n    this.$onMultiSelectExec = function(e) {\n        var command = e.command;\n        var editor = e.editor;\n        if (!editor.multiSelect)\n            return;\n        if (!command.multiSelectAction) {\n            var result = command.exec(editor, e.args || {});\n            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n            editor.multiSelect.mergeOverlappingRanges();\n        } else if (command.multiSelectAction == \"forEach\") {\n            result = editor.forEachSelection(command, e.args);\n        } else if (command.multiSelectAction == \"forEachLine\") {\n            result = editor.forEachSelection(command, e.args, true);\n        } else if (command.multiSelectAction == \"single\") {\n            editor.exitMultiSelectMode();\n            result = command.exec(editor, e.args || {});\n        } else {\n            result = command.multiSelectAction(editor, e.args || {});\n        }\n        return result;\n    }; \n    this.forEachSelection = function(cmd, args, options) {\n        if (this.inVirtualSelectionMode)\n            return;\n        var keepOrder = options && options.keepOrder;\n        var $byLines = options == true || options && options.$byLines;\n        var session = this.session;\n        var selection = this.selection;\n        var rangeList = selection.rangeList;\n        var ranges = (keepOrder ? selection : rangeList).ranges;\n        var result;\n        \n        if (!ranges.length)\n            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n        \n        var reg = selection._eventRegistry;\n        selection._eventRegistry = {};\n\n        var tmpSel = new Selection(session);\n        this.inVirtualSelectionMode = true;\n        for (var i = ranges.length; i--;) {\n            if ($byLines) {\n                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n                    i--;\n            }\n            tmpSel.fromOrientedRange(ranges[i]);\n            tmpSel.index = i;\n            this.selection = session.selection = tmpSel;\n            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n            if (!result && cmdResult !== undefined)\n                result = cmdResult;\n            tmpSel.toOrientedRange(ranges[i]);\n        }\n        tmpSel.detach();\n\n        this.selection = session.selection = selection;\n        this.inVirtualSelectionMode = false;\n        selection._eventRegistry = reg;\n        selection.mergeOverlappingRanges();\n        if (selection.ranges[0])\n            selection.fromOrientedRange(selection.ranges[0]);\n        \n        var anim = this.renderer.$scrollAnimation;\n        this.onCursorChange();\n        this.onSelectionChange();\n        if (anim && anim.from == anim.to)\n            this.renderer.animateScrolling(anim.from);\n        \n        return result;\n    };\n    this.exitMultiSelectMode = function() {\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n            return;\n        this.multiSelect.toSingleRange();\n    };\n\n    this.getSelectedText = function() {\n        var text = \"\";\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var ranges = this.multiSelect.rangeList.ranges;\n            var buf = [];\n            for (var i = 0; i < ranges.length; i++) {\n                buf.push(this.session.getTextRange(ranges[i]));\n            }\n            var nl = this.session.getDocument().getNewLineCharacter();\n            text = buf.join(nl);\n            if (text.length == (buf.length - 1) * nl.length)\n                text = \"\";\n        } else if (!this.selection.isEmpty()) {\n            text = this.session.getTextRange(this.getSelectionRange());\n        }\n        return text;\n    };\n    \n    this.$checkMultiselectChange = function(e, anchor) {\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var range = this.multiSelect.ranges[0];\n            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n                return;\n            var pos = anchor == this.multiSelect.anchor\n                ? range.cursor == range.start ? range.end : range.start\n                : range.cursor;\n            if (pos.row != anchor.row \n                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)\n                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n            else\n                this.multiSelect.mergeOverlappingRanges();\n        }\n    };\n    this.findAll = function(needle, options, additive) {\n        options = options || {};\n        options.needle = needle || options.needle;\n        if (options.needle == undefined) {\n            var range = this.selection.isEmpty()\n                ? this.selection.getWordRange()\n                : this.selection.getRange();\n            options.needle = this.session.getTextRange(range);\n        }    \n        this.$search.set(options);\n        \n        var ranges = this.$search.findAll(this.session);\n        if (!ranges.length)\n            return 0;\n\n        var selection = this.multiSelect;\n\n        if (!additive)\n            selection.toSingleRange(ranges[0]);\n\n        for (var i = ranges.length; i--; )\n            selection.addRange(ranges[i], true);\n        if (range && selection.rangeList.rangeAtPoint(range.start))\n            selection.addRange(range, true);\n        \n        return ranges.length;\n    };\n    this.selectMoreLines = function(dir, skip) {\n        var range = this.selection.toOrientedRange();\n        var isBackwards = range.cursor == range.end;\n\n        var screenLead = this.session.documentToScreenPosition(range.cursor);\n        if (this.selection.$desiredColumn)\n            screenLead.column = this.selection.$desiredColumn;\n\n        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n\n        if (!range.isEmpty()) {\n            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n        } else {\n            var anchor = lead;\n        }\n\n        if (isBackwards) {\n            var newRange = Range.fromPoints(lead, anchor);\n            newRange.cursor = newRange.start;\n        } else {\n            var newRange = Range.fromPoints(anchor, lead);\n            newRange.cursor = newRange.end;\n        }\n\n        newRange.desiredColumn = screenLead.column;\n        if (!this.selection.inMultiSelectMode) {\n            this.selection.addRange(range);\n        } else {\n            if (skip)\n                var toRemove = range.cursor;\n        }\n\n        this.selection.addRange(newRange);\n        if (toRemove)\n            this.selection.substractPoint(toRemove);\n    };\n    this.transposeSelections = function(dir) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var all = sel.ranges;\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            if (range.isEmpty()) {\n                var tmp = session.getWordRange(range.start.row, range.start.column);\n                range.start.row = tmp.start.row;\n                range.start.column = tmp.start.column;\n                range.end.row = tmp.end.row;\n                range.end.column = tmp.end.column;\n            }\n        }\n        sel.mergeOverlappingRanges();\n\n        var words = [];\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            words.unshift(session.getTextRange(range));\n        }\n\n        if (dir < 0)\n            words.unshift(words.pop());\n        else\n            words.push(words.shift());\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            var tmp = range.clone();\n            session.replace(range, words[i]);\n            range.start.row = tmp.start.row;\n            range.start.column = tmp.start.column;\n        }\n        sel.fromOrientedRange(sel.ranges[0]);\n    };\n    this.selectMore = function(dir, skip, stopAtFirst) {\n        var session = this.session;\n        var sel = session.multiSelect;\n\n        var range = sel.toOrientedRange();\n        if (range.isEmpty()) {\n            range = session.getWordRange(range.start.row, range.start.column);\n            range.cursor = dir == -1 ? range.start : range.end;\n            this.multiSelect.addRange(range);\n            if (stopAtFirst)\n                return;\n        }\n        var needle = session.getTextRange(range);\n\n        var newRange = find(session, needle, dir);\n        if (newRange) {\n            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n            this.session.unfold(newRange);\n            this.multiSelect.addRange(newRange);\n            this.renderer.scrollCursorIntoView(null, 0.5);\n        }\n        if (skip)\n            this.multiSelect.substractPoint(range.cursor);\n    };\n    this.alignCursors = function() {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var ranges = sel.ranges;\n        var row = -1;\n        var sameRowRanges = ranges.filter(function(r) {\n            if (r.cursor.row == row)\n                return true;\n            row = r.cursor.row;\n        });\n        \n        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n            var range = this.selection.getRange();\n            var fr = range.start.row, lr = range.end.row;\n            var guessRange = fr == lr;\n            if (guessRange) {\n                var max = this.session.getLength();\n                var line;\n                do {\n                    line = this.session.getLine(lr);\n                } while (/[=:]/.test(line) && ++lr < max);\n                do {\n                    line = this.session.getLine(fr);\n                } while (/[=:]/.test(line) && --fr > 0);\n                \n                if (fr < 0) fr = 0;\n                if (lr >= max) lr = max - 1;\n            }\n            var lines = this.session.removeFullLines(fr, lr);\n            lines = this.$reAlignText(lines, guessRange);\n            this.session.insert({row: fr, column: 0}, lines.join(\"\\n\") + \"\\n\");\n            if (!guessRange) {\n                range.start.column = 0;\n                range.end.column = lines[lines.length - 1].length;\n            }\n            this.selection.setRange(range);\n        } else {\n            sameRowRanges.forEach(function(r) {\n                sel.substractPoint(r.cursor);\n            });\n\n            var maxCol = 0;\n            var minSpace = Infinity;\n            var spaceOffsets = ranges.map(function(r) {\n                var p = r.cursor;\n                var line = session.getLine(p.row);\n                var spaceOffset = line.substr(p.column).search(/\\S/g);\n                if (spaceOffset == -1)\n                    spaceOffset = 0;\n\n                if (p.column > maxCol)\n                    maxCol = p.column;\n                if (spaceOffset < minSpace)\n                    minSpace = spaceOffset;\n                return spaceOffset;\n            });\n            ranges.forEach(function(r, i) {\n                var p = r.cursor;\n                var l = maxCol - p.column;\n                var d = spaceOffsets[i] - minSpace;\n                if (l > d)\n                    session.insert(p, lang.stringRepeat(\" \", l - d));\n                else\n                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n\n                r.start.column = r.end.column = maxCol;\n                r.start.row = r.end.row = p.row;\n                r.cursor = r.end;\n            });\n            sel.fromOrientedRange(ranges[0]);\n            this.renderer.updateCursor();\n            this.renderer.updateBackMarkers();\n        }\n    };\n\n    this.$reAlignText = function(lines, forceLeft) {\n        var isLeftAligned = true, isRightAligned = true;\n        var startW, textW, endW;\n\n        return lines.map(function(line) {\n            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n            if (!m)\n                return [line];\n\n            if (startW == null) {\n                startW = m[1].length;\n                textW = m[2].length;\n                endW = m[3].length;\n                return m;\n            }\n\n            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n                isRightAligned = false;\n            if (startW != m[1].length)\n                isLeftAligned = false;\n\n            if (startW > m[1].length)\n                startW = m[1].length;\n            if (textW < m[2].length)\n                textW = m[2].length;\n            if (endW > m[3].length)\n                endW = m[3].length;\n\n            return m;\n        }).map(forceLeft ? alignLeft :\n            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n\n        function spaces(n) {\n            return lang.stringRepeat(\" \", n);\n        }\n\n        function alignLeft(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(textW - m[2].length + endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function alignRight(m) {\n            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function unAlign(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n    };\n}).call(Editor.prototype);\n\n\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nexports.onSessionChange = function(e) {\n    var session = e.session;\n    if (session && !session.multiSelect) {\n        session.$selectionMarkers = [];\n        session.selection.$initRangeList();\n        session.multiSelect = session.selection;\n    }\n    this.multiSelect = session && session.multiSelect;\n\n    var oldSession = e.oldSession;\n    if (oldSession) {\n        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n        oldSession.multiSelect.lead.off(\"change\", this.$checkMultiselectChange);\n        oldSession.multiSelect.anchor.off(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session) {\n        session.multiSelect.on(\"addRange\", this.$onAddRange);\n        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n        session.multiSelect.lead.on(\"change\", this.$checkMultiselectChange);\n        session.multiSelect.anchor.on(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n        if (session.selection.inMultiSelectMode)\n            this.$onMultiSelect();\n        else\n            this.$onSingleSelect();\n    }\n};\nfunction MultiSelect(editor) {\n    if (editor.$multiselectOnSessionChange)\n        return;\n    editor.$onAddRange = editor.$onAddRange.bind(editor);\n    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n\n    editor.$multiselectOnSessionChange(editor);\n    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n\n    editor.on(\"mousedown\", onMouseDown);\n    editor.commands.addCommands(commands.defaultCommands);\n\n    addAltCursorListeners(editor);\n}\n\nfunction addAltCursorListeners(editor){\n    var el = editor.textInput.getElement();\n    var altCursor = false;\n    event.addListener(el, \"keydown\", function(e) {\n        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);\n        if (editor.$blockSelectEnabled && altDown) {\n            if (!altCursor) {\n                editor.renderer.setMouseCursor(\"crosshair\");\n                altCursor = true;\n            }\n        } else if (altCursor) {\n            reset();\n        }\n    });\n\n    event.addListener(el, \"keyup\", reset);\n    event.addListener(el, \"blur\", reset);\n    function reset(e) {\n        if (altCursor) {\n            editor.renderer.setMouseCursor(\"\");\n            altCursor = false;\n        }\n    }\n}\n\nexports.MultiSelect = MultiSelect;\n\n\nrequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    enableMultiselect: {\n        set: function(val) {\n            MultiSelect(this);\n            if (val) {\n                this.on(\"changeSession\", this.$multiselectOnSessionChange);\n                this.on(\"mousedown\", onMouseDown);\n            } else {\n                this.off(\"changeSession\", this.$multiselectOnSessionChange);\n                this.off(\"mousedown\", onMouseDown);\n            }\n        },\n        value: true\n    },\n    enableBlockSelect: {\n        set: function(val) {\n            this.$blockSelectEnabled = val;\n        },\n        value: true\n    }\n});\n\n\n\n});\n\nace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\n\n(function() {\n\n    this.foldingStartMarker = null;\n    this.foldingStopMarker = null;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (this.foldingStartMarker.test(line))\n            return \"start\";\n        if (foldStyle == \"markbeginend\"\n                && this.foldingStopMarker\n                && this.foldingStopMarker.test(line))\n            return \"end\";\n        return \"\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        return null;\n    };\n\n    this.indentationBlock = function(session, row, column) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1)\n            return;\n\n        var startColumn = column || line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            var level = session.getLine(row).search(re);\n\n            if (level == -1)\n                continue;\n\n            if (level <= startLevel)\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var start = {row: row, column: column + 1};\n        var end = session.$findClosingBracket(bracket, start, typeRe);\n        if (!end)\n            return;\n\n        var fw = session.foldWidgets[end.row];\n        if (fw == null)\n            fw = session.getFoldWidget(end.row);\n\n        if (fw == \"start\" && end.row > start.row) {\n            end.row --;\n            end.column = session.getLine(end.row).length;\n        }\n        return Range.fromPoints(start, end);\n    };\n\n    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var end = {row: row, column: column};\n        var start = session.$findOpeningBracket(bracket, end);\n\n        if (!start)\n            return;\n\n        start.column++;\n        end.column--;\n\n        return  Range.fromPoints(start, end);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nexports.isDark = false;\nexports.cssClass = \"ace-tm\";\nexports.cssText = \".ace-tm .ace_gutter {\\\nbackground: #f0f0f0;\\\ncolor: #333;\\\n}\\\n.ace-tm .ace_print-margin {\\\nwidth: 1px;\\\nbackground: #e8e8e8;\\\n}\\\n.ace-tm .ace_fold {\\\nbackground-color: #6B72E6;\\\n}\\\n.ace-tm {\\\nbackground-color: #FFFFFF;\\\ncolor: black;\\\n}\\\n.ace-tm .ace_cursor {\\\ncolor: black;\\\n}\\\n.ace-tm .ace_invisible {\\\ncolor: rgb(191, 191, 191);\\\n}\\\n.ace-tm .ace_storage,\\\n.ace-tm .ace_keyword {\\\ncolor: blue;\\\n}\\\n.ace-tm .ace_constant {\\\ncolor: rgb(197, 6, 11);\\\n}\\\n.ace-tm .ace_constant.ace_buildin {\\\ncolor: rgb(88, 72, 246);\\\n}\\\n.ace-tm .ace_constant.ace_language {\\\ncolor: rgb(88, 92, 246);\\\n}\\\n.ace-tm .ace_constant.ace_library {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_invalid {\\\nbackground-color: rgba(255, 0, 0, 0.1);\\\ncolor: red;\\\n}\\\n.ace-tm .ace_support.ace_function {\\\ncolor: rgb(60, 76, 114);\\\n}\\\n.ace-tm .ace_support.ace_constant {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_support.ace_type,\\\n.ace-tm .ace_support.ace_class {\\\ncolor: rgb(109, 121, 222);\\\n}\\\n.ace-tm .ace_keyword.ace_operator {\\\ncolor: rgb(104, 118, 135);\\\n}\\\n.ace-tm .ace_string {\\\ncolor: rgb(3, 106, 7);\\\n}\\\n.ace-tm .ace_comment {\\\ncolor: rgb(76, 136, 107);\\\n}\\\n.ace-tm .ace_comment.ace_doc {\\\ncolor: rgb(0, 102, 255);\\\n}\\\n.ace-tm .ace_comment.ace_doc.ace_tag {\\\ncolor: rgb(128, 159, 191);\\\n}\\\n.ace-tm .ace_constant.ace_numeric {\\\ncolor: rgb(0, 0, 205);\\\n}\\\n.ace-tm .ace_variable {\\\ncolor: rgb(49, 132, 149);\\\n}\\\n.ace-tm .ace_xml-pe {\\\ncolor: rgb(104, 104, 91);\\\n}\\\n.ace-tm .ace_entity.ace_name.ace_function {\\\ncolor: #0000A2;\\\n}\\\n.ace-tm .ace_heading {\\\ncolor: rgb(12, 7, 255);\\\n}\\\n.ace-tm .ace_list {\\\ncolor:rgb(185, 6, 144);\\\n}\\\n.ace-tm .ace_meta.ace_tag {\\\ncolor:rgb(0, 22, 142);\\\n}\\\n.ace-tm .ace_string.ace_regex {\\\ncolor: rgb(255, 0, 0)\\\n}\\\n.ace-tm .ace_marker-layer .ace_selection {\\\nbackground: rgb(181, 213, 255);\\\n}\\\n.ace-tm.ace_multiselect .ace_selection.ace_start {\\\nbox-shadow: 0 0 3px 0px white;\\\n}\\\n.ace-tm .ace_marker-layer .ace_step {\\\nbackground: rgb(252, 255, 0);\\\n}\\\n.ace-tm .ace_marker-layer .ace_stack {\\\nbackground: rgb(164, 229, 101);\\\n}\\\n.ace-tm .ace_marker-layer .ace_bracket {\\\nmargin: -1px 0 0 -1px;\\\nborder: 1px solid rgb(192, 192, 192);\\\n}\\\n.ace-tm .ace_marker-layer .ace_active-line {\\\nbackground: rgba(0, 0, 0, 0.07);\\\n}\\\n.ace-tm .ace_gutter-active-line {\\\nbackground-color : #dcdcdc;\\\n}\\\n.ace-tm .ace_marker-layer .ace_selected-word {\\\nbackground: rgb(250, 250, 255);\\\nborder: 1px solid rgb(200, 200, 250);\\\n}\\\n.ace-tm .ace_indent-guide {\\\nbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\\n}\\\n\";\nexports.$id = \"ace/theme/textmate\";\n\nvar dom = require(\"../lib/dom\");\ndom.importCssString(exports.cssText, exports.cssClass);\n});\n\nace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar Range = require(\"./range\").Range;\n\n\nfunction LineWidgets(session) {\n    this.session = session;\n    this.session.widgetManager = this;\n    this.session.getRowLength = this.getRowLength;\n    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n    this.updateOnChange = this.updateOnChange.bind(this);\n    this.renderWidgets = this.renderWidgets.bind(this);\n    this.measureWidgets = this.measureWidgets.bind(this);\n    this.session._changedWidgets = [];\n    this.$onChangeEditor = this.$onChangeEditor.bind(this);\n    \n    this.session.on(\"change\", this.updateOnChange);\n    this.session.on(\"changeFold\", this.updateOnFold);\n    this.session.on(\"changeEditor\", this.$onChangeEditor);\n}\n\n(function() {\n    this.getRowLength = function(row) {\n        var h;\n        if (this.lineWidgets)\n            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else \n            h = 0;\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1 + h;\n        } else {\n            return this.$wrapData[row].length + 1 + h;\n        }\n    };\n\n    this.$getWidgetScreenLength = function() {\n        var screenRows = 0;\n        this.lineWidgets.forEach(function(w){\n            if (w && w.rowCount && !w.hidden)\n                screenRows += w.rowCount;\n        });\n        return screenRows;\n    };    \n    \n    this.$onChangeEditor = function(e) {\n        this.attach(e.editor);\n    };\n    \n    this.attach = function(editor) {\n        if (editor  && editor.widgetManager && editor.widgetManager != this)\n            editor.widgetManager.detach();\n\n        if (this.editor == editor)\n            return;\n\n        this.detach();\n        this.editor = editor;\n        \n        if (editor) {\n            editor.widgetManager = this;\n            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n            editor.renderer.on(\"afterRender\", this.renderWidgets);\n        }\n    };\n    this.detach = function(e) {\n        var editor = this.editor;\n        if (!editor)\n            return;\n        \n        this.editor = null;\n        editor.widgetManager = null;\n        \n        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n        editor.renderer.off(\"afterRender\", this.renderWidgets);\n        var lineWidgets = this.session.lineWidgets;\n        lineWidgets && lineWidgets.forEach(function(w) {\n            if (w && w.el && w.el.parentNode) {\n                w._inDocument = false;\n                w.el.parentNode.removeChild(w.el);\n            }\n        });\n    };\n\n    this.updateOnFold = function(e, session) {\n        var lineWidgets = session.lineWidgets;\n        if (!lineWidgets || !e.action)\n            return;\n        var fold = e.data;\n        var start = fold.start.row;\n        var end = fold.end.row;\n        var hide = e.action == \"add\";\n        for (var i = start + 1; i < end; i++) {\n            if (lineWidgets[i])\n                lineWidgets[i].hidden = hide;\n        }\n        if (lineWidgets[end]) {\n            if (hide) {\n                if (!lineWidgets[start])\n                    lineWidgets[start] = lineWidgets[end];\n                else\n                    lineWidgets[end].hidden = hide;\n            } else {\n                if (lineWidgets[start] == lineWidgets[end])\n                    lineWidgets[start] = undefined;\n                lineWidgets[end].hidden = hide;\n            }\n        }\n    };\n    \n    this.updateOnChange = function(delta) {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        \n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n        } else if (delta.action == 'remove') {\n            var removed = lineWidgets.splice(startRow + 1, len);\n            removed.forEach(function(w) {\n                w && this.removeLineWidget(w);\n            }, this);\n            this.$updateRows();\n        } else {\n            var args = new Array(len);\n            args.unshift(startRow, 0);\n            lineWidgets.splice.apply(lineWidgets, args);\n            this.$updateRows();\n        }\n    };\n    \n    this.$updateRows = function() {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        var noWidgets = true;\n        lineWidgets.forEach(function(w, i) {\n            if (w) {\n                noWidgets = false;\n                w.row = i;\n                while (w.$oldWidget) {\n                    w.$oldWidget.row = i;\n                    w = w.$oldWidget;\n                }\n            }\n        });\n        if (noWidgets)\n            this.session.lineWidgets = null;\n    };\n\n    this.addLineWidget = function(w) {\n        if (!this.session.lineWidgets)\n            this.session.lineWidgets = new Array(this.session.getLength());\n        \n        var old = this.session.lineWidgets[w.row];\n        if (old) {\n            w.$oldWidget = old;\n            if (old.el && old.el.parentNode) {\n                old.el.parentNode.removeChild(old.el);\n                old._inDocument = false;\n            }\n        }\n            \n        this.session.lineWidgets[w.row] = w;\n        \n        w.session = this.session;\n        \n        var renderer = this.editor.renderer;\n        if (w.html && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.innerHTML = w.html;\n        }\n        if (w.el) {\n            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n            w.el.style.position = \"absolute\";\n            w.el.style.zIndex = 5;\n            renderer.container.appendChild(w.el);\n            w._inDocument = true;\n        }\n        \n        if (!w.coverGutter) {\n            w.el.style.zIndex = 3;\n        }\n        if (w.pixelHeight == null) {\n            w.pixelHeight = w.el.offsetHeight;\n        }\n        if (w.rowCount == null) {\n            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n        }\n        \n        var fold = this.session.getFoldAt(w.row, 0);\n        w.$fold = fold;\n        if (fold) {\n            var lineWidgets = this.session.lineWidgets;\n            if (w.row == fold.end.row && !lineWidgets[fold.start.row])\n                lineWidgets[fold.start.row] = w;\n            else\n                w.hidden = true;\n        }\n            \n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        \n        this.$updateRows();\n        this.renderWidgets(null, renderer);\n        this.onWidgetChanged(w);\n        return w;\n    };\n    \n    this.removeLineWidget = function(w) {\n        w._inDocument = false;\n        w.session = null;\n        if (w.el && w.el.parentNode)\n            w.el.parentNode.removeChild(w.el);\n        if (w.editor && w.editor.destroy) try {\n            w.editor.destroy();\n        } catch(e){}\n        if (this.session.lineWidgets) {\n            var w1 = this.session.lineWidgets[w.row];\n            if (w1 == w) {\n                this.session.lineWidgets[w.row] = w.$oldWidget;\n                if (w.$oldWidget)\n                    this.onWidgetChanged(w.$oldWidget);\n            } else {\n                while (w1) {\n                    if (w1.$oldWidget == w) {\n                        w1.$oldWidget = w.$oldWidget;\n                        break;\n                    }\n                    w1 = w1.$oldWidget;\n                }\n            }\n        }\n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        this.$updateRows();\n    };\n    \n    this.getWidgetsAtRow = function(row) {\n        var lineWidgets = this.session.lineWidgets;\n        var w = lineWidgets && lineWidgets[row];\n        var list = [];\n        while (w) {\n            list.push(w);\n            w = w.$oldWidget;\n        }\n        return list;\n    };\n    \n    this.onWidgetChanged = function(w) {\n        this.session._changedWidgets.push(w);\n        this.editor && this.editor.renderer.updateFull();\n    };\n    \n    this.measureWidgets = function(e, renderer) {\n        var changedWidgets = this.session._changedWidgets;\n        var config = renderer.layerConfig;\n        \n        if (!changedWidgets || !changedWidgets.length) return;\n        var min = Infinity;\n        for (var i = 0; i < changedWidgets.length; i++) {\n            var w = changedWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.session != this.session) continue;\n            if (!w._inDocument) {\n                if (this.session.lineWidgets[w.row] != w)\n                    continue;\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            \n            w.h = w.el.offsetHeight;\n            \n            if (!w.fixedWidth) {\n                w.w = w.el.offsetWidth;\n                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n            }\n            \n            var rowCount = w.h / config.lineHeight;\n            if (w.coverLine) {\n                rowCount -= this.session.getRowLineCount(w.row);\n                if (rowCount < 0)\n                    rowCount = 0;\n            }\n            if (w.rowCount != rowCount) {\n                w.rowCount = rowCount;\n                if (w.row < min)\n                    min = w.row;\n            }\n        }\n        if (min != Infinity) {\n            this.session._emit(\"changeFold\", {data:{start:{row: min}}});\n            this.session.lineWidgetWidth = null;\n        }\n        this.session._changedWidgets = [];\n    };\n    \n    this.renderWidgets = function(e, renderer) {\n        var config = renderer.layerConfig;\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var first = Math.min(this.firstRow, config.firstRow);\n        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n        \n        while (first > 0 && !lineWidgets[first])\n            first--;\n        \n        this.firstRow = config.firstRow;\n        this.lastRow = config.lastRow;\n\n        renderer.$cursorLayer.config = config;\n        for (var i = first; i <= last; i++) {\n            var w = lineWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.hidden) {\n                w.el.style.top = -100 - (w.pixelHeight || 0) + \"px\";\n                continue;\n            }\n            if (!w._inDocument) {\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;\n            if (!w.coverLine)\n                top += config.lineHeight * this.session.getRowLineCount(w.row);\n            w.el.style.top = top - config.offset + \"px\";\n            \n            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n            if (!w.fixedWidth)\n                left -= renderer.scrollLeft;\n            w.el.style.left = left + \"px\";\n            \n            if (w.fullWidth && w.screenWidth) {\n                w.el.style.minWidth = config.width + 2 * config.padding + \"px\";\n            }\n            \n            if (w.fixedWidth) {\n                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n            } else {\n                w.el.style.right = \"\";\n            }\n        }\n    };\n    \n}).call(LineWidgets.prototype);\n\n\nexports.LineWidgets = LineWidgets;\n\n});\n\nace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/line_widgets\",\"ace/lib/dom\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar LineWidgets = require(\"../line_widgets\").LineWidgets;\nvar dom = require(\"../lib/dom\");\nvar Range = require(\"../range\").Range;\n\nfunction binarySearch(array, needle, comparator) {\n    var first = 0;\n    var last = array.length - 1;\n\n    while (first <= last) {\n        var mid = (first + last) >> 1;\n        var c = comparator(needle, array[mid]);\n        if (c > 0)\n            first = mid + 1;\n        else if (c < 0)\n            last = mid - 1;\n        else\n            return mid;\n    }\n    return -(first + 1);\n}\n\nfunction findAnnotations(session, row, dir) {\n    var annotations = session.getAnnotations().sort(Range.comparePoints);\n    if (!annotations.length)\n        return;\n    \n    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);\n    if (i < 0)\n        i = -i - 1;\n    \n    if (i >= annotations.length)\n        i = dir > 0 ? 0 : annotations.length - 1;\n    else if (i === 0 && dir < 0)\n        i = annotations.length - 1;\n    \n    var annotation = annotations[i];\n    if (!annotation || !dir)\n        return;\n\n    if (annotation.row === row) {\n        do {\n            annotation = annotations[i += dir];\n        } while (annotation && annotation.row === row);\n        if (!annotation)\n            return annotations.slice();\n    }\n    \n    \n    var matched = [];\n    row = annotation.row;\n    do {\n        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n        annotation = annotations[i += dir];\n    } while (annotation && annotation.row == row);\n    return matched.length && matched;\n}\n\nexports.showErrorMarker = function(editor, dir) {\n    var session = editor.session;\n    if (!session.widgetManager) {\n        session.widgetManager = new LineWidgets(session);\n        session.widgetManager.attach(editor);\n    }\n    \n    var pos = editor.getCursorPosition();\n    var row = pos.row;\n    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {\n        return w.type == \"errorMarker\";\n    })[0];\n    if (oldWidget) {\n        oldWidget.destroy();\n    } else {\n        row -= dir;\n    }\n    var annotations = findAnnotations(session, row, dir);\n    var gutterAnno;\n    if (annotations) {\n        var annotation = annotations[0];\n        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n            ? annotation.pos.sc\n            : annotation.column) || 0;\n        pos.row = annotation.row;\n        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n    } else if (oldWidget) {\n        return;\n    } else {\n        gutterAnno = {\n            text: [\"Looks good!\"],\n            className: \"ace_ok\"\n        };\n    }\n    editor.session.unfold(pos.row);\n    editor.selection.moveToPosition(pos);\n    \n    var w = {\n        row: pos.row, \n        fixedWidth: true,\n        coverGutter: true,\n        el: dom.createElement(\"div\"),\n        type: \"errorMarker\"\n    };\n    var el = w.el.appendChild(dom.createElement(\"div\"));\n    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n    \n    var left = editor.renderer.$cursorLayer\n        .getPixelPosition(pos).left;\n    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n    \n    w.el.className = \"error_widget_wrapper\";\n    el.className = \"error_widget \" + gutterAnno.className;\n    el.innerHTML = gutterAnno.text.join(\"<br>\");\n    \n    el.appendChild(dom.createElement(\"div\"));\n    \n    var kb = function(_, hashId, keyString) {\n        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n            w.destroy();\n            return {command: \"null\"};\n        }\n    };\n    \n    w.destroy = function() {\n        if (editor.$mouseHandler.isMousePressed)\n            return;\n        editor.keyBinding.removeKeyboardHandler(kb);\n        session.widgetManager.removeLineWidget(w);\n        editor.off(\"changeSelection\", w.destroy);\n        editor.off(\"changeSession\", w.destroy);\n        editor.off(\"mouseup\", w.destroy);\n        editor.off(\"change\", w.destroy);\n    };\n    \n    editor.keyBinding.addKeyboardHandler(kb);\n    editor.on(\"changeSelection\", w.destroy);\n    editor.on(\"changeSession\", w.destroy);\n    editor.on(\"mouseup\", w.destroy);\n    editor.on(\"change\", w.destroy);\n    \n    editor.session.widgetManager.addLineWidget(w);\n    \n    w.el.onmousedown = editor.focus.bind(editor);\n    \n    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});\n};\n\n\ndom.importCssString(\"\\\n    .error_widget_wrapper {\\\n        background: inherit;\\\n        color: inherit;\\\n        border:none\\\n    }\\\n    .error_widget {\\\n        border-top: solid 2px;\\\n        border-bottom: solid 2px;\\\n        margin: 5px 0;\\\n        padding: 10px 40px;\\\n        white-space: pre-wrap;\\\n    }\\\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\\\n        border-color: #ff5a5a\\\n    }\\\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\\n        border-color: #F1D817\\\n    }\\\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\\\n        border-color: #5a5a5a\\\n    }\\\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\\n        border-color: #5aaa5a\\\n    }\\\n    .error_widget_arrow {\\\n        position: absolute;\\\n        border: solid 5px;\\\n        border-top-color: transparent!important;\\\n        border-right-color: transparent!important;\\\n        border-left-color: transparent!important;\\\n        top: -5px;\\\n    }\\\n\", \"\");\n\n});\n\nace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/range\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\n\nvar Range = require(\"./range\").Range;\nvar Editor = require(\"./editor\").Editor;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nrequire(\"./worker/worker_client\");\nrequire(\"./keyboard/hash_handler\");\nrequire(\"./placeholder\");\nrequire(\"./multi_select\");\nrequire(\"./mode/folding/fold_mode\");\nrequire(\"./theme/textmate\");\nrequire(\"./ext/error_marker\");\n\nexports.config = require(\"./config\");\nexports.require = require;\n\nif (typeof define === \"function\")\n    exports.define = define;\nexports.edit = function(el, options) {\n    if (typeof el == \"string\") {\n        var _id = el;\n        el = document.getElementById(_id);\n        if (!el)\n            throw new Error(\"ace.edit can't find div #\" + _id);\n    }\n\n    if (el && el.env && el.env.editor instanceof Editor)\n        return el.env.editor;\n\n    var value = \"\";\n    if (el && /input|textarea/i.test(el.tagName)) {\n        var oldNode = el;\n        value = oldNode.value;\n        el = dom.createElement(\"pre\");\n        oldNode.parentNode.replaceChild(el, oldNode);\n    } else if (el) {\n        value = el.textContent;\n        el.innerHTML = \"\";\n    }\n\n    var doc = exports.createEditSession(value);\n\n    var editor = new Editor(new Renderer(el), doc, options);\n\n    var env = {\n        document: doc,\n        editor: editor,\n        onResize: editor.resize.bind(editor, null)\n    };\n    if (oldNode) env.textarea = oldNode;\n    event.addListener(window, \"resize\", env.onResize);\n    editor.on(\"destroy\", function() {\n        event.removeListener(window, \"resize\", env.onResize);\n        env.editor.container.env = null; // prevent memory leak on old ie\n    });\n    editor.container.env = editor.env = env;\n    return editor;\n};\nexports.createEditSession = function(text, mode) {\n    var doc = new EditSession(text, mode);\n    doc.setUndoManager(new UndoManager());\n    return doc;\n};\nexports.Range = Range;\nexports.Editor = Editor;\nexports.EditSession = EditSession;\nexports.UndoManager = UndoManager;\nexports.VirtualRenderer = Renderer;\nexports.version = \"1.4.4\";\n});            (function() {\n                ace.require([\"ace/ace\"], function(a) {\n                    if (a) {\n                        a.config.init(true);\n                        a.define = ace.define;\n                    }\n                    if (!window.ace)\n                        window.ace = a;\n                    for (var key in a) if (a.hasOwnProperty(key))\n                        window.ace[key] = a[key];\n                    window.ace[\"default\"] = window.ace;\n                    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                        module.exports = window.ace;\n                    }\n                });\n            })();\n        \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ace-builds/src-noconflict/ace.js\n// module id = 15\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 16\n// module chunks = 0","// Imports\nconst vm = require('vm');\nconst util = require('util');\n\n/*\n*   Handles code from Ace Editor\n*/\nexport class AceHandler {\n    constructor() {}\n\n    runCode(code, variables) {\n\n        const script = new vm.Script(code);\n\n        const sandbox = {};\n        script.runInNewContext(sandbox);\n    \n        var results = [];\n        \n        variables.forEach((variable) => {\n            results.push(variable + ': ' + util.inspect(sandbox[variable]));\n        })\n\n        return results\n    }\n\n    runFunction(code, functionName, variables) {\n        const script = new vm.Script(code);\n\n        const sandbox = {};\n        script.runInNewContext(sandbox);\n        console.log(...variables);\n        console.log(variables);\n        return util.inspect(sandbox[functionName](...variables));        \n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/aceHandler.js","var indexOf = function (xs, item) {\n    if (xs.indexOf) return xs.indexOf(item);\n    else for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === item) return i;\n    }\n    return -1;\n};\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    if (context) {\n        forEach(Object_keys(ctx), function (key) {\n            context[key] = ctx[key];\n        });\n    }\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.isContext = function (context) {\n    return context instanceof Context;\n};\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vm-browserify/index.js\n// module id = 18\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/util.js\n// module id = 19\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/support/isBufferBrowser.js\n// module id = 20\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/node_modules/inherits/inherits_browser.js\n// module id = 21\n// module chunks = 0","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('div',{attrs:{\"id\":\"editor\"}}),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"shell\"}},[_vm._m(0),_vm._v(\" \"),_c('div',{staticClass:\"input-line\"},[_c('span',{staticStyle:{\"font-size\":\"10px\"}},[_vm._v(\">\")]),_vm._v(\" \"),_c('form',{on:{\"submit\":function($event){$event.preventDefault();return _vm.runCommand()}}},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.shellInput),expression:\"shellInput\"}],attrs:{\"type\":\"text\"},domProps:{\"value\":(_vm.shellInput)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.shellInput=$event.target.value}}})])])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"shell-content\"},[_c('p',[_vm._v(\"Interactive JavaScript Shell\")])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-13a01a4a\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n// module id = 22\n// module chunks = 0"],"sourceRoot":""}